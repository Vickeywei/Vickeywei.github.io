<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[property认识]]></title>
    <url>%2F2019%2F01%2F29%2Fproperty%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[@property为什么要讨论这些问题?因为这些东西在平常开发是很难用到的,但是在面试和找工作的过程中就会被提及,公司不仅需要实战者,也需要理论和实战相结合的人.所以我们要掌握理论来完成实战.@property本质是什么?@property为我们做了哪几件事?分类如何为类添加属性?能够添加实例变量吗?通过编译的类能够添加实例变量?在运行时创建的类能否添加实例变量?我们将从这几个方面来查找和解决这个问题?property是我们在开发中为某个类来添加属性的声明方式.它为了我们做了三件事情,1.生成带有下划线的实例变量,2.生成getter方法,3.生成setter方法.settet和getter也被称为属性合成方法.平时我们开发过程中不需要写,编译器会帮我们完成这项繁琐的工作.但是如果我们需要自己实现该如何写呢?@implementation MJPerson@synthesize name =_name;- (NSString )name{return @”1111”;}- (void)setName:(NSString )name {_name = name;}关键字:@synthesize和@dynamic这个稍后讨论分类是不可以添加实例变量的,因为在类经过编译后,类的objc_ivar_list已经确定,并且已经调用了class_setIvarLayout和class_setWeakIvarLayout已经确定了实例变量的布局,所以无法增加实例变量那么分类是否可以添加属性呢?答案是肯定的,因为在运行时环境中,我们可以采用关联引用为类动态添加属性//设置属性的值OBJC_EXPORT void objc_setAssociatedObject(id _Nonnull object, const void _Nonnull key,id _Nullable value, objc_AssociationPolicy policy)//获取属性的值OBJC_EXPORTid_Nullableobjc_getAssociatedObject(id _Nonnull object, const void _Nonnull key)OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);//移除属性OBJC_EXPORT voidobjc_removeAssociatedObjects(id _Nonnull object) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);上面第一个方法是设置关联属性的值,必须给定一个object,一个唯一的key,和缓存策略.我们再给定一个唯一的key是要注意,我们再获取时也需要用到这个key所以必须具有唯一性.所以我们一般使用static char来定义这个key,在选择缓存策略时就要考虑这个属性的类型,如果输基础数据类型,就是assign,如果是对象就是retain,如果是字符串或者是block等要选择copy.这个缓存策略中在对象时,会有NONATOMIC和atomic这个的选择和我们声明属性一致.第二个方式是获取关联属性的值,参数为关联的属性和唯一的key第三个方法是移除所有的关联属性,我们要想移除单个关联属性,应该调用设置关联属性值的函数,并且设置value为nil我们无法给通过编译的类,添加实例变量,但是我们可以给运行时创建的类添加实例变量.runtime函数如下://首先创建类OBJC_EXPORT Class _Nullableobjc_allocateClassPair(Class _Nullable superclass, const char _Nonnull name, size_t extraBytes)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);//为类添加属性参数:创建的类,属性名称,和修饰属性的关键字属性数组,属性数组countOBJC_EXPORT BOOLclass_addProperty(Class _Nullable cls, const char _Nonnull name,const objc_property_attribute_t * _Nullable attributes,unsigned int attributeCount)OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0);//注册类objc_registerClassPair(cls);我们可以为这个类添加属性,添加方法,添加协议等等,还可以添加实例变量,但是这个类必须包含一个同名的实例变量好了上面的四个小问题说完了,该说刚才说的@synthesize和@dynamic,如果两个都没写就是@ synthesize property=_property,@synthesize系统会帮我们自动实现setter和getter方法,@dynamic 需要我们自己实现setter和getter方法,如果不实现,就会出现崩溃,因为这个是你告诉系统说,我要自己实现,系统自然不会帮你实现,但是你却没实现,然后就找不到方法了.说起属性就要说属性的默认关键字:基础数据类型:内存关键字:assign,读写属性:readwrite,原子性:atomic,对象类型:内存关键字:strong,读写属性:readWrite,原子性:atomic重点: 关联引用属性的setter和getter的合成方式,@synthesize自动合成,@dynamic手动合成.如何为运行时创建的类添加属性,方法等在上面代码中,由于macdown的编辑器*都被阉割掉了.抱歉!]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>property本质</tag>
        <tag>property做了哪些事情</tag>
        <tag>分类添加属性</tag>
        <tag>如何给运行时创建的类添加属性,方法等</tag>
        <tag>属性的默认关键字</tag>
        <tag>synthesize和dynamic区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime方法查找]]></title>
    <url>%2F2019%2F01%2F25%2Fruntime%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[runtime是如何查找到一个方法的在iOS开发过程中我们知道OC语言是C语言的超集.并且将SmallTalk的消息传递特性加入了其中,使得Objective-C也具有了消息传递这一特性.Objective-C方法调用的本质既然说Objective-C结合了smallTalk的消息传递,那自然也是将这个特性发挥到了这个方面,而且Objective-C作为一门动态语言,与其他面向对象语言不同,它总是想办法把一些决定工作从编译连接推迟到运行时.Objective-C依赖运行时系统,runtime运行时库提供了很多在运行时过程中操作类和对象的API.而我们的方法调用就是依赖于这个运行时系统.MJPerson person = [[MJPerson alloc] init];person.name=@”1111”;[person print];这是我们使用OC语言开发中常见的方法调用,那么它底层做了什么呢?它是怎么用到消息传递机制的?下面我们再看这段代码:MJPerson person = objc_msgSend(objc_getClass(“MJPerson”), @selector(alloc));objc_msgSend(person, @selector(init));objc_msgSend(person, @selector(setName:),@”11111”);objc_msgSend(person, @selector(print));系统会在调用方法时都会将方法调用转成消息传递的方式进行.那么就让我们来通过runtime的源代码看一下:alloc方法alloc是NSObject的类方法,而我们大多数的类都继承于NSObject.和不常见的NSProxy.我们也知道通过继承,我们可以继承父类的属性和方法那么在调用alloc方法后,系统是如何找到该方法的实现的.因为在runtime中关于objc_class的定义中有objc_ivar_list和objc_method_list还有objc_cache还有objc_protocol_list.通过名称我们也能知道一个是成员变量列表,一个是方法列表一个是方法缓存列表,一个是协议列表.查找方法肯定先会找方法缓存列表,别问我为什么?,因为这是系统对方法调用进行的优化,有缓存直接使用缓存,减少查找,增快效率,如果没有缓存,就找方法列表,找到就返回并执行,如果没找到就找父类,一直向上查找,如果找到根类还没有找到,就看有没有转发,如果有转发就执行转发,如果没有那就只能抛出异常.上面说到的是怎么寻找方法,alloc做为类方法,我们也知道类方法存在于元类的方法列表当中,然后和上面的步骤相同进行查找alloc方法查找代码://1,查找类方法Method class_getClassMethod(Class cls, SEL sel){if (!cls || !sel)return nil;return class_getInstanceMethod(cls-&gt;getMeta(), sel);//在这里我们首先获取了cls的元类metaClass,然后查找元类的方法列表}//2.查找类的实例方法Method class_getInstanceMethod(Class cls, SEL sel){if (!cls || !sel) return nil;//判断cls和方法编号是否存在#warning fixme build and search cacheslookUpImpOrNil(cls, sel, nil, NO/initialize/, NO/cache/, YES/resolver/);//查找方法缓存;在查找方法缓存是会看到cache_getImp这个函数.但是无法查看它的内部实现,但是runtime源码中有这个方法的汇编代码,一会可以通过汇编代码进行大致了解.#warning fixme build and search cachesreturn _class_getMethod(cls, sel);//如果缓存中没有找到,就会查找方法列表,并同时会创建缓存链表,如果找到方法实现就进行方法缓存}//3.cache_getImp的汇编代码STATIC_ENTRY _cache_getImpmov r9, r0 :r0标识要在哪个缓存类中搜索,将r0寄存器的值传递给r9寄存器.在后面解释lookUpImpOrForward源代码是会看到,_cache_getImp传入的参数是cls,和方法编号,如果是类方法传入的就是metaClass,如果是实例方法就是当前类.CacheLookup NORMAL //这个宏定义中r0和r1表示消息接收者,r1或r2代表方法编号;方法实现imp在r12中mov r0, r12 //缓存命中,方法的实现在r12寄存器中,然后传递给r0寄存器;如果没命中就继续执行cacheLookup2bx lr // return impCacheLookup2 GETIMP// 缓存没命中,丢失返回nilmov r0, #0bx lrEND_ENTRY _cache_getImp//objc_msgSend汇编代码ENTRY _objc_msgSend MESSENGER_START cbz r0, LNilReceiver_f //判断消息接收者是否为nil ldr r9, [r0] // r9 = self-&gt;isa GetClassFromIsa // r9 = class CacheLookup NORMAL //缓存命中,直接调用imp nonstret forwarding MESSENGER_END_FAST bx r12 // call imp CacheLookup2 NORMAL //缓存miss ldr r9, [r0] // r9 = self-&gt;isa GetClassFromIsa // r9 = class MESSENGER_END_SLOW b __objc_msgSend_uncached //方法未缓存 STATIC_ENTRY __objc_msgSend_uncached // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band r9 is the class to search MethodTableLookup NORMAL // returns IMP in r12 bx r12 END_ENTRY __objc_msgSend_uncached STATIC_ENTRY __objc_msgSend_stret_uncached // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band r9 is the class to search MethodTableLookup STRET // returns IMP in r12 bx r12 END_ENTRY __objc_msgSend_stret_uncached STATIC_ENTRY __objc_msgLookup_uncached // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band r9 is the class to search MethodTableLookup NORMAL // returns IMP in r12 bx lr END_ENTRY __objc_msgLookup_uncached STATIC_ENTRY __objc_msgLookup_stret_uncached // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band r9 is the class to search MethodTableLookup STRET // returns IMP in r12 bx lr END_ENTRY __objc_msgLookup_stret_uncached 可能看不懂汇编,而且和我们学的8086汇编不同,但是从它的注释中我们可以看出首先会判断消息接收者是否为nil,然后在缓存方法查找,如果找到直接call imp,如果没找到就表明该方法没缓存就执行__objc_msgSend_uncached 在这个汇编代码中可以看到MethodTableLookup;我们再查看这个到底是什么东西.macro MethodTableLookup stmfd sp!, {r0-r3,r7,lr} add r7, sp, #16 sub sp, #8 // align stack FP_SAVE.if $0 == NORMAL // receiver already in r0 // selector already in r1.else mov r0, r1 // receiver mov r1, r2 // selector.endif mov r2, r9 // class to search blx __class_lookupMethodAndLoadCache3 mov r12, r0 // r12 = IMP.if $0 == NORMAL cmp r12, r12 // set eq for nonstret forwarding.else tst r12, r12 // set ne for stret forwarding.endif FP_RESTORE add sp, #8 // align stack ldmfd sp!, {r0-r3,r7,lr}.endmacro在这个宏定义中,我们看到了__class_lookupMethodAndLoadCache3这个方法名,然后在runtime的方法中查找,找到了函数的实现IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls){ return lookUpImpOrForward(cls, sel, obj, YES/initialize/, NO/cache/, YES/resolver/);}IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // Optimistic cache lookup if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.read(); if (!cls-&gt;isRealized()) { // Drop the read-lock and acquire the write-lock. // realizeClass() checks isRealized() again to prevent // a race while the lock is down. runtimeLock.unlockRead(); runtimeLock.write(); realizeClass(cls); runtimeLock.unlockWrite(); runtimeLock.read(); } if (initialize &amp;&amp; !cls-&gt;isInitialized()) { runtimeLock.unlockRead(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.read(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won’t happen. 2778172 } retry: runtimeLock.assertReading(); // Try this class’s cache. imp = cache_getImp(cls, sel); if (imp) goto done; // Try this class’s method lists. { Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; } } // Try superclass caches and method lists. { unsigned attempts = unreasonableClassCount(); for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) { // Halt if there is a cycle in the superclass chain. if (–attempts == 0) { _objc_fatal(“Memory corruption in class list.”); } // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don’t cache yet; call method // resolver for this class first. break; } } // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; } } } // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don’t cache the result; we don’t hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } // No implementation found, and method resolver didn’t help. // Use forwarding. imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); return imp;}通过上面的代码已经很明显能看出了,方法是如何被查找到的.首先我们忽略锁的操作,然后主要看关心的部分,如果cache传入的为yes,就会去类方法缓存列表中去找,如果存在就返回,否则就看有没有被初始化.初始化过的直接查找this class’s method list,如果找到就done,并为imp赋值.如果不存在就查找superclass caches and method lists.如果找到了就done,并为imp赋值.如果还没找到方法实现,然后会判断是否有能处理的对象,也是就是我们刚才提到的走转发,如果没有找到方法,也没有转发那么就会failure. 扩展 下面这段方法就是查找类方法列表是调用的方法,然后都是循环遍历cls-&gt;data()-&gt;methods.beiginLists到endLists?方法不是放在结构体objc_method_list中的吗? 然后我们一层一层往上找,在objc-runtime-new.h中objc_class:objc_object的定义中看到了data(),他是一个class_rw_t*指针,然后点进去看到了我们看到的methods,properties,protocols,firstSubClass,还有很多函数和成员变量,我们关心的就这三个,方法,属性列表,和协议列表.而且发现runtime.h中的定义和objc-runtime-new中的定义不同了.runtime使用的是结构体,而new中使用的是c++中的类.然后我再看了class_copyProtocolList函数也是通过遍历cls-&gt;data()-&gt;protocols,然后查看objc_getivar也是通过cls-&gt;data()-&gt;ro-&gt;ivars来获取,所以明白runtime中定义的是老的版本,而new中定义的是新版本的.但是对于两者都进行了解比较好 static method_t * getMethodNoSuper_nolock(Class cls, SEL sel) { runtimeLock.assertLocked(); assert(cls->isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls->data()->methods.beginLists(), end = cls->data()->methods.endLists(); mlists != end; ++mlists) { method_t *m = search_method_list(*mlists, sel); if (m) return m; } return nil; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[基础知识 汇编语言的组成汇编指令伪指令其他符号:如+,-,*,/等 存储器CPU所需要的指令和数据都在存储器中存放,也就是我们所说的内存当中.磁盘不同于内存,磁盘上的数据或程序如果不读到内存中,就无法被CPU使用.指令和数据在内存或磁盘上,指令和数据没有任何区别,都是二进制信息.存储单元存储器被划分成或干戈存储单元,每个存储单元从0开始顺序额编号.微机存储器的容量是以字节为最小单位来计算的.CPU对存储器的读写CPU要从内存中读数据,首先要指定存储单元的地址.在一台微机中不是只有存储器这一种器件,CPU在读写数据时还要指明,他要对哪一个器件进行操作.进行哪种操作,是读出数据还是写入数据.CPU读写数据时的必备条件存储单元的地址器件的选择,读或写的命令读或写的数据 总线电子计算机能处理,传输的信息都是电信号,电信号当然要用导线传送,在计算机中专门有链接CPU和其他芯片的导线,通常称为总线地址总线控制总线数据总线地址总线CPU是通过地址总线来指定存储单元的,可见地址总线能传送多少个不同的信息,CPU就可以对多少个存储单元进行寻址.一个CPU有N根地址线,则可以说这个CPU的地址总线的宽度为N.这样CPU最多可以寻找2的N次方个内存单元数据总线数据总线的宽度决定了CPU和外界的数据传送速度.8根数据总线一次课传送一个8位二进制数据(一个字节).16根数据总线一次可传送两个字节控制总线有多少根控制总线,就意味着CPU提供了对外部期间的多少种控制.所以控制总线的宽度决定了CPU对外部器件的控制能力总结汇编指令是机器指令的助记符,统计器指令一一对应每一种CPU都有自己的汇编指令集CPU可以直接使用的信息在存储器中存放在存储其中的指令和数据没有任何区别,都是二进制信息存储单元从零开始顺序编号一个存储单元可以存储8个bit,即8位二进制数(一个字节)每一个CPU芯片都有许多管教,这些管脚和总线相连.也可以说这些管教引出总线.一个CPU可以引出3中总线的宽度标志了这个CPU的不同方面的性能,地址总线的宽度决定了CPU的寻址能力,数据总线的宽度决定了CPU与其他部件进行数据传送石的一次数据传送量.控制总线的宽度决定了CPU对系统中其他期间的控制能力内存地址空间一个CPU的地址总线宽度为10,那么可以寻址1024个内存单元(byte,8bit),这个1024个可寻到的内存单元就构成这个CPU的内存地址空间主板主板上有核心器件和一些主要器件,这些器件通过总线(地址,数据,控制总线)相连.这些器件有CPU,存储器,外围芯片组,扩展插槽.扩展插槽上一般由RAM内存条和各类接口卡接口卡CPU对外部设备不能直接控制.直接控制这些设备进行工作的是插在扩展插槽上的接口卡.扩展插槽通过总线和CPU相连,所以接口卡也通过总线同CPU相连.CPU可以直接控制这些接口卡,从而实现CPU对外设的间接控制.CPU通过总线向接口卡发送命令,接口卡根据CPU的命令控制外设进行工作.各类存储器芯片存储器芯片从物理连接上看是独立的.不同的期间.从读写属性分为随机存储器和只读存储器.随机存储器可读可写,但必须带电存储.关机后存储的内容丢失.只读存储器只能读取不能写入.关机后其中的内容不丢失随机存储器,用于存放工CPU使用的大部分程序和数据,主随机存储器一般由两个位置的RAM组成,装在主板上的RAM和插在扩展插槽上的RAM装有BIOS的ROM接口卡上的RAM某些接口卡上需要对大批量输入,输出数据进行暂时存储,在其上装有RAM最典型的就是显示卡上的RAM,一般称为显存.内存地址空间上述的存储器在物理上是独立的期间.但是都与CPU的总线相连接.CPU对他们进行读或写的时候都通过控制总线发出内存读写命令CPU在操作他们的时候,把他们都当做内存来对待,把他们总的看做一个由若干存储单元组成的逻辑存储器,这个逻辑存储器就是我们所说的内存地址空间寄存器一个CPU是由运算器,控制器,寄存器等期间构成,这些期间靠内部总线相连.运算器进行信息处理寄存器进行信息存储控制器控制各种器件进行工作内部总线连接各种器件,在它们之间进行数据的传送CPU中的主要部件是寄存器,寄存器是CPU中程序员可以用指令读写的部件.程序员通过改变各种寄存器中的内容来实现对CPU的控制通用寄存器8086CPU的所有紧蹙起都是16位的,可以存放两个字节.AX,BX,CX,DX这四个寄存器通常用来存放一般性的数据,被称为通用寄存器8086CPU为了兼容上一代寄存器(8位)所以8086CPU的AX,BX,CX,DX这四个寄存器都可分为两个可独立使用的8位寄存器来用:AX可分为AH和ALBX可分为BH和BLCX可分为CH和CLDX可分为DH和DL字在寄存器中的存储字节:记为byte,一个字节有8bit组成,可以存放在8位寄存器中字:记为word,一个字由两个字节组成,这两个字节分别称为这个字的高位字节和低位字几条汇编指令mov ax,18 将18送入寄存器AXmov ah,78 将78送入寄存器AHadd ax,8 将寄存器AX的值加上8mov ax,bx 将寄存器bx中的数据送入寄存器AXadd ax,bx 将AX和BX的数值相加,结果存在寄存器AXmov ax,4e20hadd ax,1406hmov bx,2000hadd ax,bxmov bx,axadd ax,bx本来ax中的值为1044ch但是由于ax寄存器为16位,只能保存16位数.所以最高位的1,被舍弃,ax的数据为044chmov ax,001ahmov bx,0026hadd al,bladd ah,bladd bh,almov ah,0add al,85hadd al,93h 注意在进行数据传送和运算时,要注意指令的两个操作对象的位数应当是一致的 物理地址所有的内存单元构成的存储空间是一个一维的线性空间,每一个内存单元在这个空间中都有唯一的地址,我们将这个唯一的地址称为物理地址.CPU通过地址总线送入村塾琦的,必须是一个内存单元的物理地址 16位结构的CPU16位CPU具有下面几方面的结构特性运算器一次最多可以处理16位的数据寄存器的最大宽度为16位寄存器和运算器之间的通路为16位8084是16位结构的CPU,这也就是说,在8086内部,能够一次性处理,传输,暂时存储的信息的最大长度是16位的.内存单元的地址在送上地址总线之前,必须在CPU中处理,传输,暂时存放. 8086CPU给出物理地址的方法8086CPU有20位地址总线,可以传送20位地址,达到1MB寻址能力.8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址CPU中的相关部件提供两个16位的地址,一个称谓段地址,一个称为偏移地址段地址和偏移地址通过内部总线送入一个称为地址加法器的部件地址加法器将两个16位的地址合成为一个20位的物理地址地址加法器通过内部总线将20位物理地址送入输入输出控制电路输入输出控制电路将20位物理地址送上地址总线20位物理地址被地址总线传送到存储器地址加法器采用物理地址=段地址x16+偏移地址的方法用段地址和偏移地址合成物理地址 段地址x16(16进制向左移一位)+偏移地址=物理地址的本质在CPU访问内存时,用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加给出内存单元的物理地址 段的概念内存并没有分段,段的划分来自于CPU,由于8086CPU用”基础地址(段地址x16)+偏移地址=物理地址”的方式给出内存单元的物理地址,使得我们可以用分段的方式来管理内存.物理地址 段地址 偏移地21F60H 2000H 1F60H 2100H 0F60H 21F0H 0060H 21F6H 0000H 1F00H 2F60H结论 CPU可以用不同的段地址和偏移地址形成同一个物理地址 偏移地址为16位的,变化范围为0-FFFFH,仅用偏移地址来寻址最多可寻64kb的内存单元段寄存器8086CPU在访问内存时,要由相关部件提供内存单元的段地址和偏移地址,送入地址加法器合成物理地址.段地址在8086的段寄存器中存放,8086CPU有4个寄存器CS,DS,SS,ES.CS和IPCS和IP是8086CPU中两个最关键的寄存器,他们指示当前要读取指令的地址.CS魏代码段寄存器,IP魏指令指针寄存器.任意时刻,CPU将CS:IP指向的内容当做指令执行指令执行的步骤从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器IP=IP+所读取指令的长度,从而指向下一条指令执行指令在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为CS=FFFFH,IP=0000H,即在8086CPU机刚启动时,CPU从内存FFF0H单元中读取指令,FFFF0H单元中的指令是8086CPU开机后的第一条指令修改CS,IP的指令可以通过mov指令来改变AX,BX,CX,DX中的值,mov指令被称为传送指令mov指令不能用于设置CS,IP的值.8086CPU为CS,IP提供了另外的指令来改变他们的值.能够改变CS,IP的内容的指令被称为转移指令:jmp指令若想同时修改CS,IP的内容,可用形如jmp段地址:偏移地址的指令完成jmp 2AE3:3执行后:CS=2AE3H,IP=0003H,CPU将从2AE33H处读取指令jmp段地址:偏移地址指令的功能为:用指令中给出的段地址修改CS,偏移地址修改IP若想仅修改IP的内容,可用形如jmp某一合法寄存器的指令完成jmp ax,指令执行前:1x=1000H,CS=2000H,IP为0003H.指令执行后:ax=1000H,CS=2000H,IP=1000Hjmp 某一合法寄存器,指令的功能为:用寄存器中的值修改IP 代码段如何使代码段中的指令被执行将一段内存当做代码段,仅仅是我们再编程时的一种安排,CPU并不会由于这种安排,就自动地将我们定义的代码段中的指令当做指令来执行.CPU只认被CS:IP指向的内存单元中的内容为指令.所以要让CPU执行我们放在代码段中的指令,必须要将CS:IP指向所定义的代码段的第一条指令的首地址.小结段地址在8086CPU的段寄存器中存放.当8086CPU要访问内存时,由段寄存器提供内存单元的段地址.8086CPU有4个段寄存器,其中CS用来存放指令的段地址CS存放指令的段地址,IP存放指令的偏移地址,8086机中,任意时候,CPU将CS:IP指向的内容当做指令执行8086CPU的工作过程从CS:IP执行的内存单元读取指令,读取的指令进入指令缓冲器IP指向下一条指令执行指令8086CPU提供转移指令修改CS,IP的内容,jmp段地址:偏移地址:修改CS:IP.jmp 某个合法寄存器:修改IP寄存器(内存访问) 内存中字的存储CPU中,用16位寄存器来存储一个字,高8位存放高位字节,低8位存放低位字节,在内存中存储时,由于内存单元是字节单元(一个单元存放一个字节),则一个字要用两个地址连续的内存单元来存放,这个字的低位字节存放在低地址单元中,高位字节存放在高地址单元中.进制十进制平时使用的数字都是由0~9共10个数字组成的,一个数字最多能表示9,如果要表示十,十一,二十九,一百等,就需要多个数字组合起来因为逢十进一,也因为只有0~9共十个数字,所以被叫做十进制;这时进一位相当于十,进两位相当于二十进制也就是进位制.进行加法运算时逢X进一,进行减法运算时借一当X,这就是X进制,这种进制也就包含X个数字,基数为X.十进制有0~9共10个数字,基数为10,在加减法运算中,逢十进一,借一当十二进制既然可以用0~9共十个数字表示数值,那么也可以用0,1两个数字表示数值,这就是二进制二进制加减法和十进制加减法的思想是类似的:对于十进制,进行加法运算时逢十进一,进行减法运算时借一当十对于二进制,进行加法运算时逢二进一,进行减法运算时借一当二二进制加法:1+0=1,1+1=10,11+10=101,111+111=1110二进制减法:1-0=1,10-1=1,101-11=10,1100-111=101八进制八进制有0~7共8个数字,基数为8,加法运算时逢八进一,减法运算时借一当八八进制加法:3+4=7,5+6=13,75+42=137,2427+567-3216八进制减法:6-4=2,52-27=23,307-141=146,7430-1451=5757十六进制十六进制中,用A表示10,B表示11,C表示12,D表示13,E表示14,F表示15,因此有0~F共有16个数字,基数为16,加法运算时逢16进1,减法运算时借1当16.十六进制加法:6+7=D,18+BA=D2,595=792=D27,2F87+F8A=3F11十六进制减法:D-3=A,52-2F=23,E07-141=CC6,7CA0-1CB1=5FEF进制转换将二进制、八进制、十六进制转换为十进制二进制,八进制和十六进制向十进制转换都非常容易,就是”按权相加”.所谓”权”,也即”位权”假设当前数字是N进制,那么对于整数部分,从右往左看,第i位的位权等于Ni-1对于小数部分,恰好相反,要从左往右看,第j位的位权为N-j整数部分将八进制数字53627转换成十进制:53627=5x84+3x83+6x82+2x81+7x80小数部分将八进制数字423.5176转换成十进制:423.5176=4x82+2x81+3x80+5x8-1+1x8-2+7x8-3+6x8-4小数部分和证书部分相反,要从左往右看,第一位的位权为8-1=1/8将十进制转换成二进制,八进制、十六进制整数部分将十进制整数转换为N进制整数采用”除N取余,逆序排列”法.具体做法是将N作为除数,用十进制整数除以N,可以得到一个商和余数保留余数,用商继续除以N,又得到一个新的商和余数仍保留余数,用商继续除以N,还会得到一个新的商和余数……如此反复进行,每次都保留余数,用商接着除以N,直到商为0时停止把先得到的余数作为 N 进制数的低位数字，后得到的余数作为 N 进制数的高位数字，依次排列起来，就得到了 N 进制数字。小数部分十进制小数转换成N进制小数采用”乘N取整,顺序排列“法.具体做法如下用N乘以十进制小数,可以得到一个积,这个积包含了整数部分和小数部分;将积的整数部分取出,再用N乘以余下的小数部分,又得到一个新的积;再将积的整数部分取出,继续用N乘以余下的小数部分;……如此反复进行,每次都取出整数部分,用N接着乘以小数部分,直到几种的小数部分为0,或者达到所要求的精度为止把取出的整数部分按顺序排列起来，先取出的整数作为 N 进制小数的高位数字，后取出的整数作为低位数字，这样就得到了 N 进制小数。1-1F91Q20520335.png如果一个数字既包含了整数部分又包含了小数部分,那么将整数部分和小数部分分开,分别按照上面的方法完成转换,然后再合并在一起即可注意十进制小数转换成其他进制小数时,结果有可能是一个无限位的小数二进制和八进制、十六进制的转换将二进制转换为八进制和十六进制时就有非常简洁的方法，反之亦然二进制整数和八进制整数之间的转换二进制整数转换成八进制整数时,每三位二进制数字转换为一位八进制数字,运算的顺序是从低位向高位依次进行,高位不足三位用零补齐八进制整数转换成二进制数时,思路是相反的,每一位八进制数字转换为三位二进制数字,运算的顺序也是从低位向高位依次进行二进制整数和十六进制整数之间的转换二进制整数转换为十六进制整数时,每四位二进制数字转换为一位十六进制数字,运算的顺序是从低位向高位依次进行,高位不足四位用零补齐.十六进制整数转换为二进制整数时,思路是相反的,每一位十六进制数字转换为四位二进制数字,运算顺序也是从低位向高位依次进行十进制012345678910111213141516二进制0110111001011101111000100110101011110011011110111110000八进制01234567101112131415161720十六进制0123456789ABCDEF10内存存储在内存中存储时,由于内存单元是字节单元(一个单元存放一个字节)则一个字要用两个地址连续的内存单元来存放,这个字的低位字节存放在低地址单元中,高位字节存放在高地址单元中字单元:即存放一个字型数据(16位)的内存单元,由两个地址连续的内存单元组成.高地址内存单元中存放字型数据的高位自己,低地址内存单元中存放字型数据的低位字节.DS和[address]CPU要读写一个内存单元的时候,必须给出这个内存单元的地址,在8086CPU中,内存地址有段地址和偏移地址组成.8086CPU中有一个DS寄存器,通常用来存放要访问数据的段地址.mov bx,1000hmov ds,bxmov al,[0]详细解释mov al,[0].前面我们使用mov指令完成过两种传送.1,将数据直接传送到寄存器,2将一个寄存器中的内容送入另一个寄存器也可以使用mov指令将一个内存单元中的内容送入另一个寄存器中.mov 寄存器名,内存单元地址“[…]”标识一个内存单元,”[…]”中的0标识内存单元的偏移地址,我们知道只有偏移地址是不能定位一个内存单元的,那么在指令执行时,8086CPU自动取ds中的数据为内存单元的段地址注意8086CPU不支持将数据直接送入段寄存器的操作,ds是一段寄存器,所以mv ds,1000h这条指令是非法的.字的传送因为8086CPU是16位结构,有16根数据线,所以一次性传送16位的数据,也就是说可以一次性传送一个字.只要在mov指令中给出16位寄存器就可以进行16位数据的传送(简单理解就是如果mov指令后面给的是ax就取2个字节数据给ax,如果是al就读一个字节数据给寄存器的al)mov,add,sub指令常见的mov指令形式:mov ax,8(mov 寄存器 数据),mov ax,bx(mov 寄存器 寄存器),mov ax,0,mov [0],bx(mov 内存单元 寄存器),mov ds,ax(mov 段寄存器,寄存器),mov ax,ds(mov 寄存器 段寄存器),mov [0],cs(mov 内存单元 段寄存器),mov ds,[0]add和sub指令同mov一样,都有两个操作队形数据段总结字在内存中存储时,要用两个地址连续的内存单元存放,字的低位字节存放在低地址单元中,高位字节存放在高地址单元中用mov指令访问内存单元,可以再mov指令中只给出单元的偏移地址,此时段地址默认在DS寄存器中[address]表示一个偏移地址为address的内存单元.在内存和寄存器之间传送字型数据时,高地址单元和高8位寄存器,低地址单元和低8位寄存器相对应mov,add,sub是具有两个操作对象的指令,jmp是具有一个操作对象的指令可以根据自己的推测,在Debug中实验指令的新格式栈栈的基本操作有入栈和出栈,入栈就是将一个新的元素放到栈顶,出栈就是从栈顶取出一个元素.栈顶的元素总是最后入栈,需要出栈时,又最先被从栈中取出.栈的这种操作规则被称为LIFOCPU提供的栈机制8086CPU提供入栈和出栈指令,最基本的两个是PUSH(入栈)和POP(出栈).比如push ax表示将寄存器ax中的数据送入栈中,pop ax表示从栈顶取出数据送入ax,8086CPU的入栈和出栈操作都是以字为单位进行的8086CPU中,有两个寄存器,段寄存器SS和寄存器SP,栈顶的段地址存放在SS中,偏移地址存放在SP中,任意时候,SS:SP指向栈顶的元素.push指令和pop指令执行时,CPU从SS和SP中得到栈顶的地址栈顶超界问题一句话只能自己在编程的时候要自己操心栈顶超姐的问题,要根据可能用到的醉倒栈空间来安排栈的大小,防止入栈的数据太多而导致的超界;执行出栈操作时也要注意,以防栈空的时候继续出栈而导致的超界push,pop指令push和pop指令是可以再寄存器和内存(栈空间当然也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间.)之间传送数据的栈的综述8086CPU提供了栈操作的机制,方案如下.在SS,SP中存放栈顶的段地址和偏移地址;提供入栈和出栈指令,他们根据SS:SP指示的地址,按照栈的方式访问内存单元push指令的执行步骤:SP=SP-2;向SS:SP指向的字单元中送入数据pop指令的执行步骤:从SS:SP指向的子单元中读取数据;SP=SP+2任意时刻,SS:SP指向栈顶元素8086CPU只记录栈顶,栈空间的大小我们要自己管理用栈来暂存以后需要恢复的寄存器的内容时,寄存器出栈的顺序要和入栈的顺序相反push,pop实质上是一种内存传送指令,注意它们的灵活应用第一个程序一个源程序从写出到执行的过程可执行文件包含两部分内容程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)相关的描述信息(比如,程序有多大,要占用多少内存空间等)汇编语言程序从写出到最终执行的简要过程编写汇编源程序对源程序进行编译链接执行可执行文件中的程序源程序程序4.1assume cs:codesgcode segmentmov ax,0123hmov bx,0456hadd ax,bxadd ax,axmov ax,4c00hint 21hcodesg endsend伪指令在汇编语言源程序中,包含两种指令,一种是汇编指令,一种是伪指令.汇编指令是有对应的机器码的指令,可以被编译魏机器指令,最终为CPU所执行.而伪指令没有对应的机器指令,最终不被CPU所执行.那么谁来执行伪指令呢?伪指令是由编译器来执行的指令,编译器根据伪指令来进行相关的编译工作,程序4.1中出现的3中伪指令:XXX segment,:,XXX ends.segment和ends是一对成对使用的伪指令,这是在写可被编译器编译的汇编程序时,必须要用到的一对伪指令.segment和ends的功能是定义一个段,segment说明一个段的开始,ends说明一个段的结束.一个段必须有一个名称来标识伪指令:end,end是一个汇编程序的结束标记,编译器在编译汇编程序的过程中,如果碰到了伪指令end,就结束对源程序的编译.assume:这条伪指令的含义为假设,它假设某一段的寄存器和程序中的某一个用segment…ends定义的段相关联.源程序中的”程序”源程序中的汇编指令组成了最终有计算机执行的程序,而源程序中的伪指令由编译器来处理的,这里所说的程序就是指源程序中最终由计算机执行,处理的指令和数据标号汇编源程序中,除了汇编指令和伪指令,还有一些标号,一个标号指代一个地址.比如codesg在segment的前面,作为一个段的名称,这个段的名称最终被编译,链接程序处理为一个段的段地址程序的结构源程序是由一些段构成的我们可以在这些断种存放代码,数据或将某个段当做栈中的空间.程序返回一个程序P2在可执行文件中,则必须有一个正在运行的程序P1,将P2从可执行文件中加载入内存后,将CPU的控制权交给P2,P2才能得以运行.P2开始运行后,P1暂停运行.而当P2运行完毕后,应该将CPU的控制权交还给使它得以运行的程序,我们称这个过程为:程序返回.mov ax,4c00hint 21h语法错误和逻辑错误编辑源程序可以用任意的文本编辑器来编辑源程序,只要最终将其存储为.asm即可编译连接以简化的方式进行编译和连接1.exe的执行谁将可执行文件中的程序装载入内存并使它运行?操作系统的外壳操作系统是由多个功能模块组成的庞大,复杂的软件系统.任何通用的操作系统,都要提供一个称为shell(外壳)的程序,用户(操作人员)使用这个程序来操作计算机系统进行工作DOS中有一个程序command.com,这个程序在DOS中称为命令解释器,也就是DOS系统的shellDOS启动时,先完成其他重要的初始化工作,然后运行command.com,command.com运行后,执行完其他的相关任务后,在屏幕上显示出由当前盘符和当前路径组成的提示符,然后等待用户输入用户可以输入所以执行的命令,比如,cd,dir,type等,这些命令由command执行,command执行完这些命令后,再次显示由当前盘符和当前路径组成的提示符,等待用户的输入如果用户要执行一个程序,则输入该程序的可执行文件的名称,command首先根据文件名找到可执行文件,然后将这个可执行文件中的程序加载如内存,设置CS:IP指向程序的入口.此后,command暂停运行,CPU运行程序,程序运行结束后,返回到command中,command再次显示由当前盘符和当前路径组成的提示符,等待用户的输入在DOS中,command处理各种输入:命令或要执行的程序的文件名.我们就是通过command来进行工作的在DOS中直接执行1.exe时,是正在运行的command,将1.exe中程序加载入内存;command设置CPU的CS:IP指向程序的第一条指令(即程序的入口),从而使程序得以运行;程序运行结束后,返回到command中,CPU继续运行command汇编程序从写出到执行的过程编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;记载-&gt;内存中的程序-&gt;运行第五章[BX]和loop指令L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[KVO原理和自定义]]></title>
    <url>%2F2019%2F01%2F07%2FKVO%E5%8E%9F%E7%90%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[KVO的自定义和原理分析 KVO的触发模式 kvo的触发方式分为手动和自动触发自动触发:添加观察,实现监听方法[_p addObserver:self forKeyPath:@”name” options:(NSKeyValueObservingOptionNew) context:nil];- (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void )context { NSLog(@”%@,%@”,change,_p.name);}手动观察实现automaticallyNotifiesObserversForKey:(NSString )key 方法,判断key值是否开启手动观察@implementation Person//返回一个bool值,该值指示所观察的对象是否支持对给定的键值自动观察+ (BOOL)automaticallyNotifiesObserversForKey:(NSString )key { if ([key isEqualToString:@”name”]) { return NO; } return YES;}@end当开启手动观察后,如果需要监听值的改变,必须调用willChangeValueForKey:和didChangeValueForKey: [_p willChangeValueForKey:@”name”]; _p.name = [NSString stringWithFormat:@”%d”,a++]; [_p didChangeValueForKey:@”name”];KVO的属性依赖@interface Dog : NSObject@property(nonatomic, assign) int age;@property(nonatomic, assign) int level;@end@interface Person : NSObject@property(nonatomic, copy) NSString name;@property(nonatomic, strong)Dog dog;@end+ (NSSet&lt;NSString &gt; )keyPathsForValuesAffectingValueForKey:(NSString )key { NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];; if ([key isEqualToString:@”dog”]) { keyPaths = [[NSSet alloc] initWithObjects:@”_dog.age”,@”_dog._level”, nil]; } return keyPaths;} _p = [[Person alloc] init];[_p addObserver:self forKeyPath:@”dog” options:(NSKeyValueObservingOptionNew) context:nil];当我们需要监听属性的属性的变化,如果只有一个属性可以直接使用keypath,但是如果有多个属性时,我们要么添加多个addObserver,要不就是使用属性依赖 KVO的原理 创建子类NSKVONotyfing_Person 重写setter方法 将isa指针指向子类 保存观察者 通知观察者,并调用父类的set方法 自定义KVO 我在思考上面的步骤,并在完成时进行了扩展和封装,并取消掉了4和5的部分步骤,而是使用了imp的block的方法,使代码看起来更加简单和清晰- (void)WQaddObserver:(NSObject )observer forKeyPath:(NSString )keyPath options:(NSKeyValueObservingOptions)options context:(nullable void )context { //子类名称 NSString className = [[@”WQ” stringByAppendingString:@”KVONotyfing“] stringByAppendingString:NSStringFromClass([self class])]; //创建子类 Class myClass = objc_allocateClassPair([self class], [className UTF8String], 0); //注册子类 objc_registerClassPair(myClass); //将keyPath的首字母大写 NSString propertyName = [keyPath capitalizedString]; //完成setter方法名拼接 NSString methodName = [[@”set” stringByAppendingString:propertyName] stringByAppendingString:@”:”]; //获取方法的SEL SEL methodSel = NSSelectorFromString(methodName); //添加方法实现 IMP methodImp = imp_implementationWithBlock(^(id self, id value) { //创建objc_super结构体,结构体有两个成员变量,一个是receiver,一个是superclass,reciver是指定类的实例,在本利中就是Person类的实例,但是这个实例对象的类型经过更改isa指针指向时已经变为子类类型(WQ KVONotyfing_ Person),第二个参数是父类,也就是Person类. struct objc_super * reciver = malloc(sizeof(struct objc_super)); reciver-&gt;receiver = self; reciver-&gt;super_class = [self superclass]; //调用objc_msgSendSuper,向父类发送消息,第一个参数就是objc_super结构体,第二个参数就是SEL,后面的参数就是sel的参数 objc_msgSendSuper(reciver, methodSel,value); //判断observer是否存在,如果存在就调用objc_msgSend,告诉观察者,值发生了改变 if (observer) { objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:),keyPath,nil,@{@”new:”:value,@”kind”:@1},context); } }); //为子类添加setter方法 class_addMethod(myClass,methodSel,methodImp,”v@:@”); //将父类的isa指针,指向子类 object_setClass(self, myClass);}在我研究的过程中,我本来也是创建了函数来实现setter方法,最后看到IMP的方法可以传入block作为方法实现,如果是使用函数的话,函数默认有两个参数(id self,SEL _cmd).而使用imp的block的话(有一个默认参数id self,去除了SEL _cmd).还有就是在调用父类的setter方法时,一直调用不了,我也一直在想到底是什么问题,检查了几次代码发现没有问题,然后在其他文件夹中找到了一个Person的分类,重写了setter方法,这个错误也让我明白了,如果分类重写了某个方法,如果一旦调用该方法,会执行分类的方法,而不会再调用类本身的方法(因为这个方法已经失效)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>KVO分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFNetwork]]></title>
    <url>%2F2018%2F12%2F19%2FCFNetwork%2F</url>
    <content type="text"><![CDATA[CFNetwork 引言 在iOS应用开发中,CFNetwork框架其实并不是非常常用的,我们常用的网络框架有NSURLSession,&nbsp;NSURLConnect,和底层的CFNetwork在目前我做过的项目中一直在使用AFNetworking,这个框架在3.0版本时放弃了NSURLConnect,开始采用了苹果推荐的NSURLSession.主要使用提升了网络连接速度,Session采用了共享,而非每次新建.使用共享就是避免每次发送请求时都会进行tcp的三次握手,session共享就是复用这个tcp连接. 使用CFNetwork进行网络请求CFNetwork是基于C语言实现的一套网络请求框架,所以它的使用难度是比NSURLSession和NSURLConnect大的.示例代码如下//创建请求URL字符串 NSURL url = [NSURL URLWithString:URLString];//创建HTTP消息 CFHTTPMessageRef request = CFHTTPMessageCreateRequest(kCFAllocatorDefault, CFSTR(“GET”),(bridge CFURLRef)url, kCFHTTPVersion1_1);//设置请求头content-type for (id object in self.networkResponseContentType) { if ([object isKindOfClass: [NSString class]]) { CFHTTPMessageSetHeaderFieldValue(request, CFSTR(“Content-type”), (bridge CFStringRef )object); } else { NSAssert([object isKindOfClass:[NSString class]], @”content-type value must be string”); } } //设置请求头 [self.allHttpHeaders enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL _Nonnull stop) { if ([key isKindOfClass:[NSString class]] &amp;&amp; [obj isKindOfClass:[NSString class]]) { CFHTTPMessageSetHeaderFieldValue(request, (bridge CFStringRef)key, (bridge CFStringRef )obj); } else { NSAssert([obj isKindOfClass:[NSString class]] &amp;&amp; [key isKindOfClass:[NSString class]], @”http header key and value must be string”); } }]; //HTTP返回消息 CFHTTPMessageRef reponse = [self performHTTPRequest:request]; NSData data = [NSJSONSerialization dataWithJSONObject:params options:NSJSONWritingPrettyPrinted error:nil]; CFHTTPMessageSetBody(request, (__bridge CFDataRef)data); CFIndex statusCode; statusCode = CFHTTPMessageGetResponseStatusCode(reponse); if (statusCode == 200) { CFDataRef responseDataRef = CFHTTPMessageCopyBody(reponse); NSDictionary dic = [NSJSONSerialization JSONObjectWithData:(bridge NSData )responseDataRef options:NSJSONReadingAllowFragments error:nil]; success(reponse,dic); } else { NSError error = [NSError errorWithDomain:NSCocoaErrorDomain code:statusCode userInfo:@{@”url”:url.absoluteString,@”errorDesc”:(bridge NSString )CFHTTPMessageCopyResponseStatusLine(reponse)}]; failure(reponse,error); }下面的方法是接收到数据流后,然后将流数据拼接起来返回- (CFHTTPMessageRef)performHTTPRequest:(CFHTTPMessageRef)request{//从请求中读取流 CFReadStreamRef requestStream = CFReadStreamCreateForHTTPRequest(NULL, request);//打开流 CFReadStreamOpen(requestStream);//拼接流 NSMutableData responseBytes = [NSMutableData data]; CFIndex numBytesRead = 0; do { UInt8 buf[1024]; numBytesRead = CFReadStreamRead(requestStream, buf, sizeof(buf)); if (numBytesRead &gt; 0) { [responseBytes appendBytes:buf length:numBytesRead]; } } while (numBytesRead &gt; 0); // CFHTTPMessageRef response = (CFHTTPMessageRef) CFReadStreamCopyProperty(requestStream, kCFStreamPropertyHTTPResponseHeader); CFHTTPMessageSetBody(response, (__bridge CFDataRef)responseBytes); CFReadStreamClose(requestStream); CFRelease(requestStream); return ((CFHTTPMessageRef) CFAutorelease(response));}CFHTTPMessageRef详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[c语言操作符]]></title>
    <url>%2F2018%2F12%2F06%2Fc%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[#####操作符 算术操作符 +, -, *, /, %除了%操作符,其他算术操作符均可用于浮点数和整数算术运算当中.当/的两个操作数为整数时,进行整除,如果是浮点数则运行浮点数除法.%取模操作符只能用于两个操作符魏整数的情况,返回值不是两个操作符的商而是两数进行整除后的余数. 移位操作符(以下都是以8位二进制讨论10010110)分为左移位和右移位,移位操作简单的理解就是将一个值向左或者向右移动指定的位数. 左移位:将指定的数向左移动若干位,但是最左边的几位会被抛弃,右边不足的几位由0补齐.这样又可以形成一个完整的二进制. 右移位:将指定的数向右移动若干位,但是在右移位当中分为两种情况,一种是逻辑移位,一种是算术移位,逻辑移位是指将指定的数向右移动若干位,左边移入的位用0补齐.然后最右边的会被抛弃.算术移位是指,将指定的数移动若干位,左边移入的位不是用0来补齐而是用符号位来补齐.如果符号位为0就用0补齐,如果是1就用1补齐. 左移三位:10110000右移三位:逻辑:00010010,算术:11110010 左移的操作符为&lt;&lt;,右移操作符为&gt;&gt;,左操作数的值将移动右操作数的位数,两个操作数都必须魏整型类型 警告 标准说明所有无符号的移位操作都是逻辑移位,但是有符号的移位操作到底是采用逻辑移位还是算术移位取决于编译器. 位操作符位操作符对他们的操作数的各个位执行AND.OR和XOR等逻辑操作. &amp; | ^AND OR XOR 当两个位进行AND操作时,如果两个位都是1结果为1,否则都为0.当两个位进行OR操作时,如果两个位都是0,结果为0,否则结果为1.当两个位进行XOR操作时,如果两个位不同则为1,否则为0. 举例:a 为00101110b 为01011011 a &amp; b = 00001010a | b = 01111111a ^ b = 01110101]]></content>
      <categories>
        <category>C和指针</category>
      </categories>
      <tags>
        <tag>算术操作符</tag>
        <tag>移位操作符</tag>
        <tag>位操作符</tag>
        <tag>赋值</tag>
        <tag>单目运算</tag>
        <tag>关系操作符</tag>
        <tag>逻辑操作符</tag>
        <tag>条件操作符</tag>
        <tag>逗号操作符</tag>
        <tag>下标引用,函数调用和结构成员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试]]></title>
    <url>%2F2018%2F12%2F05%2F%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[LLDBdSYM文件调试信息文件 断点断点目前分为swift error ,exception,symbolic,opne gl error,constraint error,Test faliure error. 异常断点 首先介绍异常断点(在开发中也被称为全局断点),在代码运行过程中抛出异常后,断点会阻止程序运行,如果不设置异常断点,只看控制台也不知道到底发生了什么.设置了异常断点后,我们经常会看到程序会在抛出异常的瞬间,停止程序.然后在调用栈中我们可以找到导致程序抛出异常的代码.从而帮助我们解决问题,在这里我建议大家在创建完项目后,就打上异常断点,这样在抛出异常的时候就能快速查阅调用堆栈,方便解决问题. 符号断点 我们可以设置符号断点,符号可以使方法名,类方法名,c函数的方法名等.(不常用) open gl (没用过) 编辑断点 我们滚动到需要添加断点的代码时,添加完断点,可以点击鼠标右键选择edit breakpoint,来编辑断点.这个在日常开发中也是很有用的.可以设置condition,来终止程序继续执行,也可以添加action(apple script,sound,shell,log,debug command,GPU frame)等. 共享断点 我们可以在断点导航面板,点击断点,然后鼠标右键,然后点击share,就可以将断点保存到工程文件包的xcshareddata中.然后提交到代码版本库中. 控制台我们在开发过程中经常会使用po和p来调试 p主要用来在控制台输出基础数据类型 po主要用来在控制要输出对象 还可以使用register read来查看寄存器信息,我们知道使用register关键字申明的变量不是保存在内存上的,而是保存在寄存器上的.所有不能使用取地址符来方法这些变量.因为取地址符是用来访问内存的. 如果你是一名python的开发者,或者说熟悉python,也可以在控制台输入script来引入python脚本来进行调试 NSZombieEnabledNSZombieEnabled,它会用一个僵尸实现来替换默认的dealloc实现.当引用计数降到0时,]]></content>
      <tags>
        <tag>LLDB调试</tag>
        <tag>断点</tag>
        <tag>控制台</tag>
        <tag>NSZombieEnabled</tag>
        <tag>崩溃类型</tag>
        <tag>断言</tag>
        <tag>异常</tag>
        <tag>崩溃报告收集</tag>
        <tag>第三方崩溃报告服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIWebView/WKWebview]]></title>
    <url>%2F2018%2F12%2F04%2FUIWebView-WKWebview%2F</url>
    <content type="text"><![CDATA[UIWebview/WKWebview事情并非突然,并不是一时的兴趣.只是遇到的问题,才想着去解决.问题: 本来的项目是使用的UIWebview,但是苹果推荐在iOS8以后希望开发者使用WKWebview,不仅是在内存消耗释放等方面做出了优化,更是在其他性能发面做出了巨大的改变和优化.(具体哪些后面再说),所以在客户提出说要优化webview的加载速度时,首先想到的是将UIWebview替换成WKWebview.不换不知道,一换吓一跳.然后就是我和测试的锅了,没有进行全面的测试,因为有些链接会去下载利用企业证书签名的app.但是在点击时却下载不了,客户那边很着急,然后我连上测试机,打开safari开始调试,发现在js文件的下载方法中进行了判断,会对浏览器的标识进行判断.因为h5页面也不是我们公司写的.所以不能修改,只能自己换回UIWebview.没想到的是UIWebview是可以的.那么UIWeb和WKWeb到底什么地方不同啦? UIWebview在官方文档中明确指出,当你的apps运行在iOS 8及以后的使用应该使用WKWeb来代替UIWeb.如果你不想呈现可以不运行js文件,可以设置WKPreferences的属性javaScriptEnabled为false.(只需要记住在iOS 8以后尽量使用WKWeb). 注意点: 一个iOSapp如果运行在iOS10以后必须在info.plist文件中使用 那些权限的描述key.如果没添加可能会出现crash的情况.例如NSPhotoLibraryUsageDescription 和 NSCameraUsageDescription. loadHTMLString(:baseURL:)这个方法被用来loading 本地的html 文件.loadRequest(:)则是用来加载web contentstopLoading() 可以停止加载isLoading property可以查看web是否正在加载goback(),可以返回到webpage history,goForward(),可以前进到webpage historycanGoBack 和canGoForward属性判断是否可以回退和前进UIDataDetectorTypes:在默认情况下web view自动转换手机号码.当一个phone lonks出现在web conten中.当这个phone linkl 被点击.就会拨打电话.如果想关闭该默认的行为,可以设置dataDetectorTypes.让它不包含phone number flag scalesPageToFit设置这个属性可以在web content显示在web view上时,调整大小.用户可以使用手势调整scale delegate:代理(UIWebviewDelegate) 注意点:你不应该将webview或者是tableview对象内嵌到scollview中,如果你这样做了.可能会在造成意想不到的结果 然后剩下的就是我们调试的问题,可以通过Safari调试webview的内容. uiwebview还可有显示其他的内容例如:keynote,pdf,page doct .但是如果要显示富文本尽量使用UITextview 在iOS6以后,设置restorationIdentifier 属性可以尝试保存url 历史.当缩放和滑动到其他页面时.再恢复期间,驶入将恢复这些值.以便web的内容和之前的一样 看完文档再看UIWebview的头文件 1234567891011121314151617UIKIT_EXTERN API_DEPRECATED(&quot;No longer supported; please adopt WKWebView.&quot;, ios(2.0, 12.0)) API_UNAVAILABLE(tvos, macos) @interface UIWebView : UIView &lt;NSCoding, UIScrollViewDelegate&gt;#ifdef __cplusplus 在c++. extern &quot;C&quot; 是为了兼容以前的C程序.告诉编译器按照以前C编译方式对(全局)函数或变量进行编译.否则按照C++的方式进行编译#define UIKIT_EXTERN extern &quot;C&quot; __attribute__((visibility (&quot;default&quot;)))#else#define UIKIT_EXTERN extern __attribute__((visibility (&quot;default&quot;)))#endif在c++. extern &quot;C&quot; 是为了兼容以前的C程序.告诉编译器按照以前C编译方式对(全局)函数或变量进行编译.否则按照C++的方式进行编译__attribute__设置函数属性(变量,类型)visibility属性是否设置将本项目的函数作为库使用时的可见性,g++编译时, 加入-fvisibility=hidden参数, 会将所有默认public属性设为hidden, 导致库外文件不可见但是如果设置了__attribute__((visibility (&quot;default&quot;)))的函数, 其public属性仍能对外可见, 而不是hidden。可见编译指令 -fvisibility是对所有属性符号进行处理, 而__attribute__((visibility (&quot;default&quot;)))是对特定函数可见性进行设置, 避免冲突第二个就是说这个api废弃了.然后说让你使用WKWeb.然后他还是支持从iOS2.0到iOS12第三个宏定义就是说这个api不支持tvos,macos. 123456789@property (nullable, nonatomic, assign) id &lt;UIWebViewDelegate&gt; delegate;//通过这个代理方法可以决定是否加在网页中的链接,也可以在该方法中拦截加载和完成与js交互- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType API_DEPRECATED(&quot;No longer supported.&quot;, ios(2.0, 12.0));//web content 开始加载- (void)webViewDidStartLoad:(UIWebView *)webView API_DEPRECATED(&quot;No longer supported.&quot;, ios(2.0, 12.0));//web content 加载完成- (void)webViewDidFinishLoad:(UIWebView *)webView API_DEPRECATED(&quot;No longer supported.&quot;, ios(2.0, 12.0));//加载失败出现错误- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error API_DEPRECATED(&quot;No longer supported.&quot;, ios(2.0, 12.0)); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//我们创建一个满屏的webview时,发现它是可以拖动的,我们也知道能拖动的view在iOS开发中都是继承或者是内嵌了uiscollview.//第二点这里声明属性时,使用了只读属性,在我们以后的开发中,外部只是访问属性的值时,也可以参考苹果的这种做法,在.h声明为只读,在.m声明为可读写.这样可以防止外部写入,防止外部修改.@property (nonatomic, readonly, strong) UIScrollView *scrollView NS_AVAILABLE_IOS(5_0);//加载web content- (void)loadRequest:(NSURLRequest *)request;//加载本地html文件- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;//加载其他类型的文件.例如keynote,pdf等- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;//当我们在调试webview时,经常会webview.request.url.发现这个url是会变的.所以在uiwebview的内部.当没加载一个新的页面时,这个request会被重新赋值.@property (nullable, nonatomic, readonly, strong) NSURLRequest *request;//刷新- (void)reload;//停止加载- (void)stopLoading;//返回- (void)goBack;//前进- (void)goForward;//能否后退@property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack;//能否前进@property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward;//是否正在加载@property (nonatomic, readonly, getter=isLoading) BOOL loading;//注入js的方法(交互方法)- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;//调整页面首次加载时的规模,后期可以通过手势修改比例@property (nonatomic) BOOL scalesPageToFit;//NS_DEPRECATED_IOS(2_0, 3_0),3.0就废弃了,跳过@property (nonatomic) BOOL detectsPhoneNumbers NS_DEPRECATED_IOS(2_0, 3_0);//从3.0开始可用(这是就是设置当web content中出现手机号,邮箱等信息时,如果点击这些会自动进行打电话和发邮件等,可以通过设置该属性进行修改)@property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0);//下面这三个是媒体播放的相关设置@property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); // iPhone Safari defaults to NO. iPad Safari defaults to YES@property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); // iPhone and iPad Safari both default to YES@property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); // iPhone and iPad Safari both default to YES//增量@property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); // iPhone and iPad Safari both default to NO//键盘的显示设置@property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); // default is YES//编页码方式@property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0);//分页模式@property (nonatomic) UIWebPaginationBreakingMode paginationBreakingMode NS_AVAILABLE_IOS(7_0);//页长@property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0);//页间距@property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0);//页数@property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0);//图片在媒体中播放@property (nonatomic) BOOL allowsPictureInPictureMediaPlayback NS_AVAILABLE_IOS(9_0);//允许链接预览@property (nonatomic) BOOL allowsLinkPreview NS_AVAILABLE_IOS(9_0); // default is NO 头文件也看完了.现在就说一下平时可能遇到的问题. 1.由于h5页面不只是放在app中的webview,也有可能在多个app中使用,那么怎么区分到底是哪个app的流量带入更大啦.我们可以设置user-agent.可以拼接上每个app的名称来进行区分.还可以进行拦截.比如说你的h5页面有下载,或者是其他需要保证流量正确性的时候,可以判断非该user-agent的不能进行该操作.2.返回退出和进入,内存持续增长.得不到有效释放.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIWebview</tag>
        <tag>WKWebview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理三]]></title>
    <url>%2F2018%2F10%2F17%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%89%2F</url>
    <content type="text"><![CDATA[3.1 内存管理的思考方式自己生成的对象,自己持有非自己生成的对象,自己也能持有不再需要自己持有的对象时释放非自己持有的对象不能释放]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存管理的思考方式</tag>
        <tag>所有权修饰符</tag>
        <tag>规则</tag>
        <tag>属性</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rxswift学习(一)]]></title>
    <url>%2F2018%2F10%2F12%2Frxswift%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理(二)]]></title>
    <url>%2F2018%2F10%2F12%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1%2F</url>
    <content type="text"><![CDATA[iOS内存管理(一) 2.1 release2.1.1 release的作用我们都知道release的作用是引用计数-1.当我们不需要持有对象的引用时需要进行release. 2.1.2 release的调用过程 首先调用对象的release方法 在release方法中调用rootRelease(),在rootRelease()中断言是否使用的GC,判断是否是TaggedPointer,如果是返回false,否则调用sidetable_release(true) 在sidetable_release()方法中首先获取对象保存引用计数的数据结构SideTable,定义局部变量do_dealloc是否进行dealloc.然后SideTable开锁.然后获取到对象的引用计数散列表.如果引用计数值==table.refcnts.end(). do_dealloc = true,将对象的引用计数标识为SIDE_TABLE_DEALLOCATING.如果不等于end.判断it-&gt;second &lt; 小于SIDE_TABLE_DEALLOCATING(判断引用计数是否为0),do_dealloc = true,it-&gt;second = it-&gt;second | SIDE_TABLE_DEALLOCATING.然后如果it-&gt;second &amp; SIDE_TABLE_RC_PINNED(溢出标识).引用计数-1.如果do_dealloc和performDealloc都为true调用dealloc方法.否则调用sidetable_release_slow() sidetable_release_slow()的内部实现和sidetable_release大致类似. 欠缺点: ??? it-&gt;second是什么? ??? 按位与和按位或 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970- (oneway void)release &#123; ((id)self)-&gt;rootRelease();&#125;inline bool objc_object::rootRelease()&#123; assert(!UseGC); if (isTaggedPointer()) return false; return sidetable_release(true);&#125;uintptr_t objc_object::sidetable_release(bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif SideTable&amp; table = SideTables()[this]; bool do_dealloc = false; if (table.trylock()) &#123; RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) &#123; do_dealloc = true; table.refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123; // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it. do_dealloc = true; it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123; it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; table.unlock(); if (do_dealloc &amp;&amp; performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return do_dealloc; &#125; return sidetable_release_slow(table, performDealloc);&#125;uintptr_tobjc_object::sidetable_release_slow(SideTable&amp; table, bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif bool do_dealloc = false; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) &#123; do_dealloc = true; table.refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123; // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it. do_dealloc = true; it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123; it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; table.unlock(); if (do_dealloc &amp;&amp; performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return do_dealloc;&#125; 2.2 autorelease2.2.1 autorelease的作用autorelease的目的是为了让内存能够延迟释放.那么到底它的释放时机什么时候?那么我们先看autorelease的调用过程 调用NSObject的autorelease方法 调用rootAutorelease()方法.在方法内部首先断言是否使用GC,然后就会判断对象是否为TaggedPointer如果是返回当前对象本身,继续判断prepareOptimizedReturn(ReturnAtPlus1),如果为true,返回当前对象,否则调用rootAutorelease2() 在rootAutorelease2()方法中首先判断是否为TaggedPointer.然后调用AutoreleasePoolPage::autorelease((id)this) 在AutoreleasePoolPage::autorelease((id)this)方法中首先断言对象obj是否存在,在判断是否为TaggedPointer.然后会定义一个id类型的变量接受autoreleaseFast(obj)的返回值.在autoreleaseFast(obj)方法中首先获取AutoreleasePoolPage对象.如果page存在并且page没有被塞满,就将obj对象加到page中.否则page存在,但是page已经塞满会重新new一个page,然后在添加进去.如果没有page就回调用autoreleaseNoPage,也会new一个然后把obj添加进去.然后返回对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586871.- (id)autorelease &#123; return ((id)self)-&gt;rootAutorelease();&#125;2.inline id objc_object::rootAutorelease()&#123; assert(!UseGC); if (isTaggedPointer()) return (id)this; if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this; return rootAutorelease2();&#125;3.id objc_object::rootAutorelease2()&#123; assert(!isTaggedPointer()); return AutoreleasePoolPage::autorelease((id)this);&#125;4.static inline id autorelease(id obj) &#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); assert(!dest || *dest == obj); return obj; &#125; 5. static inline id *autoreleaseFast(id obj) &#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125; &#125; 6.static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; // The hot page is full. // Step to the next non-full page, adding a new page if necessary. // Then add the object to that page. assert(page == hotPage()); assert(page-&gt;full() || DebugPoolAllocation); do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj); &#125; static __attribute__((noinline)) id *autoreleaseNoPage(id obj) &#123; // No pool in place. assert(!hotPage()); if (obj != POOL_SENTINEL &amp;&amp; DebugMissingPools) &#123; // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push an autorelease pool boundary if it wasn&apos;t already requested. if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; // Push the requested object. return page-&gt;add(obj); &#125; 这样就完成了将一个对象的延迟释放.但是autorelease的对象什么时机会释放啦.我们的猜想肯定是和AutoreleasePoolPage有关.我们看class AutoreleasePoolPage 的代码会发现,它有push和pop方法.释放肯定和pop有关,push肯定和入栈有关.我们先看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 static inline void pop(void *token) &#123; //定义局部变量AutoreleasePoolPage *page AutoreleasePoolPage *page; //定义stop变量 id *stop; //根据token获取page page = pageForPointer(token); //然后将token赋值给stop stop = (id *)token; DebugPoolAllocation:halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools大致的意思就是当自动释放池出现故障或停止时,允许堆调试器跟踪自动释放池 *stop != POOL_SENTINEL : stop不为nil 无效的自动释放池 if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; //如果自动释放池的高位置标记存在,就打印高位置标记 if (PrintPoolHiwat) printHiwat(); //page调用releaseUntil()方法 page-&gt;releaseUntil(stop); /* void releaseUntil(id *stop) &#123; // Not recursive: we don&apos;t want to blow out the stack // if a thread accumulates a stupendous amount of garbage //当page-&gt;next = stop时停止,否则进行循环 while (this-&gt;next != stop) &#123; // Restart from hotPage() every time, in case -release // autoreleased more objects //获取AutoreleasePoolPage AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can&apos;t prove it while循环如果page为空,就找parent,然后赋值给page.当page不为空时停止循环 while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; //修改page的内存区域保护属性 (mprotect()函数可以用来修改一段指定内存区域的保护属性) page-&gt;unprotect(); ??? 从下面的段代码可以看出将obj添加进page时也是通过next的++操作,然后通过--操作可以获取到当前对象. /* id *add(id obj) &#123; assert(!full()); unprotect(); id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; protect(); return ret; &#125; */ id obj = *--page-&gt;next; //将page-&gt;next的内存重置为0xA3 memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); 修改page的内存区域保护属性 page-&gt;protect(); //如果obj不为nil,就会release if (obj != POOL_SENTINEL) &#123; //和上面的release调用过程同 objc_release(obj); &#125; &#125; setHotPage(this);#if DEBUG // we expect any children to be completely empty for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123; assert(page-&gt;empty()); &#125;#endif &#125; */ // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125; &#125; 然后我们根据autoreleasePoolPage的pop方法一直向上寻找,终于找到以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801. loadimages方法const char *load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; bool found; // Return without taking locks if there are no +load methods here. found = false; for (uint32_t i = 0; i &lt; infoCount; i++) &#123; if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123; found = true; break; &#125; &#125; if (!found) return nil; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; rwlock_writer_t lock2(runtimeLock); found = load_images_nolock(state, infoCount, infoList); &#125; // Call +load methods (without runtimeLock - re-entrant) if (found) &#123; call_load_methods(); &#125; return nil;&#125;2. call_load_methods方法void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125;3.objc_autoreleasePoolPop方法voidobjc_autoreleasePoolPop(void *ctxt)&#123; if (UseGC) return; AutoreleasePoolPage::pop(ctxt);&#125;4._objc_load_image 也有调用call_load_methodsOBJC_EXPORT void _objc_load_image(HMODULE image, header_info *hinfo)&#123; prepare_load_methods(hinfo); call_load_methods();&#125; 然后我们看到了AutoreleasePoolPage调用了pop方法.而loadiamges方法以前应该也见过,就是在使用method swwizing的时候,重写load方法时,打上断点看到调用栈时看到过,还有就是framework有问题时,程序已启动就会在控制台上显示loadimages报错等.这个不是这个文章的研究重点,只是简单提一下.xnu内核加载mach-o-&gt;从xnu内核态将控制权转移到dyld-&gt;_dyld_start-&gt;加载系统的framework和dylib到内存,然后runtime开始初始化和注册-&gt;当每次有心的镜像加入运行时会回调loadinages 然后就是在每次runloop进入休眠期时会调用pop和push释放旧的,创建新的,所以在runloop的每次进入休眠时会释放一次. 篇幅已经过长,先进入下面的内容,下次再详细介绍runloop的内容和autoreleasepool 2.3 dealloc作用:销毁对象 2.3.1 调用过程 NSObject的dealloc方法 _objc_rootDealloc()方法 调用objc_object::rootDealloc() 调用object_dispose(id obj)方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.dealloc- (void)dealloc &#123; _objc_rootDealloc(self);&#125;2. _objc_rootDeallocvoid_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125;3.objc_object::rootDealloc()inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; object_dispose((id)this);&#125;4.object_dispose()id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); #if SUPPORT_GC if (UseGC) &#123; auto_zone_retain(gc_zone, obj); // gc free expects rc==1 &#125;#endif free(obj); return nil;&#125;void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. //对象是否有析构函数 bool cxx = obj-&gt;hasCxxDtor(); //对象是否有动态绑定和关联引用 bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects(); //是否使用gc bool dealloc = !UseGC; // This order is important. //如果存在使用析构函数 if (cxx) object_cxxDestruct(obj); //如果存在动态属性,移除动态绑定和关联应用 if (assoc) _object_remove_assocations(obj); // if (dealloc) obj-&gt;clearDeallocating(); &#125; return obj;&#125; 2.4 retainCount作用:查看对象的引用计数 2.4.1 调用 retainCount rootRetainCount sidetable_retainCount() 123456789101112131415161718192021222324252627282930313233341. retainCount- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125;2. rootRetainCountinline uintptr_t objc_object::rootRetainCount()&#123; assert(!UseGC); if (isTaggedPointer()) return (uintptr_t)this; return sidetable_retainCount();&#125;3.sidetable_retainCountuintptr_tobjc_object::sidetable_retainCount()&#123;//获取对象保存引用计数的数据结构 SideTable&amp; table = SideTables()[this]; //定义局部变量refcnt_result size_t refcnt_result = 1; table.lock(); //获取对象的引用计数表 RefcountMap::iterator it = table.refcnts.find(this); //如果引用计数 != end(引用计数散列表未填充满) if (it != table.refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too 然后引用计数 = refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; table.unlock(); return refcnt_result;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>release</tag>
        <tag>autorelease</tag>
        <tag>dealloc</tag>
        <tag>retainCount</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存分析(一)]]></title>
    <url>%2F2018%2F10%2F12%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[自动引用计数1.1 什么是自动引用计数自动引用计数就是指在内存管理上不需要程序员再次键入retain和release等内存管理语句.而是由系统自动对引用进行计数 目前我们所创建的项目都是ARC的,它不仅减少了程序员的开发工作,而且也降低了程序的崩溃,内存泄漏等风险. 1.2内存管理/引用计数1.2.1 概要书中的举例非常经典,利用办公室开关灯的实际情况对内存管理进行了详细的分析. 当第一个人进入办公室时需要照明,所以开灯 (引用计数1) 当第二个人进入办公室时也需要照明,持有对象 (引用计数2) 当第一个人离开办公室时不需要照明,但是别人还需要照明,所以不能关闭灯,只能释放自己的持有 (引用计数1) 当最后一个人离开时,不需要灯光了,然后关闭灯光,释放自己持有.对象释放 (引用计数0) 1.2.2 内存管理的思考方式 自己生成的对象,自己持有 非自己生成的对象,自己也能持有 不在需要自己持有的对象时,需要自己释放 不能释放自己不持有的对象 对象操作Objective-C方法生成并持有对象alloc/new/copy/mutableCopy等持有对象retain释放对象release废弃对象dealloc 自己生成并持有对象 alloc new copy mutableCopy 123456789/** 自己生成并持有对象*/ id obj = [[NSObject alloc] init]; /** 自己持有对象 */ alloc方法生成的对象自己持有(自己生成并持有对象),并将指向生成持有对象的指针赋给了变量obj.new方法与alloc方法完全一致,copy和mutableCopy方法基于NSCopying和NSMutableCopying协议约定,利用copyWithZ one:方法生成并持有对象的副本 ##1.2.3 alloc的调用过程 1.首先调用NSObject的alloc方法 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 2.调用_objc_rootAlloc()函数 12345id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; 3.调用了callAlloc()函数 123456789101112131415161718192021222324252627282930313233343536static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;//判断是否为Nil和cls是否存在,不存在直接返回 if (checkNil &amp;&amp; !cls) return nil;#if __OBJC2__//判断是否自定义实现的allocwithzone方法 if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast&apos;s summary //还需要再次判断当前的class是否支持快速alloc。如果支持，直接调用calloc函数，申请 bits.fastInstanceSize()大小的内存空间，如果创建失败，会调用callBadAllocHandler函数，如 果不支持快速alloc则调用class_createInstance if (cls-&gt;canAllocFast()) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (!obj) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (!obj) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 4.调用allocWithZone 123+ (id)allocWithZone:(struct _NSZone *)zone &#123; return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);&#125; 5.调用_objc_rootAllocWithZone()函数 12345678910111213141516171819202122id_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&#123; id obj;#if __OBJC2__ //如果是oc代码使用class_createInstance() // allocWithZone under __OBJC2__ ignores the zone parameter (void)zone; obj = class_createInstance(cls, 0);#else//如果不存在zone或者是使用了GC使用class_createInstance(),如果不是使用class_createInstanceFromZone() if (!zone || UseGC) &#123; obj = class_createInstance(cls, 0); &#125; else &#123; obj = class_createInstanceFromZone(cls, 0, zone); &#125;#endif if (!obj) obj = callBadAllocHandler(cls); return obj;&#125; 6.调用class_createInstance()函数 12345id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; 7.调用_class_createInstanceFromZone() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123;//cls是否存在 if (!cls) return nil;//判断该类是否已经做过realize,realize主要是一些数据的拷贝和整理对齐。???(具体做什么) assert(cls-&gt;isRealized()); // Read class&apos;s info bits all at once for performance /* 判断是否支持hasCxxCtor 和 hasCxxDtor还有canAllocNonpointer，hasCxxCtor 和 hasCxxDtor是对 Objective-C++ 的支持，表示这个类是否有 C++ 类构造函数和析构函数，如果有的话，需要进行额外的工 作。canAllocNonpointer我们不用太关心，这里OC 2.0以上基本上返回的都是true。 */ bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocIndexed();//计算instance大小 size_t size = cls-&gt;instanceSize(extraBytes); //if outAllocatedSize存在 *outAllocatedSize的大小 = size if (outAllocatedSize) *outAllocatedSize = size; id obj; //如果不是用gc,不存在zone,??? if (!UseGC &amp;&amp; !zone &amp;&amp; fast) &#123; //分配objc内存大小 obj = (id)calloc(1, size); //如果obj不存在,return nil if (!obj) return nil; //初始化函数 obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123;#if SUPPORT_GC if (UseGC) &#123; obj = (id)auto_zone_allocate_object(gc_zone, size, AUTO_OBJECT_SCANNED, 0, 1); &#125; else #endif if (zone) &#123; obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; if (!obj) return nil; // Use non-indexed isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125;// 不懂 if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; 我们都知道alloc的作用是开辟足够的内存空间,并初始化.然后使obj指针指向对象的内存地址 ##1.2.4 initInstanceIsa与init initInstanceIsa123456789101112131415161718192021222324252627282930inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; assert(!UseGC);//是否使用GC assert(!cls-&gt;requiresRawIsa());//是否具有原始的isa assert(hasCxxDtor == cls-&gt;hasCxxDtor());//是否有析构函数 initIsa(cls, true, hasCxxDtor);&#125;inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#123; //非TaggedPointer assert(!isTaggedPointer()); if (!indexed) &#123; isa.cls = cls; &#125; else &#123; assert(!DisableIndexedIsa); //设置bits的值为define ISA_MAGIC_VALUE 0x001d800000000001ULL isa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.indexed is part of ISA_MAGIC_VALUE //设置isa构造韩式 isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; 我们可以看到initInstanceIsa与isa有巨大关系和对象本身没有多大关系,所以上面的韩式是初始化isa的操作 init函数123456789101112- (id)init &#123; return _objc_rootInit(self);&#125;id_objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. //返回对象本身 return obj;&#125; 所以当我们不自定义实现init方法时,系统默认只是返回对象本身,我们可以再自定义的init方法中设置属性的值 ##1.2.5 非自己生成的对象,自己也能持有 在我们学习OC的时候我们只有对象的生成方法有两种,一种是使用alloc方法,还有一种是使用便利构造器也就是常见的例如: 1id obj = [NSArray array]; 分析:这个对象是由自己生成,但并非自己持有. 12345+(instancetype)array &#123; __autoreleasing NSArray *array = [[NSArray alloc] init]; return array; &#125; 从上面第一条自己生成并持有.我们可以得到array只是将自己生成并持有对象的指针赋给了array变量.我们拿到的只是这个变量指针. 那么如何取得这个对象的所有权啦???** 然后就用到了retain方法 123id obj = [NSArray array];[obj retain]; 通过retain函数持有非自己生成对象 retain方法调用过程我们通过查询runtime源代码可以找到retain的调用顺序1.首先是NSObject的retain方法 123- (id)retain &#123; return ((id)self)-&gt;rootRetain();&#125; 2.在retain方法内部调用了rootRetain()方法 12345678id_objc_rootRetain(id obj)&#123;//判断当前的obj对象是否为空 assert(obj); return obj-&gt;rootRetain();&#125; 3.在rootRetain方法内部调用了objc_object::rootRetain()方法 123456789inline id objc_object::rootRetain()&#123; assert(!UseGC); //如果是TaggedPointer直接返回对象本身 if (isTaggedPointer()) return (id)this; //如果不是调用sidetable_retain() return sidetable_retain();&#125; 4.调用sidetable_retain()函数,首先获取对象的引用技术管理结构体SideTable,在SideTable中有三个重要的成员(spinlock_t slock,RefcountMap refcnts,weak_table_t weak_table).其中引用计数是保存到refcnts.weak_table弱引用表.第一个是一个自旋锁,保证在多线程中操作. 1234567891011121314151617idobjc_object::sidetable_retain()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif SideTable&amp; table = SideTables()[this]; table.lock(); size_t&amp; refcntStorage = table.refcnts[this]; if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; refcntStorage += SIDE_TABLE_RC_ONE; &#125; table.unlock(); return (id)this;&#125; 我们再看引用计数每次加SIDE_TABLE_RC_ONE到底是什么东西? 1234567#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1) 这里使用了一个位操作,在二进制下将1向左移动2位,就是100.然后100代表的数字是4.所以实际上retain加的引用计数是4.SIDE_TABLE_WEAKLY_REFERENCED （内存的第1位）标识该对象是否有过weak对象；SIDE_TABLE_DEALLOCATING（内存的第2位），标识该对象是否正在dealloc。SIDE_TABLE_RC_ONE （内存的第3位），存放引用计数数值（三位之后都用来存放引用计数数值）。SIDE_TABLE_RC_PINNED, 标识引用计数的溢出所以每次我们引用计数加一时，真正加的是4,在取出真正的引用计数时需要右移两位 12345678910111213141516uintptr_tobjc_object::sidetable_retainCount()&#123; SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; table.unlock(); return refcnt_result;&#125; 从上面的代码的代码可以看出refcnt_result+=引用计数总计.而refcnt_result = 1.所以我们访问时都是1而不是0 12345678910111213141516171819202122idobjc_object::sidetable_retain()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif//获取管理引用计数的结构体SideTable SideTable&amp; table = SideTables()[this]; if (table.trylock()) &#123; //获取当前对象的引用计数散列表,使用散列表可以将对象持有者的内存地址和引用计数保存在散列表中.就算在出现异常情况时,也能定位到地址信息 size_t&amp; refcntStorage = table.refcnts[this]; //判断当前的引用计数是否越界 if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; //如果引用计数没有越界,引用计数加1 refcntStorage += SIDE_TABLE_RC_ONE; &#125; table.unlock(); return (id)this; &#125; return sidetable_retain_slow(table);&#125; 6.调用sidetable_retain_slow()函数 12345678910111213141516idobjc_object::sidetable_retain_slow(SideTable&amp; table)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif table.lock(); size_t&amp; refcntStorage = table.refcnts[this]; if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; refcntStorage += SIDE_TABLE_RC_ONE; &#125; table.unlock(); return (id)this;&#125; 上述代码也是引用计数进行加一的一个函数 上面的所有的过程就是在我们调用retain的函数调用过程.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>引用计数</tag>
        <tag>alloc/new/copy/mutableCopy</tag>
        <tag>retain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Objective-C 2.0 52个方法]]></title>
    <url>%2F2018%2F10%2F12%2F52%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一条:了解Objective-C的语言的起源?Objective-C和C++、Java 等都是面向对象的语言。但是在面向对象的语言中Objective-C采用的是消息结构语言，而其他的面向语言采用的还是函数调用的方式。消息结构语言来自于SmallTalk。 消息结构和函数调用的区别 消息结构决定其运行过程中所需要执行的代码由运行时环境决定，而其他面向对象语言则是由编译器决定。我们都知道 OC 是在运行时才会确定对象类型。而调用方法亦是如此，在运行时才回去查找到底该执行哪个方法。而且在 OC 中接收消息的对象可以为 nil 这是其他面向对象语言所不具有的。其他的语言都会先进行判断。 OC 作为 C 的超集在很多方面还是沿用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>52个方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/DNS解析与DNS劫持]]></title>
    <url>%2F2018%2F10%2F12%2FHTTP-DNS%E8%A7%A3%E6%9E%90-DNS%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[HTTP/DNS解析/DNS劫持HTTP请求HTTP全名超文本传输协议，是一种用于分布式，协作式的超媒体信息系统的应用层协议。 HTTP请求行：请求地址和协议版本 HTTP请求头： 请求头中包含：Accept(能够接受的回应内容类型)，Accept-Charset(能够接受的字符集)，Cache-Control(缓存机制)，Connenct(连接类型)，Cookie，Content-Length(请求体的长度)，Content-Type（请求体的多媒体类型），Host(端口)等 HTTP请求体： 任意类型：服务器不会解析请求体，请求体的处理需要后台同学自己处理解析 application/json 使得请求体结构化，序列化可以方便提交复杂的数据结构，也适合在调试接口阶段进行抓包等行为。 text/xml：以XML的方式提交，因为XML支持各种语言使用广泛。但是XML相对于JSON较为臃肿。目前大多数场景都是使用JSON提交 表单提交：application/x-www-form-urlencoded，使得参数必须以键值对的形式并用&amp;链接。 文件提交：multipart/form-data 在上传图片时或者其他类型文件时，都是将文件分成多个部分。每一个部分都是以boundary分割 HTTP请求方法： POST 向指定资源提交数据，数据放在请求本文中，这个请求可以修改现有资源也可以创建新资源 GET 获取指定资源，使用GET请求只用于读取数据。 HEAD 向服务器放出指定资源的请求(目前我还没用到) DELETE 删除服务器上Request-URL标记的资源 PUT 向服务器指定资源位置上传最新内容 TRACE (没用到)HTTP维基百科 OPTIONS (没用到)HTTP维基百科 CONNECT (没用到)HTTP维基百科 HTTP请求过程：当我们手机，pc等网络设备请求百度的域名时分为三步： 1.请求到达运营商DNS服务器并解析这个域名，查找对应的IP地址2.根据IP地址查找对应的服务器，向服务器发起一个HTTP请求3.服务器收到请求后，将所需资源包装后原路返回给网络设备DNS解析就在前一段时间我刚自己买了一个VPS服务器，然后自己买了域名，目的就是为了搭建属于自己的博客，买完服务器后，服务器有对应的IP地址，我为了使用我买的域名访问我的博客，我就必须将服务器的IP和域名进行映射(DNS解析) DNS解析：就是讲域名指向网站空间的IP上，让用户可以通过域名访问到网站的一种服务。域名解析就是域名到IP地址的转换过程。这个过程由DNS服务器完成。 DNS解析的过程： 1.用户主机上运行着DNS的客户端2.浏览器将输入的URL中抽出域名字段3.DNS客户端会向DNS服务器端发送一个查询报文，报文中包含域名字段。4.DNS服务器端响应DNS客户端报文，找到域名对应的IP地址。5.DNS客户端收到DNS服务器的响应报文，其中包含主机名和IP地址6.浏览器拿到IP地址后，就是向该IP地址定位到的HTTP服务器发起请求进行TCP连接。DNS劫持在发生请求时，当运营商收到用户主机请求后，获取到域名，然后通过DNS服务器进行解析，在解析的过程中可能DNS服务器受到第三方攻击。就是第三方攻击解析服务器，使得服务器无法正常解析，然后修改解析后的IP地址指向一个虚假的服务器。如图所示 解决办法：可以使用自己的解析服务器自行解析，或者在APP内部使用解析好的域名以IP的形式访问。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP/DNS解析</tag>
        <tag>DNS劫持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HomeBrew VS Wegt]]></title>
    <url>%2F2018%2F10%2F12%2FHomeBrew%E4%B8%8ERuby%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[HomeBrew 与 wegtHomeBrew 是一款自由及开放源代码的软件包管理系统,用以简化Mac OS X系统上的软件安装过程.它使用Ruby语言写成,针对Mac OS X操作系统自带的Ruby版本,默认安装在/usr/local下.由一个核心的git版本库构成,以使用户能更新HomeBrew.包管理器使用一种称为”公式”的DSL脚本来管理依赖,下载源代码及配置和编译软件,从源代码中构建软件 安装需求 Xcode 安装方式 1$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 相关指令 搜索: 1brew search 套件名称 查询套件信息 1brew info 套件名称 安装套件 1brew install 套件名称 查询目前已经安装的套件 1brew list 更新HomeBrew 1brew update 卸载HomeBrew 1234$ cd `brew --prefix`$ rm -rf Cellar$ brew prune$ rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew$ rm -rf ~/Library/Caches/Homebrew wegt 是linux的一个命令用来下载文件的工具我只有在虚拟机上使用过这个命令,主要作用是用来下载文件.比如说做后台的同学想下载tomcat,就可以通过这个来下载,过多的内容接不介绍了 RubyMac OS X 系统自带了ruby环境,所以我们一般是不需要管理ruby环境的,今天说这个问题是在过年期间我在更新mac系统时出错了缺少系统启动文件,然后我就恢复系统了,知道今天才发现我pod install执行不了,提示ruby的版本过低,而我的pod版本是最新版,所以我就想通过更新ruby来解决问题,但是更新ruby时又发现brew出错了.所以很生气,后果很严重.下载brew,更新ruby,pod就好了卸载和安装上面都有讲述.更新ruby 1brew upgrade ruby Cocoapods对于iOS开发的同学,使用cocoapods是在所难免的,所以不再过多讲述,网上的文章一搜一大堆.pod入门到放弃]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>HomeBrew</tag>
        <tag>wegt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说IBoutlet]]></title>
    <url>%2F2018%2F10%2F12%2FIBoutlet%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[细说IBoutlet当我们在XIb文件或者SB文件中添加空间后,需要与对应属性关联时就会产生 @property(nonatomic,weak) IBoutlet UIbutton *button 那么 IBoutlet到底有什么作用啦.首先IBoutlet不是系统关键字,只是位于系统头文件中的一组预处理命令 #ifdef IBoutlet #define IBoutlet #endif 对于编译器来说,它没有任何作用.它只是告诉Xcode,它和Xib文件中的对象关联. 在古老的OC语言中.我们声明属性是,都需要声明相对应的实例变量 @interface ViewController : UIViewController { IBoutlet UIbutton *button; } @property(nonatomic,weak) IBoutlet UIbutton *button; @end 那为什么要这么做,因为当时采用GCC的编译器.最后苹果开发出了自己的编译器LLVM.在声明属性时,就不需要声明实例变量了.因为LLVM在编译过程中如果没有找到对应属性的实例变量,会自己创建.所以就不需要声明了.就将IBoutlet迁移到了属性声明上.区别于自己声明的属性和与XIB文件中对象关联的属性.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>IBoutlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C视频学习资源]]></title>
    <url>%2F2018%2F10%2F12%2FObjective-C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%92%8C%E5%A4%A7%E7%A5%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Objective-C视频学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源又包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Objective-C对象的构造模式]]></title>
    <url>%2F2018%2F10%2F12%2FObjective-C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[谈对象的构造模式Objective-C语言在创建对象的时候需要先调用alloc,然后实例对象调用init方法完成初始化. alloc究竟干了什么为了能够看到alloc到底干了什么,我们可以下载GNUStep开源的libs-base工程然后找到NSObject.m文件.为什么用GNUStep来查看源码? GNUstep，GNU计划的项目之一。它将Cocoa（前身为NeXT的OpenStep）Objective-C软件库，部件工具箱（widget toolkits）以及其上的应用软件，以自由软件方式重新实现。它能够运行在类Unix操作系统上，也能运作在Microsoft Windows上。GNUStep 1234+ (id) alloc&#123; return [self allocWithZone: NSDefaultMallocZone()];&#125; 可以看到它调用了allocWithZone方法,具体作用就是给当前创建的实例对象开辟内存空间. 12345NSZone*NSDefaultMallocZone (void)&#123; return &amp;default_zone;&#125; 我们都知道oc对象的本质其实就是结构体,在开辟内存空间函数内部,他会遍历当前结构体的所有成员变量,然后根据成员变量的数据类型计算内存大小. 当alloc函数调用完成后会返回一个未初始化的实例,在这里cocoa不仅为这个实例申请了足够大的内存空间还做了以下几件事:1.将该对象的引用计数加12.将该对象的isa指针指向类3.为成员变量初始化值nil/0 init方法init方法是该对象的初始化方法,目的是初始化该对象的成员变量. new方法类方法new的出现是苹果对java等程序员的照顾,而new方法的内部和调用alloc、init是一致的。可以从GNUStep的源代码中得出结论。 1234+ (id) new&#123; return [[self alloc] init];&#125; 设计原则alloc和init的定位不同： alloc旨在为实例对象在虚拟内存上申请足够大的内存空间。而且将对象的retainCount+1.帮助系统完成内存管理。将isa指针指向该类，是为了在运行时环境中完成对该类的检查。 init方法旨在完成该对象成员变量的初始化。在内存方面并没有什么处理。 这样设计的结果可以使苹果开发者更加清晰的了解这两个函数的作用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>alloc</tag>
        <tag>构造模式</tag>
        <tag>init</tag>
        <tag>设计原则</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React(二)]]></title>
    <url>%2F2018%2F10%2F12%2FReact%E7%AC%AC%E4%BA%8C%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[元素渲染:元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器的数据内容和React的保持一致 浏览器中的Dom元素: 元素和组件:元素是组件的一个组成部分,而组件更加广义,在下一课中我们一起学习组件 元素举例 1const element = &lt;h1&gt;hello world!&lt;/h1&gt; 将元素渲染到Dom中在学习完元素之后,我们应该如何将元素显示并渲染到界面上就是这个问题所要研究的内容.大家是否还记得在创建完项目后,我们打开看过index.html的源码在body中有一行这样的代码 1&lt;div id= &quot;root&quot;&gt;&lt;/div&gt; 如果还没有回忆起来那就打开项目看一下,而且在上一课中我按照我的理解已经解释过为什么屏幕上会出现hello world!的原理.这里在说一次在index.js的代码中又这样几行代码 123456const element = &lt;h1&gt;hello world!&lt;/h1&gt;ReactDom.render( element, document.getElementById(&apos;root&apos;)); 也就是说在这个div中的所有内容将有ReactDom来管理,render只是一个渲染函数,这个div也被称为根Dom节点.做过手机App开发的也可以这样理解他就是父视图,后续所有的元素和子视图都是在他上面添加和渲染的.我们会将我们需要渲染的内容通过id获取到根dom节点,然后将其填充到根dom节点中,渲染到页面上.这一切的操作都是由ReactDom来完成的. 更新Dom元素重点:React元素都是不可变的,做过App的都知道不可变的类型有很多在iOS 中常见的NSString,NSArray,NSDictionary,NSSet等.,所以React也是不可以修改其内容和属性的.那么到目前为止我们应该怎样去更新这个元素啦?就是通过创建一个新的元素然后重新渲染到界面上.(is only,not is only)只是针对目前知识浅薄而已.后面应该会有办法更新的,后面我们一起学到了再说.说到这里就举一个例子吧 1234567891011121314151617let tick = () =&gt; &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick,1000); 1234567891011121314151617function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125; 上面的例子中我们通过定时器不断的调用ReactDom的render函数来更新h2这个标签的内容.效果大家可以自己在自己代码中尝试一下(两端代码都可以,一个是箭头函数,一个是常规的js),并且使用检查来观察h2的变化. 重点:在实际项目中render函数只会被调用一次.这次只是为了在目前学习到的基础上看到更新的效果才不得已而为之,如果在以后的开发中,你们使用了这样的方式调用render函数,那么你就要考虑代码的设计问题了. React只会更新必要的部分在开发中又用过数据库的同学应该了解数据库的update操作,当一条记录需要被更新时,他会拿到这条记录的主见然后查找到这条记录,进行字段比对,当有某一个值更新时,才会更新.所以React的更新也是这样的,只会更新发生变化的部分,其他的东西我不会主动更新. 在上一个例子中,我们使用定时器不断的创建描述整个界面的元素,但是当你使用检查检测时会发现,只有h2在不断变化,其他的都是不会发生变化的.在开发中我们会将界面视为一帧一帧的动画,不是随时变化的.我们在发生更新时只需要更新那一帧动画即可,并不需要将更段动画全部更新. 在很多时候都是这样的.基本上所有的开发中只关注我们需要更新的内容,其余的内容我们不需要理会.]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React(三)]]></title>
    <url>%2F2018%2F10%2F12%2FReact%E7%AC%AC%E4%B8%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[函数组件和类定义组件组件:在react和react-native中通常会把可复用的部件封装起来,构建成一个单独的组件.组件从概念上看上去就像一个函数,他可以接收任意输入的值称之为(props)属性.并返回一个需要在页面上显示的React元素 函数定义组件 123456789function Student(props) &#123; return &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 上面的函数就是一个有效的React组件,它接收一个props的对象参数,并返回一个有效的React元素.我们称之为函数定义组件 类定义组件 12345678910111213class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;weiqi&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 看到Class这个关键字,我们很清楚的知道这个是一个类,不论是在java,oc,还是swift他都指代一个类.所以我们通过创建一个类来完成定义在类的render()函数中返回一个React元素,然后将元素添加到界面上显示.在render函数中我们看到了this.props.name,this代表是这个类本身.而props是这个类的属性,那么是具体属性的名称. 以一个上边为图片下边为文字的button来用oc的语言特征进行解释解释(强行扯上关系):比如封装一个上图下文的button 函数形式: 我们可以通过在需要用到的地方以函数的形式构建,然后通过函数返回值返回需要的结果,添加到页面上显示代码在这里就不写了,没什么技术含量. 类形式 创建一个继承自UIbutton的子类,然后在init方法中构建自己需要的页面样式.在需要使用的地方初始化,加载. 上面我举的是一个很微不足道的例子,只是为了做解释说明,方便大家记忆理解,同时也是为了方便我记忆理解.可能让你单独记忆这个概念,可能记不住,但是你一旦把他和你的生活上经常干的事扯上关系,那就不算记忆,只是做一些扩展而已.就变得简单多了. 组件渲染从上面的函数定义组件分析组件渲染: 组件 元素调用的ReactDom的render函数 React将{name:”vicky”}作为Student的props传递给了Student组件 在Student组件将函数结果返回. ReactDom将Dom更新为组件返回的结果 介绍俩个概念: Dom标签:我们前面使用过的在ReactDom.render函数中直接使用的标签,作为React的元素 自定义组件:通过函数或类来自定义的组件 组合组件1234567891011121314151617181920212223class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;Student name = &quot;张三&quot;/&gt; &lt;Student name = &quot;李四&quot;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;App /&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 理解:就是在一个组件内部可已使用另外的一个组件.工程中中就是在一个自定义的子视图中使用另外的一个自定义子视图控件 重点:一个新的React程序的顶部一般都是App组件,如果要讲React集成到现有的应用程序中,则可以从下而上使用小组件作为开始,然后逐渐向顶层扩展. 警告:组件的返回值只能有一个根元素. 提取组件123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 看到上面的代码有什么感受,好多div啊,而且嵌套了好多层啊.现在让我们一起讲上面的代码进行提取组件,然后使代码变得清晰. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Avatar(props) &#123; return ( &lt;img className=&quot;Avatar&quot; src=&#123;props.author.url&#125; alt=&#123;props.author.name&#125; /&gt; )&#125;;function UserInfo(props) &#123; return ( &lt;div className=&quot;UserInfU&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; )&#125;;function CommentText(props) &#123; return ( &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; )&#125;;function CommentDate(props) &#123; return ( &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; )&#125;;function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user = &#123;props.author&#125; /&gt; &lt;UserInfo user = &#123;props.author&#125;/&gt; &lt;/div&gt; &lt;CommentText text = &#123;props.text&#125;/&gt; &lt;CommentDate date = &#123;props.date&#125;/&gt; &lt;/div&gt; );&#125;; 拆解之后有什么好处: 1.代码的可读性较高 2.拆解出来的组件可以进行复用 3.可以分别拆解到不同的文件,减少单独文件的代码量 props属性和只读属性123function sum(a,b) &#123; return a + b;&#125; 这个函数并没有修改输入值得本身,当传入值相同时结果是相同的这种函数较重纯函数 123function withdraw(account, amount) &#123; account.total -= amount;&#125; 这个函数对它自身输入的值进行了-=操作,输入值本身发生了变化. ##重点:所有的React组件必须(必须)(必须)像纯函数那样使用它们的props 类的定义初级类定义:刚开始学就这样了,后面学习到了慢慢改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先引入React和PropTypesimport React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;//开始定义Student类class Student extends React.Component &#123; render() &#123; const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt; name:&#123;name&#125; &lt;/h1&gt; &lt;h1&gt; age: &#123;age&#125; &lt;/h1&gt; &lt;h1&gt; star:&#123;star&#125; &lt;/h1&gt; &lt;h1&gt; sex:&#123;sex&#125; &lt;/h1&gt; &lt;h1&gt; phone: &#123;phone&#125; &lt;/h1&gt; &lt;h1&gt; account:&#123;account&#125; &lt;/h1&gt; &lt;img src= &#123;headImage&#125;/&gt; &lt;/div&gt; ) &#125;&#125;//到底我们需要哪些属性啦?按需求来定Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125;//检查数据类型,如果数据类型不匹配会进行报错提醒Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125;//export default Student; 然后在index.js引入文件并渲染组件 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&quot;56&quot; star=&quot;白羊&quot; sex=&quot;2&quot; phone=&quot;122222222&quot; account=&quot;2222222&quot; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 然后运行发现报错了报错大概是这样的 export default was not found ./Stundet到底什么意思啦就是在类定义组件并且分文件之后要将自己暴露出来,在类定义的最后一行引入这行代码 1export default Student; 然后在运行发现还有报错:这次就不展示什么报错了,就是类型检查报错,因为我们声明了很多属性的类型为number类型,但是我们用string赋值肯定会报错的. 修改完后的代码 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&#123;56&#125; star=&quot;白羊&quot; sex=&#123;2&#125; phone=&#123;122222222&#125; account=&#123;2222222&#125; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 报错是消失了,但是图片和名字还是没有显示,原来是属性名写错了,sorry低级失误. 添加属性的方法 可以再使用组件时直接添加,例如,然后在组件内部return是用this.props.name来获取属性值 添加属性默认值 12345678910Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125; 检查数据类型,如果数据类型不匹配会进行报错提醒 123456789Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125; render函数的使用属性的多种方法,常见的就是this.props.name这种,还有在一些人的代码中经常会看到这样的代码 1234567891011const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; 简化赋值操作.]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码阅读(一)]]></title>
    <url>%2F2018%2F10%2F12%2FSDWebImage%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[SDWebImage的目录层级都说技术的成长要不断的学习和不断的练习.学习可以有很多方法For example 读书,阅读博客,阅读源代码,还有就是我们观看一些技术讨论会,分享会和开发者大会.而我们今天要讲的是从阅读源码开始.从事iOS开发三年来,有读过源码,但是都不完整.所以我目前的长进还只是停留在某个层面.所以从现在开始养成阅读源码的习惯.但是好的源码有很多,到底该如何入手.那么先从加载图片框架开始! 我们要阅读一份源码,首先会看到这份源码的层级结构,包含哪些文件根据文件名判断其主要功能和作用.SD目录层级如下:]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>sdwebimage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift学习资源]]></title>
    <url>%2F2018%2F10%2F12%2FSwift%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%92%8C%E5%A4%A7%E7%A5%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Swift学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源也包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Architectures]]></title>
    <url>%2F2018%2F10%2F12%2FXcode%E4%B9%8BArchitectures%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Xcode设置项之Architectures和Valid Architectures为什么会聊到这个话题,我今天早上刚到公司,说我们App晚上要发版,但是我周六对电脑的Xcode中的缓存文件进行了大规模的清理.然后打开项目跑代码的时候,发现怎么运行不起来了,一直报错library not found for -lafnetworking然后我开始不断的尝试各种方法,最终还是没有解决,大约在14年左右吧,这个项目当时还是使用cocoapods的,最后经过岁月的摧残,当我拿到项目的时候,交接的人说cocoapods不能用,我当时心里就感觉到,这他妈要凉啊.那我导入第三方还要手动拖进去,这也太尴尬了吧.最后我实在忍不住了,就执行了pod install,然后应用程序就有问题了,找到问题-&gt;修改问题-&gt;测试-&gt;成功-&gt;倍儿爽!.但是这次我不知道为什么前几天还好好的工程,为什么在我删除Xcode的一些过大文件后就报错了啦.原因目前可能是将某个配置文件删除了,重新编译的过程中,使用了一个有问题的编译配置.知道是配置的问题,那就开始找问题,我找到以前的代码对比配置,尤其是pod的配置,因为错误很明显afnetworking.我发现在Build Active Architecture only这里以前Debug和Release都是No,但是现在却是Yes,当我改成No之后编译就成功了,虽然可能会在调试的时候编译会慢,但是问题还得慢慢找,先解决发版在说.虽然很懵逼,但是很开心.终于可以赶上发版了.要是出问题了,就又得加班了,关键是这个周末我没有休息,来公司做其他项目了.眼睛也不知道为什么会肿.所以看到问题就很难受.言归正传 介绍上面的两个名词 Valid Architectures您的App需要支持的指令集,最终生成的二进制文件所支持的指令集 如果你设置Valid Architectures支出armv7/armv7s/arm64,Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。到底armv7什么含义可以自己去看一下,简单的理解就是arm处理器的指令集,也就是你支持设备版本. Build Active Architecture Only该编译项用于设置是否只编译当前使用的设备对应的arm指令集。就是你用什么设备调试,就是用对应的指令集去进行编译.当该选项设置成YES时，你连上一个armv7指令集的设备，就算你的Valid Architectures和Architectures都设置成armv7/armv7s/arm64，还是依然只会生成一个armv7指令集的二进制包.当选择NO,那就是你设置了几种,它就会编译几种,最终产生的二进制文件较大,而且编译过程会慢. 重点 指令集都是可以向下兼容的 作用如果你想较小包的大小,就可以设置这个来减少编译不同指令的包.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode常用命令]]></title>
    <url>%2F2018%2F10%2F12%2FXcode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Xcode常用命令p :常用来输出基础数据类型 po :常用来输出oc对象类型 expr :可以在调试时动态的执行表达式，同时打印出结果。常用来动态修改变量的值。 call :常用来动态调用函数 image: image命令可以列出当前App中的所有模块 po [view recursiveDescription] 查看view的层级关系 Xcode常用快捷键shift+command+o :快速打开文件 Command+1~9:导航面版切换]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[关于版本控制版本控制是帮助我们记录文件内容发生变化,方便后面查阅每个版本不同的修订情况.还可以通过版本控制回溯到某个版本的状态.还可以比较文件的变化细节. git的工作状态 工作目录 暂存区域 git仓库 工作目录是在本地计算机上拉取远程仓库某个版本的内容和数据,然后我们进行修改和使用. 暂存区域是一个文件,它会保存下次即将要提交的文件列表信息,一般会在git仓库的目录中. git仓库:是用来保存项目元数据和对象数据库的地方.每次我们提交的更新通过快照也保存在git仓库中.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>git</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用攻防实战(一)]]></title>
    <url>%2F2018%2F10%2F12%2FiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[误解1: 认证因为这设备是安全可信任的设备和产品的认证,只是认证机构对于设备和产品的概念性功能和实现能力的合规性认证,在认证的过程中并没有对设备和产品进行渗透性测试.并不能保证设备和程序不被黑客攻破. 误解2: 单一性安全机制单一性安全机制的问题,就存在与单一性上,他简化了攻破所需要分析的代码.如果一旦单一的安全机制被攻破,所有基于这个单一安全机制的设备和程序都将被攻破. iOS安全模型1.设备安全:防止未授权的人使用设备 2.数据安全:存储在设备上的数据得到保护 3.网络安全:当通过网络传输时的加密工具 4.应用软件安全:加固操作系统并隔离运行时应用软件的机制 设备安全对于设备安全,苹果做出的应对是设置密码和PIN锁.苹果允许企业在安全策略中强制设置这些锁,或个人用户手动设置. 数据安全苹果的数据加密是很值得一提的,采用硬件加密加速器来加密选定的应用软件数据.通过将这些存储在设备上的特定加密密钥与用户设置的密码结合,该系统可以保证只有在用户输入密码后文件系统中这些被保护的文件才会解密.所以用户输入的密码的安全性就是关键.所以密码的复杂度就决定破解的难度. 网络安全苹果使用了很多方法来加密网络包括VPN,SSL,TLS传输层协议,WEP,WPA,WPA2无线网络加密和认证,和2017年一月份提出的HTTPS强制要求都是为了网络安全. 应用软件的安全应用软件的安全,完全依赖于苹果的沙盒技术.拼过系统将自身可被访问的API作为接口放出.应用软件本身不可以访问系统组件,和其他应用软件.沙盒机制限制了一个应用的内存和CPU使用的总量,当超出限制时,出现崩溃闪退现象.他只可以对自己文件目录访问. 为了限制应用软件访问设备资源,苹果使用代码签名的方式,所有运行在设备上的二进制代码,必须经过苹果签名或者使用苹果办法的证书签名.这样做可以保证自身无法修改二进制文件.苹果也可以检测其应用软件的完整性.确保没有被签名的代码注入. 钥匙串技术,可以将一些网络凭证,其他信息保存在钥匙串中,还提供了低级别的加密解密方法. 苹果还提供了基础的加密解密算法(common crypto),开发者可以使用加密算法,对数据机型加密. 误解三:iOS文件系统加密可以防止设备上的数据失窃(直到iOS5)iOS的文件系统加密使用了将秘钥he数据存储在同一设备上的加密系统(直到iOS5)攻击者只需要活的在设备上执行代码的权限,就可以计算出密钥来破解数据.密钥是数字形态的,谁拥有设备的数字拥有权,谁就能同时拿到锁和钥匙 密码等于弱安全相比于PC，移动设备的安全性和用户体验之间的取舍就很严重了。举一个例子：我们在使用完手机后，时不时会把放进口袋里。每一次使用手机都要进行解锁。所以手机厂商在设计这个安全锁时，就必须考虑密码的简单性。要不然用户体验就会很差（vicky_12@.qq.com）。这样的密码在pc上输入还可以，在每次解锁手机屏幕时，用户可能会取消这个设备锁。因为太过于麻烦。所以厂商的设计一般都是某种图形或者是4位或者6位数字。所以密码是弱安全。 误解四：关心安全的用户会设置复杂的密码大多数用户任然选择PIN码和简单的密码保护自己的设备。这样做是因为他们不知道密码的复杂度与设备加密强度的关系。他们自认为，我设置密码就可以赶跑那些坏人。如果坏人足够坏，你设置的密码是远远不够的。所以假设你的用户一般都只会使用简单PIN码和密码来保护设备。 误解五：强密码依然不能保证设备安全我们所指出的强弱密码并不能完全保证你设备的安全，因为在强的东西也有破绽，只是击破它的复杂度上升了，并没有说完全安全性。在互联网方面，没有完全的安全。 数字取证击败加密可能你编写的代码是很安全的，你的应用软件是很安全的。按时操作系统会不断削减你的安全性。操作系统会不断缓存你所产生的操作（键盘操作）web缓存。文件操作等。操作系统都可以缓存到磁盘中。而且操作系统还可以恢复你删除掉的私密文件。私密文件的加密秘钥只要还存在，私密文件就可能被恢复。而且更加恐怖的是连私密文件的密钥都可以被恢复。 误解六： 如果应用软件安全的实现了加密，数据就无法从设备中被恢复首先你错了。上面已经说过了操作系统会不断削弱你的安全性，会缓存你的操作和文件。就连你私密文件的密钥都能操作，你还认为应用软件安全吗？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[instrument使用]]></title>
    <url>%2F2018%2F10%2F12%2Finstrument%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>内存分析</tag>
        <tag>时间复杂度分析</tag>
        <tag>CPU占用分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际化本地化]]></title>
    <url>%2F2018%2F10%2F12%2Flocalizable-strings%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这篇文章我在简书上已经写过直接跳转简书查看利用Localizable.strings做本地化和国际化处理]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Localizable.strings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2018%2F10%2F12%2Fmysql%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[mac 安装mysql 1.安装homebrew 2.brew uninstall mysql 3.brew install mysql 4.mysql -u root -p 5.如果出现报错执行 unset TMPDIR bash mysql_install_db --verbose --user=root --basedir=&quot;$(brew --prefix mysql)&quot;--datadir=/usr/local/var/mysql --tmpdir=/tmp bash mysql.server start]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发小记]]></title>
    <url>%2F2018%2F10%2F12%2FiOS%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[iOS]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[runtime(一)]]></title>
    <url>%2F2018%2F10%2F12%2Fruntime%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[iOS runtime是如何通过selector找到对应的IMP地址？举例： 12345678#import &quot;NSString+GetImp.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSString (GetImp)+ (void)load &#123; IMP imp = class_getMethodImplementation([NSString class], @selector(substringFromIndex:)); &#125;@end 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 分析类对象的定义objc_class的结构体有以下几个成员isa指针指向元类，所有的类方法全部在元类的方法列表中name：类名varsion：版本号info：类信息instance_size：实例的大小objc_ivar_list：成员变量listobjc_method_list：实例方法列表objc_cache：缓存objc_protocol_list：协议列表 12345struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; char * _Nullable method_types OBJC2_UNAVAILABLE; IMP _Nonnull method_imp OBJC2_UNAVAILABLE;&#125; 实例方法列表中保存的都是objc_method 分析实例方法method_name：方法名称method_types：方法的参数和返回值类型method_imp：方法实现。到目前我们已经看到我们需要的IMP 那么runtime到底是如何工作的啦。 1.根据class_getMethodImplementation的第一个参数确定对象类。2.然后根据第二个参数开始进行查找类方法列表和实例方法列表（方法类型）3.遍历实例方法列表寻找与传入的method_name相等的方法，如果找到就返回该方法的实现4.如果没找到就查找父类的方法列表和元类的方法列表，知道查找到根类和根元类的方法列表。如果还没有找到就抛出异常，否则返回。]]></content>
      <categories>
        <category>runtime</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三个ImageView实现无限轮播]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%B8%89%E4%B8%AAImageView%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%92%8C%E4%B8%89%E4%B8%AALabel%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[三个ImageView实现无限轮播思路 scrollView上添加三张ImageView,分别为left,center,right 初始化scrollview时设置contentOffset为中间这张图片的位置 添加定时器,设置定时器事件,当前页+1,然后在动画过渡到第三张图片的位置,在动画结束后,进行复位操作.left的image = center.image,center.image = right.imgae, 然后设置contentOffset = center.right.image = 获取下一张图片 代码实现如下 初始化scrollview let scrollview = UIScrollView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height)) scrollview.contentSize = CGSize(width: self.frame.size.width * 3, height: 0) scrollview.isPagingEnabled = true scrollview.bounces = false scrollview.showsVerticalScrollIndicator = false scrollview.showsHorizontalScrollIndicator = false scrollview.delegate = self 初始化timer timer = Timer(timeInterval: TimeInterval(scrollInterval), target: self, selector: #selector(timerAction), userInfo: nil, repeats: true) RunLoop.current.add(timer!, forMode: .commonModes) 初始化 leftImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height)) centerImageView = UIImageView(frame: CGRect(x: self.frame.size.width * 1, y: 0, width: self.frame.size.width, height: self.frame.size.height)) rightImageView = UIImageView(frame:CGRect(x: self.frame.size.width * 2, y: 0, width: self.frame.size.width, height: self.frame.size.height)) leftImageView?.kf.setImage(with: ImageResource(downloadURL: getBeforeImageUrl(index: self.currentPage))) centerImageView?.kf.setImage(with: ImageResource(downloadURL: getImageUrl(index: self.currentPage)!)) rightImageView?.kf.setImage(with: ImageResource(downloadURL: getAfterImageUrl(index: self.currentPage))) Timer事件 currentPage = currentPage + 1 if currentPage == imageArray.count { currentPage = 0 } UIView.animate(withDuration: animationInterval, animations: { self.centerImageView?.isUserInteractionEnabled = false self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 2, y: 0) }) { (finish) in self.centerImageView?.isUserInteractionEnabled = true self.leftImageView?.image = self.centerImageView?.image self.centerImageView?.image = self.rightImageView?.image self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 1, y: 0) self.rightImageView?.kf.setImage(with: ImageResource(downloadURL: self.getAfterImageUrl(index: self.currentPage))) self.pageController?.currentPage = self.currentPage } 主要代码如上,主要是理解思路. 三个Label实现公告这个和上面的思路一致,只不过是横向换成竖向.代码就不贴了.如果对这个感兴趣,可以私聊我.我可以发代码给你.或者把代码放到git上.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程1.你理解的多线程：2.多线程的多种实现方式：3.你更倾向使用哪种？ pthread （C）pthread是一套基于c语言的多线程解决方案。使用与多个平台，linux，unix，windows。是一套跨平台的多线程解决方案。但是由于使用难度，在开发过程中很少使用到。 NSThread (OC)NSThread是苹果开发的一种多线程解决方案，基于面向对象的思想，使用OC语言开发。使用难度小。但唯一的不足就是程序员必须管理线程的生命周期。 GCD (C)GCD旨在减少程序员管理内存问题。有点事API清晰简单，使用起来简单顺手。而且线程由线程池管理。使得程序员只需要关注提交到线程中的任务。 NSOperation (OC)NSOperation是基于GCD封装的一套API。使用面向对象的设计原则，比GCD多了一些简单使用的功能，暂停，取消等，使用起来更加方便.生命周期也是系统管理。 多线程原理在单核处理器时代，我们所说的多线程技术就是CPU在线程之间来回切换。1.提交多个任务，为每个任务开辟线程和获取资源。2.CPU首先执行任务a，执行一段时间后，记录任务a，然后去执行任务b，执行一段时间后，又去执行任务c。最后又去执行任务a。在多个任务键来回切换。3。如果CPU的切换足够快，我们就会看到多线程并发的假象。 总结：开辟的线程越多，CPU的工作量就越大，耗费的系统资源就越多，每个任务被执行的时间效率降低。 多线程的优点：1.能够充分利用系统资源的使用效率。2.提高程序的执行效率 请说出你最优的选择首先我们应该排除Pthread和NSthread，使用难度和线程生命周期管理的原因。（他们只能作为备胎，而不能作为首选） GCD 它的使用更加轻量，API简单，但是功能没有NSOperation完备。程序员只关注向block中提交任务。但是想暂停和取消任务就比较难。而且设置线程依赖也要写非常多的代码。所以对于功能简单和任务明确的小项目适合使用GCD。 NSOperation 是对GCD的一套抽象封装。增加了不少的功能。而且开发者还可以继承NSOperation完成自己特质的需求。通过NSOperationQueue可以快捷方便的设置线程依赖关系。支持取消，暂停等功能。还可以设置线程的优先级。适合复杂功能和项目的开发。 同步与异步,串行与并发同步和异步:决定是否开辟新的线程 串行和并发:决定是否同时执行任务 同步:不会开辟新的线程,异步会开辟新的线程 并发:会同时执行多个任务 串行:每次执行一个任务,先进先出 优秀博文篇多线程基础 并发编程：API及挑战 并发编程 总结当前开发中多线程的使用和理解非常重要。但是在并发编程中会遇到各种问题，例如优先级翻转、死锁、线程竞争资源等。所以我们应该在并发编程中考虑周全，并需要完成大量的测试。保证系统资源的正常使用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Pthread</tag>
        <tag>NSThread</tag>
        <tag>GCD</tag>
        <tag>NSOperation</tag>
        <tag>多线程原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存优化]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%82%B9%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[内存优化的几点分析: CoreFoundation的内存管理 block的循环引用 在for循环大量数据,不断创建局部变量的几点思考 mrc的基础问题 第三方框架中的内存问题 CoreFoundation的内存管理在编程过程中我们会多次使用CoreFoundation的API,例如CFStringRef,CFArray,CFUUIDRef等。当遇到这些某些关键字的时候我们要时刻注意内存管理方面的问题了。例如alloc,create,copy,mutableCopy,CFRetain等关键字。当遇到这些关键字时，我们就要手动去管理内存了。释放内存的原则还是与手动引用计数相似， 需要引用时，引用计数+1，不需要引用时，引用计数-1 谁创建，谁release 谁retain，谁release 只要调用了alloc,必须要有realease(autorelease)example: 1234CFUUIDRef uuid = CFUUIDCreate(NULL);appUID = (NSString *)CFUUIDCreateString(NULL,uuid);CFRelease(uuid);CFRelease(appUID); block的循环引用问题循环引用问题的现象就是在内存管理方面形成了闭环，互相强引用了对方，导致在内存释放时，都无法得到释放，所以导致了该现象的发生。解决办法：就是打破闭环，在某一端的引用问题上实现弱引用，这也就是我们在代码中常见的strongSelf和weakSelf的使用。for example实例1：123456- (void)case1 &#123;NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name = @&quot;case 1&quot;; &#125;);&#125; 这种情况是不会造成内存泄漏原因就是：在block中内部引用了slef，但是self并没有引用block在系统API的block中不会出现循环引用的问题，这样的API还有UIView的动画block，GCD等。实例2：12345678- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weaktypeof(self) weakSelf = self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;case 2&quot;; &#125;];&#125; 这种就是我们常见的循环引用问题self持有了requestData这个block，在block中又引用了self，形成了一个闭环，使用weakself来打破闭环，解除循环引用。但是为了避免在block执行过程中self过早释放的问题，在block中又将weakself进行了强制引用。当self释放时，block还能够继续执行，当block执行结束后会对强引用的self进行释放。实例3：1234567- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name = @&quot;case 4&quot;; self.teacher = nil; &#125;];&#125; 不存在循环引用，因为在block执行结束后，block主动释放了持有者，在很多框架设计的时候都有这种设计。还有一种设计思想来自猿题库的网络框架设计YTKNetwork就是在block执行结束后，将block置nil。实例4：1234567- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t = [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name = @&quot;case 5&quot;; &#125;];&#125; 不存在循环引用，因为局部变量持有的block，在这个case5方法内部有效，出了大括号局部变量就会释放。 实例512345678910- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block = ^(NSData *data) &#123; self.name = @&quot;case 6&quot;; //下面两句代码任选其一 self.teacher = nil; // self.teacher.case6Block = nil; &#125;;&#125; 在block执行结束后置nil操作，解决内存泄漏问题 for循环大量数据时，不断创建局部变量的思考在使用for循环大量数据并创建大量局部变量时内存会飙升，有兴趣的同学可以试试，从10000次-到10万次看一下内存的增长速度。conclusion：在for循环大量数据并不断创建局部变量时，不适用@autorelasepool，临时变量的内存增长可能是爆发式的。但是当使用@autoreleasepool后，在每个@autoreleasepool结束时，局部变量都会被回收，内存使用更加合理。 mrc的基础虽然现在已经有arc帮助我们管理内存，但是做为一个开发者，理解内存管理是基础。所以在iOS开发中我们要牢记mrc的基本原则： 需要引用时，引用计数+1，不需要引用时，引用计数-1 （reatin-&gt;release） 谁创建，谁release (alloc-&gt;release） 谁retain，谁release (retain-&gt;release) 只要调用了alloc,必须要有realease(autorelease) (alloc-&gt;release(autorelease)) 关于第三方出现的循环引用问题我们项目中网络请求库用的AFN，但是由于在实例化AFHTTPSessionManager中，当并行多个请求时会创建多个manager，当使用leaks查看内存问题时看到AFN代码中这行代码中的init方法会出现内存泄漏。1[[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; 解决办法：采用单例的方式创建。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存问题优化</tag>
        <tag>CoreFoundation</tag>
        <tag>block的循环引用问题</tag>
        <tag>for循环</tag>
        <tag>mrc的基础</tag>
        <tag>关于第三方出现的循环引用问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配合内存区块]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%86%85%E5%AD%98%E5%8C%BA%E5%9D%97%2F</url>
    <content type="text"><![CDATA[-：内存分区栈区：分为动态分配和静态分配。栈区的地址分配是高地址指向低地址栈区主要存储函数的实参和局部变量。静态分配是由编译器完成，动态分配是由malloc函数来完成。栈区的内存释放由系统完成。 堆区：内存的申请和释放由程序员管理。在内存申请时，操作系统会从管理堆区的内存地址的链表中查找未被使用的且足够大的内存。当完成内存分配后会从链表中删除这段内存。将剩余内存的首地址插入到链表中。所以与栈区对比堆区的内存具有碎片化的特性。堆内存的释放有程序员完成，如果程序员未完成内存释放，在程序结束后系统将自动释放这段内存。 静态（全局区）：全局变量和静态变量的存放位置，初始化的静态变量和初始化的全局变量存放在.data段（数据段）。未初始化的放在。bss段系统管理内存的释放。 代码区：存放函数的二进制代码 文字常量区：存放字符串常量 栈区-&gt;堆区-&gt;静态全局区-&gt;文字常量区-&gt;代码区高地址&lt;——————————————————————————&gt;低地址 问题补充：当发起内存申请，系统会如何响应？栈：当每一个函数执行的时候，都会向系统索要资源，函数的运行时发生在栈区的。栈区内存是静态分配和动态分配两种。随着函数的运行而分配内存，随着函数的运行而释放内存。注意：在内存申请过程中，如果剩余的内存空间大于申请的内存空间，系统将为城西分配足够大的内存，如果则表示栈内存不够（栈溢出） 堆：堆区的内存管理由程序员负责，在申请内存过程中，系统维护着一张空闲内存的链表。当申请内存时，系统会遍历空闲内存链表，然后找到第一个大于申请内存空间的内存首地址返回。当然申请的内存不可能正好等于分配的内存空间。所以系统会将剩余的内存空间又存到链表当中，这也是为什么堆区的内存会产生碎片化的原因。 二：内存问题举例例1:char *p = &quot;hello world1&quot;; char a[] = &quot;hello world2&quot;; //p[2] = &#39;a&#39;; a[2] = &#39;a&#39;; char *p1 = &quot;hello world1&quot;; printf(&quot;%p\n,%p\n,%p\n&quot;,p,a,p1); printf(&quot;%c\n&quot;,a[2]); 分析:这个程序是错误的,错误发生在p[2] = ‘a’ 首先变量数组a和变量p都存储于栈区(任何临时变量都是处于栈区) 但是hello world1和hello world2存储于不同区域 数据hello world2存储于数组当中,此数据存储于栈区,对它修改是没有任何问题的.但是指针变量p仅仅你能够保存某个存储单元的地址.也就是真正存储hello world1的内存地址.因为hello world1属于字符串常量所以存储于静态区.虽然通过p[2]可以访问到静态区,但是作为常量不可被修改.所以导致内存问题.指针p1和p保存的内存地址相等,因为数据区只会保留一份相同的数据. 三、堆区、栈区和静态存储区的使用规则 【规则1】用malloc 或new 申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL 的内存。 【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 【规则4】动态内存的申请与释放必须配对，防止内存泄漏。 【规则5】用free 或delete 释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存分区</tag>
        <tag>内存问题</tag>
        <tag>内存使用规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红海行动]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%BA%A2%E6%B5%B7%E8%A1%8C%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[作为一名开发者，我喜欢红海行动中的一段话。我经历了无数次的训练和演习，从来没有像这样害怕过。喜欢这句的原因在于，没有实战的特种兵也不是像他们口号意向“强者无敌”。在开发的过程中我们可能做过无数的练习和实践，但是真正的实战并不是这样的。因为在特定的环境下，一切的训练都会显得不够。在战争面前，训练只是增强了自救的能力，但是畏惧和信心还是需要经过实战来锻炼的。 作为一名观众，我喜欢红海行动。]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对于最近面试的总结1.首先面试最近还是蛮多的,而且都还聊的不错. 2.各个公司的面试方向都有所不同主要是业务和产品不同针对的方向不同,首先是某地产公司的金融产品面试,主要从面向对象编程的思想作为出发点,从单个页面到整体思路让我以面向对象的思想做出分析.还有就是对于数据量较多的处理和数据库的知识.再接着就是产品制作和服务企业,因为这个企业的产品用户较多,所以涉及安全方面的问题较多,比如代码方面的安全,个人用户信息的安全等方面.再接着是一家金融产品公司,主要针对方向是基础知识和一些新技术的发展方向和了几情况.对于产品的优化问题是如何提现的.其他的也就是类似的这种.针对企业目前或者是未来的产品做出提问.剩下的就是我们的基本功.如果基本功扎实的话,可以多了解公司. 3.目前面试了很多家发现自己的不足就是说的时候,表达的不够清楚,感觉好像是这么回事有感觉不像这么回事.其实应该仔细考虑提问并花时间考虑回答.因为面试时间较短所以反应能力和表达能力很重要(需要加强) 4.对于基础知识方面:只要是用过的做过的都能说个差不多,但是就怕没用过的.所以发现自己的知识面的横向拓展还有待提高 总结:生活就是这样,亦步亦趋.在面试和生活中找寻不足,然后面对不足做出回应,然后使自己更加完善.]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React(一)]]></title>
    <url>%2F2018%2F10%2F12%2Freact%E7%AC%AC%E4%B8%80%E8%8A%82%2F</url>
    <content type="text"><![CDATA[配置React开发环境我们选择使用HomeBrew来安装node 安装homebrew ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 更新brew brew update 配置环境变量 vim ./bash.profile export PATH="/usr/local/bin:$PATH" esc,shift+wq退出并保存 为了保证你的环境中没有node的参与文件,可以通过以下命令完全删除node sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*} 安装node brew link node brew uninstall node brew install node 测试安装是否成功 npm install -g grunt-cli 创建项目mkdir react-demo cd react-demo npm install -g create-react-app create-react-app my-app cd my-app npm start 这样就可以看到运行起来的react项目 修改项目删除APP.js,App.css,App.test.js,index.css,logo.svg,registerServiceWorker.js 文件修改index.js文件 import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; ReactDOM.render( &lt;h1&gt;Hello world&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); npm start 运行 理解上面的这段代码会渲染一个id叫做root的dom元素,所以在index.html中我们会看到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 因为我是iOS的开发工作者,我的理解是,html文件向我们提供了一个父视图View也就是这里的div,然后我们根据设置这个View的id来让外界访问.然后在index.js文件中我们创建了一个子视图,并添加到div这个父视图上.就显示到了html页面上. 开始学习本人从未开发过react项目一切都是从零开始,选择编辑器开发react的工具有很多,有IDEA,WebStrom,SublimeText等.具体安装什么插件,网上都有教程,这里不做详细说明,可以按照个人喜好安装. 我选择是idea来编辑项目,因为公司的前端小伙伴都是使用这个编辑器,方便学习和交流,我也推荐大家按照公司小伙伴的喜好来使用编辑器,这样有什么不懂的更方便询问和学习. JSX简介我对jsx 的理解就是JavaScript + XML组成JSX第一步使用JSX语法修改刚才的项目 const element = &lt;h1&gt;Hello world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 第一行的代码看起来既不是字符串也不是html,而他正式这个react的主角:JSX,也就是js的语法扩展,在OC中也有很多语法扩展.说到这里我就说一下iOS中的语法扩展GCC扩展语法,为什么这样写,这样写有什么好处 优点:1.如果不是通过XIB来定义控件我们经常会看到大量的定义UI界面的代码,如果开发这的代码规范有很大的纰漏,那样我相信你们会很发燥,因为可能要到处找代码,例如这个控件的颜色到底在哪里设置的.但是通过这样的语法我们就可以将代码放在大括号内部,是代码更加清晰整洁.2.如果你看到这样的代码,是不是也会认为这样的代码逼格会高一点啦. UIButton *secondButton = ({ UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.frame = CGRectMake(100, 100, 100, 100); button; }); 回到JSX的话题. let fommat = (user)=&gt; user.firstName + &apos;&apos; + user.lastName; const user = { firstName:&apos;wei&apos;, lastName:&apos;qi&apos; }; const element = ( &lt;h1&gt; Hello {fommat(user)}! &lt;/h1&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 划重点:第一行代码使用了箭头函数,后面的就是JSX的基础使用 这次是我学习react的第一课,希望大家多多谅解!如果有志同道合者希望加入我的队列.谢谢!]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
</search>
