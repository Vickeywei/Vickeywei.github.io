{"meta":{"title":"Vicky的技术博客","subtitle":null,"description":"15年毕业于榆林学院,现就职于杭州东导数据科技有限公司.两年多的iOS开发,使我熟练掌握和使用Objective-C和Swift","author":"Vicky","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-12-25T05:35:45.000Z","updated":"2017-12-25T05:42:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-25T06:15:03.000Z","updated":"2017-12-25T06:15:24.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-25T05:34:40.000Z","updated":"2017-12-25T05:43:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Objective-C学习资源和大神博客","slug":"Objective-C学习资源和大神博客","date":"2017-12-25T06:11:55.000Z","updated":"2017-12-25T06:22:14.000Z","comments":false,"path":"2017/12/25/Objective-C学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Objective-C学习资源和大神博客/","excerpt":"","text":"","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift学习资源和大神博客","slug":"Swift学习资源和大神博客","date":"2017-12-25T06:11:37.000Z","updated":"2017-12-25T06:22:28.000Z","comments":false,"path":"2017/12/25/Swift学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift学习资源和大神博客/","excerpt":"","text":"","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift基础篇","slug":"Swift基础篇","date":"2017-12-25T06:09:36.000Z","updated":"2017-12-25T06:10:14.000Z","comments":false,"path":"2017/12/25/Swift基础篇/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift基础篇/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}]},{"title":"instrument的使用","slug":"instrument的使用","date":"2017-12-25T06:03:23.000Z","updated":"2017-12-25T06:22:01.000Z","comments":false,"path":"2017/12/25/instrument的使用/","link":"","permalink":"http://yoursite.com/2017/12/25/instrument的使用/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"优化内存泄漏的几点分析","slug":"优化内存泄漏的几点分析","date":"2017-12-25T05:26:08.000Z","updated":"2017-12-26T02:56:39.000Z","comments":true,"path":"2017/12/25/优化内存泄漏的几点分析/","link":"","permalink":"http://yoursite.com/2017/12/25/优化内存泄漏的几点分析/","excerpt":"","text":"内存优化的几点分析: CoreFoundation的内存管理 block的循环引用 在for循环大量数据,不断创建局部变量的几点思考 mrc的基础问题 第三方框架中的内存问题 CoreFoundation的内存管理在编程过程中我们会多次使用CoreFoundation的API,例如CFStringRef,CFArray,CFUUIDRef等。当遇到这些某些关键字的时候我们要时刻注意内存管理方面的问题了。例如alloc,create,copy,mutableCopy,CFRetain等关键字。当遇到这些关键字时，我们就要手动去管理内存了。释放内存的原则还是与手动引用计数相似， 需要引用时，引用计数+1，不需要引用时，引用计数-1 谁创建，谁release 谁retain，谁release 只要调用了alloc,必须要有realease(autorelease)example: 1234CFUUIDRef uuid = CFUUIDCreate(NULL);appUID = (NSString *)CFUUIDCreateString(NULL,uuid);CFRelease(uuid);CFRelease(appUID); block的循环引用问题循环引用问题的现象就是在内存管理方面形成了闭环，互相强引用了对方，导致在内存释放时，都无法得到释放，所以导致了该现象的发生。解决办法：就是打破闭环，在某一端的引用问题上实现弱引用，这也就是我们在代码中常见的strongSelf和weakSelf的使用。for example实例1：123456- (void)case1 &#123;NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name = @&quot;case 1&quot;; &#125;);&#125; 这种情况是不会造成内存泄漏原因就是：在block中内部引用了slef，但是self并没有引用block在系统API的block中不会出现循环引用的问题，这样的API还有UIView的动画block，GCD等。实例2：12345678- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weaktypeof(self) weakSelf = self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;case 2&quot;; &#125;];&#125; 这种就是我们常见的循环引用问题self持有了requestData这个block，在block中又引用了self，形成了一个闭环，使用weakself来打破闭环，解除循环引用。但是为了避免在block执行过程中self过早释放的问题，在block中又将weakself进行了强制引用。当self释放时，block还能够继续执行，当block执行结束后会对强引用的self进行释放。实例3：1234567- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name = @&quot;case 4&quot;; self.teacher = nil; &#125;];&#125; 不存在循环引用，因为在block执行结束后，block主动释放了持有者，在很多框架设计的时候都有这种设计。还有一种设计思想来自猿题库的网络框架设计YTKNetwork就是在block执行结束后，将block置nil。实例4：1234567- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t = [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name = @&quot;case 5&quot;; &#125;];&#125; 不存在循环引用，因为局部变量持有的block，在这个case5方法内部有效，出了大括号局部变量就会释放。 实例512345678910- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block = ^(NSData *data) &#123; self.name = @&quot;case 6&quot;; //下面两句代码任选其一 self.teacher = nil; // self.teacher.case6Block = nil; &#125;;&#125; 在block执行结束后置nil操作，解决内存泄漏问题 for循环大量数据时，不断创建局部变量的思考在使用for循环大量数据并创建大量局部变量时内存会飙升，有兴趣的同学可以试试，从10000次-到10万次看一下内存的增长速度。conclusion：在for循环大量数据并不断创建局部变量时，不适用@autorelasepool，临时变量的内存增长可能是爆发式的。但是当使用@autoreleasepool后，在每个@autoreleasepool结束时，局部变量都会被回收，内存使用更加合理。 mrc的基础虽然现在已经有arc帮助我们管理内存，但是做为一个开发者，理解内存管理是基础。所以在iOS开发中我们要牢记mrc的基本原则： 需要引用时，引用计数+1，不需要引用时，引用计数-1 （reatin-&gt;release） 谁创建，谁release (alloc-&gt;release） 谁retain，谁release (retain-&gt;release) 只要调用了alloc,必须要有realease(autorelease) (alloc-&gt;release(autorelease)) 关于第三方出现的循环引用问题我们项目中网络请求库用的AFN，但是由于在实例化AFHTTPSessionManager中，当并行多个请求时会创建多个manager，当使用leaks查看内存问题时看到AFN代码中这行代码中的init方法会出现内存泄漏。1[[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; 解决办法：采用单例的方式创建。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"localizable.strings国际化和本地化处理","slug":"localizable-strings国际化和本地化处理","date":"2017-12-25T04:59:25.000Z","updated":"2017-12-25T05:46:57.000Z","comments":true,"path":"2017/12/25/localizable-strings国际化和本地化处理/","link":"","permalink":"http://yoursite.com/2017/12/25/localizable-strings国际化和本地化处理/","excerpt":"","text":"","categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}]}]}