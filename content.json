{"meta":{"title":"Vicky的技术博客","subtitle":null,"description":"15年毕业于榆林学院,现就职于杭州东导数据科技有限公司.两年多的iOS开发,使我熟练掌握和使用Objective-C和Swift","author":"Vicky","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-12-25T06:15:03.000Z","updated":"2017-12-29T06:03:38.898Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"FOO"},{"title":"categories","date":"2017-12-25T05:35:45.000Z","updated":"2017-12-25T05:42:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-25T05:34:40.000Z","updated":"2017-12-25T05:43:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React第二课","slug":"React第二课","date":"2018-01-10T07:52:22.000Z","updated":"2018-01-10T07:55:13.104Z","comments":true,"path":"2018/01/10/React第二课/","link":"","permalink":"http://yoursite.com/2018/01/10/React第二课/","excerpt":"","text":"React 学习第二课元素渲染:元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器的数据内容和React的保持一致 浏览器中的Dom元素: 元素和组件:元素是组件的一个组成部分,而组件更加广义,在下一课中我们一起学习组件 元素举例 1const element = &lt;h1&gt;hello world!&lt;/h1&gt; 将元素渲染到Dom中在学习完元素之后,我们应该如何将元素显示并渲染到界面上就是这个问题所要研究的内容.大家是否还记得在创建完项目后,我们打开看过index.html的源码在body中有一行这样的代码 1&lt;div id= &quot;root&quot;&gt;&lt;/div&gt; 如果还没有回忆起来那就打开项目看一下,而且在上一课中我按照我的理解已经解释过为什么屏幕上会出现hello world!的原理.这里在说一次在index.js的代码中又这样几行代码 123456const element = &lt;h1&gt;hello world!&lt;/h1&gt;ReactDom.render( element, document.getElementById(&apos;root&apos;)); 也就是说在这个div中的所有内容将有ReactDom来管理,render只是一个渲染函数,这个div也被称为根Dom节点.做过手机App开发的也可以这样理解他就是父视图,后续所有的元素和子视图都是在他上面添加和渲染的.我们会将我们需要渲染的内容通过id获取到根dom节点,然后将其填充到根dom节点中,渲染到页面上.这一切的操作都是由ReactDom来完成的. 更新Dom元素重点:React元素都是不可变的,做过App的都知道不可变的类型有很多在iOS 中常见的NSString,NSArray,NSDictionary,NSSet等.,所以React也是不可以修改其内容和属性的.那么到目前为止我们应该怎样去更新这个元素啦?就是通过创建一个新的元素然后重新渲染到界面上.(is only,not is only)只是针对目前知识浅薄而已.后面应该会有办法更新的,后面我们一起学到了再说. 说到这里就举一个例子吧 1234567891011121314151617let tick = () =&gt; &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick,1000); 1234567891011121314151617function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125; 上面的例子中我们通过定时器不断的调用ReactDom的render函数来更新h2这个标签的内容.效果大家可以自己在自己代码中尝试一下(两端代码都可以,一个是箭头函数,一个是常规的js),并且使用检查来观察h2的变化. 重点:在实际项目中render函数只会被调用一次.这次只是为了在目前学习到的基础上看到更新的效果才不得已而为之,如果在以后的开发中,你们使用了这样的方式调用render函数,那么你就要考虑代码的设计问题了. React只会更新必要的部分在开发中又用过数据库的同学应该了解数据库的update操作,当一条记录需要被更新时,他会拿到这条记录的主见然后查找到这条记录,进行字段比对,当有某一个值更新时,才会更新.所以React的更新也是这样的,只会更新发生变化的部分,其他的东西我不会主动更新. 在上一个例子中,我们使用定时器不断的创建描述整个界面的元素,但是当你使用检查检测时会发现,只有h2在不断变化,其他的都是不会发生变化的.在开发中我们会将界面视为一帧一帧的动画,不是随时变化的.我们在发生更新时只需要更新那一帧动画即可,并不需要将更段动画全部更新. 在很多时候都是这样的.基本上所有的开发中只关注我们需要更新的内容,其余的内容我们不需要理会.","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"react第一节","slug":"react第一节","date":"2018-01-08T07:19:53.000Z","updated":"2018-01-08T07:24:37.877Z","comments":true,"path":"2018/01/08/react第一节/","link":"","permalink":"http://yoursite.com/2018/01/08/react第一节/","excerpt":"","text":"配置React开发环境我们选择使用HomeBrew来安装node 安装homebrew ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 更新brew brew update 配置环境变量 vim ./bash.profile export PATH=\"/usr/local/bin:$PATH\" esc,shift+wq退出并保存 为了保证你的环境中没有node的参与文件,可以通过以下命令完全删除node sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*} 安装node brew link node brew uninstall node brew install node 测试安装是否成功 npm install -g grunt-cli 创建项目mkdir react-demo cd react-demo npm install -g create-react-app create-react-app my-app cd my-app npm start 这样就可以看到运行起来的react项目 修改项目删除APP.js,App.css,App.test.js,index.css,logo.svg,registerServiceWorker.js 文件修改index.js文件 import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; ReactDOM.render( &lt;h1&gt;Hello world&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); npm start 运行 理解上面的这段代码会渲染一个id叫做root的dom元素,所以在index.html中我们会看到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 因为我是iOS的开发工作者,我的理解是,html文件向我们提供了一个父视图View也就是这里的div,然后我们根据设置这个View的id来让外界访问.然后在index.js文件中我们创建了一个子视图,并添加到div这个父视图上.就显示到了html页面上. 开始学习本人从未开发过react项目一切都是从零开始,选择编辑器开发react的工具有很多,有IDEA,WebStrom,SublimeText等.具体安装什么插件,网上都有教程,这里不做详细说明,可以按照个人喜好安装. 我选择是idea来编辑项目,因为公司的前端小伙伴都是使用这个编辑器,方便学习和交流,我也推荐大家按照公司小伙伴的喜好来使用编辑器,这样有什么不懂的更方便询问和学习. JSX简介我对jsx 的理解就是JavaScript + XML组成JSX第一步使用JSX语法修改刚才的项目 const element = &lt;h1&gt;Hello world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 第一行的代码看起来既不是字符串也不是html,而他正式这个react的主角:JSX,也就是js的语法扩展,在OC中也有很多语法扩展.说到这里我就说一下iOS中的语法扩展GCC扩展语法,为什么这样写,这样写有什么好处 优点:1.如果不是通过XIB来定义控件我们经常会看到大量的定义UI界面的代码,如果开发这的代码规范有很大的纰漏,那样我相信你们会很发燥,因为可能要到处找代码,例如这个控件的颜色到底在哪里设置的.但是通过这样的语法我们就可以将代码放在大括号内部,是代码更加清晰整洁.2.如果你看到这样的代码,是不是也会认为这样的代码逼格会高一点啦. UIButton *secondButton = ({ UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.frame = CGRectMake(100, 100, 100, 100); button; }); 回到JSX的话题. let fommat = (user)=&gt; user.firstName + &apos;&apos; + user.lastName; const user = { firstName:&apos;wei&apos;, lastName:&apos;qi&apos; }; const element = ( &lt;h1&gt; Hello {fommat(user)}! &lt;/h1&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 划重点:第一行代码使用了箭头函数,后面的就是JSX的基础使用 这次是我学习react的第一课,希望大家多多谅解!如果有志同道合者希望加入我的队列.谢谢!","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"HTTP-DNS解析-DNS劫持","slug":"HTTP-DNS解析-DNS劫持","date":"2018-01-05T06:53:24.000Z","updated":"2018-01-05T07:04:38.674Z","comments":true,"path":"2018/01/05/HTTP-DNS解析-DNS劫持/","link":"","permalink":"http://yoursite.com/2018/01/05/HTTP-DNS解析-DNS劫持/","excerpt":"","text":"HTTP/DNS解析/DNS劫持HTTP请求HTTP全名超文本传输协议，是一种用于分布式，协作式的超媒体信息系统的应用层协议。 HTTP请求行：请求地址和协议版本 HTTP请求头： 请求头中包含：Accept(能够接受的回应内容类型)，Accept-Charset(能够接受的字符集)，Cache-Control(缓存机制)，Connenct(连接类型)，Cookie，Content-Length(请求体的长度)，Content-Type（请求体的多媒体类型），Host(端口)等 HTTP请求体： 任意类型：服务器不会解析请求体，请求体的处理需要后台同学自己处理解析 application/json 使得请求体结构化，序列化可以方便提交复杂的数据结构，也适合在调试接口阶段进行抓包等行为。 text/xml：以XML的方式提交，因为XML支持各种语言使用广泛。但是XML相对于JSON较为臃肿。目前大多数场景都是使用JSON提交 表单提交：application/x-www-form-urlencoded，使得参数必须以键值对的形式并用&amp;链接。 文件提交：multipart/form-data 在上传图片时或者其他类型文件时，都是将文件分成多个部分。每一个部分都是以boundary分割 HTTP请求方法： POST 向指定资源提交数据，数据放在请求本文中，这个请求可以修改现有资源也可以创建新资源 GET 获取指定资源，使用GET请求只用于读取数据。 HEAD 向服务器放出指定资源的请求(目前我还没用到) DELETE 删除服务器上Request-URL标记的资源 PUT 向服务器指定资源位置上传最新内容 TRACE (没用到)HTTP维基百科 OPTIONS (没用到)HTTP维基百科 CONNECT (没用到)HTTP维基百科 HTTP请求过程：当我们手机，pc等网络设备请求百度的域名时分为三步： 1.请求到达运营商DNS服务器并解析这个域名，查找对应的IP地址2.根据IP地址查找对应的服务器，向服务器发起一个HTTP请求3.服务器收到请求后，将所需资源包装后原路返回给网络设备DNS解析就在前一段时间我刚自己买了一个VPS服务器，然后自己买了域名，目的就是为了搭建属于自己的博客，买完服务器后，服务器有对应的IP地址，我为了使用我买的域名访问我的博客，我就必须将服务器的IP和域名进行映射(DNS解析) DNS解析：就是讲域名指向网站空间的IP上，让用户可以通过域名访问到网站的一种服务。域名解析就是域名到IP地址的转换过程。这个过程由DNS服务器完成。 DNS解析的过程： 1.用户主机上运行着DNS的客户端2.浏览器将输入的URL中抽出域名字段3.DNS客户端会向DNS服务器端发送一个查询报文，报文中包含域名字段。4.DNS服务器端响应DNS客户端报文，找到域名对应的IP地址。5.DNS客户端收到DNS服务器的响应报文，其中包含主机名和IP地址6.浏览器拿到IP地址后，就是向该IP地址定位到的HTTP服务器发起请求进行TCP连接。DNS劫持在发生请求时，当运营商收到用户主机请求后，获取到域名，然后通过DNS服务器进行解析，在解析的过程中可能DNS服务器受到第三方攻击。就是第三方攻击解析服务器，使得服务器无法正常解析，然后修改解析后的IP地址指向一个虚假的服务器。如图所示 解决办法：可以使用自己的解析服务器自行解析，或者在APP内部使用解析好的域名以IP的形式访问。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Objective-C学习资源和大神博客","slug":"Objective-C学习资源和大神博客","date":"2017-12-25T06:11:55.000Z","updated":"2017-12-26T16:18:59.000Z","comments":true,"path":"2017/12/25/Objective-C学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Objective-C学习资源和大神博客/","excerpt":"","text":"Objective-C视频学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源又包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift学习资源和大神博客","slug":"Swift学习资源和大神博客","date":"2017-12-25T06:11:37.000Z","updated":"2017-12-26T16:19:08.000Z","comments":true,"path":"2017/12/25/Swift学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift学习资源和大神博客/","excerpt":"","text":"Swift学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源也包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift基础篇","slug":"Swift基础篇","date":"2017-12-25T06:09:36.000Z","updated":"2017-12-26T16:19:18.000Z","comments":true,"path":"2017/12/25/Swift基础篇/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift基础篇/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}]},{"title":"instrument的使用","slug":"instrument的使用","date":"2017-12-25T06:03:23.000Z","updated":"2017-12-26T16:19:33.000Z","comments":true,"path":"2017/12/25/instrument的使用/","link":"","permalink":"http://yoursite.com/2017/12/25/instrument的使用/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"优化内存泄漏的几点分析","slug":"优化内存泄漏的几点分析","date":"2017-12-25T05:26:08.000Z","updated":"2017-12-26T02:56:39.000Z","comments":true,"path":"2017/12/25/优化内存泄漏的几点分析/","link":"","permalink":"http://yoursite.com/2017/12/25/优化内存泄漏的几点分析/","excerpt":"","text":"内存优化的几点分析: CoreFoundation的内存管理 block的循环引用 在for循环大量数据,不断创建局部变量的几点思考 mrc的基础问题 第三方框架中的内存问题 CoreFoundation的内存管理在编程过程中我们会多次使用CoreFoundation的API,例如CFStringRef,CFArray,CFUUIDRef等。当遇到这些某些关键字的时候我们要时刻注意内存管理方面的问题了。例如alloc,create,copy,mutableCopy,CFRetain等关键字。当遇到这些关键字时，我们就要手动去管理内存了。释放内存的原则还是与手动引用计数相似， 需要引用时，引用计数+1，不需要引用时，引用计数-1 谁创建，谁release 谁retain，谁release 只要调用了alloc,必须要有realease(autorelease)example: 1234CFUUIDRef uuid = CFUUIDCreate(NULL);appUID = (NSString *)CFUUIDCreateString(NULL,uuid);CFRelease(uuid);CFRelease(appUID); block的循环引用问题循环引用问题的现象就是在内存管理方面形成了闭环，互相强引用了对方，导致在内存释放时，都无法得到释放，所以导致了该现象的发生。解决办法：就是打破闭环，在某一端的引用问题上实现弱引用，这也就是我们在代码中常见的strongSelf和weakSelf的使用。for example实例1：123456- (void)case1 &#123;NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name = @&quot;case 1&quot;; &#125;);&#125; 这种情况是不会造成内存泄漏原因就是：在block中内部引用了slef，但是self并没有引用block在系统API的block中不会出现循环引用的问题，这样的API还有UIView的动画block，GCD等。实例2：12345678- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weaktypeof(self) weakSelf = self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;case 2&quot;; &#125;];&#125; 这种就是我们常见的循环引用问题self持有了requestData这个block，在block中又引用了self，形成了一个闭环，使用weakself来打破闭环，解除循环引用。但是为了避免在block执行过程中self过早释放的问题，在block中又将weakself进行了强制引用。当self释放时，block还能够继续执行，当block执行结束后会对强引用的self进行释放。实例3：1234567- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name = @&quot;case 4&quot;; self.teacher = nil; &#125;];&#125; 不存在循环引用，因为在block执行结束后，block主动释放了持有者，在很多框架设计的时候都有这种设计。还有一种设计思想来自猿题库的网络框架设计YTKNetwork就是在block执行结束后，将block置nil。实例4：1234567- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t = [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name = @&quot;case 5&quot;; &#125;];&#125; 不存在循环引用，因为局部变量持有的block，在这个case5方法内部有效，出了大括号局部变量就会释放。 实例512345678910- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block = ^(NSData *data) &#123; self.name = @&quot;case 6&quot;; //下面两句代码任选其一 self.teacher = nil; // self.teacher.case6Block = nil; &#125;;&#125; 在block执行结束后置nil操作，解决内存泄漏问题 for循环大量数据时，不断创建局部变量的思考在使用for循环大量数据并创建大量局部变量时内存会飙升，有兴趣的同学可以试试，从10000次-到10万次看一下内存的增长速度。conclusion：在for循环大量数据并不断创建局部变量时，不适用@autorelasepool，临时变量的内存增长可能是爆发式的。但是当使用@autoreleasepool后，在每个@autoreleasepool结束时，局部变量都会被回收，内存使用更加合理。 mrc的基础虽然现在已经有arc帮助我们管理内存，但是做为一个开发者，理解内存管理是基础。所以在iOS开发中我们要牢记mrc的基本原则： 需要引用时，引用计数+1，不需要引用时，引用计数-1 （reatin-&gt;release） 谁创建，谁release (alloc-&gt;release） 谁retain，谁release (retain-&gt;release) 只要调用了alloc,必须要有realease(autorelease) (alloc-&gt;release(autorelease)) 关于第三方出现的循环引用问题我们项目中网络请求库用的AFN，但是由于在实例化AFHTTPSessionManager中，当并行多个请求时会创建多个manager，当使用leaks查看内存问题时看到AFN代码中这行代码中的init方法会出现内存泄漏。1[[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; 解决办法：采用单例的方式创建。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"localizable.strings国际化和本地化处理","slug":"localizable-strings国际化和本地化处理","date":"2017-12-25T04:59:25.000Z","updated":"2017-12-25T05:46:57.000Z","comments":true,"path":"2017/12/25/localizable-strings国际化和本地化处理/","link":"","permalink":"http://yoursite.com/2017/12/25/localizable-strings国际化和本地化处理/","excerpt":"","text":"","categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}]}]}