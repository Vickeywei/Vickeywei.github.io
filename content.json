{"meta":{"title":"Vicky的技术博客","subtitle":null,"description":"15年毕业于榆林学院,现就职于杭州东导数据科技有限公司.两年多的iOS开发,使我熟练掌握和使用Objective-C和Swift","author":"Vicky","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-12-25T06:15:03.000Z","updated":"2017-12-29T06:03:38.898Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"FOO"},{"title":"categories","date":"2017-12-25T05:35:45.000Z","updated":"2017-12-25T05:42:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-25T05:34:40.000Z","updated":"2017-12-25T05:43:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HomeBrew与Ruby更新","slug":"HomeBrew与Ruby更新","date":"2018-02-24T06:39:00.000Z","updated":"2018-02-24T07:48:47.690Z","comments":false,"path":"2018/02/24/HomeBrew与Ruby更新/","link":"","permalink":"http://yoursite.com/2018/02/24/HomeBrew与Ruby更新/","excerpt":"","text":"HomeBrew 与 wegtHomeBrew 是一款自由及开放源代码的软件包管理系统,用以简化Mac OS X系统上的软件安装过程.它使用Ruby语言写成,针对Mac OS X操作系统自带的Ruby版本,默认安装在/usr/local下.由一个核心的git版本库构成,以使用户能更新HomeBrew.包管理器使用一种称为”公式”的DSL脚本来管理依赖,下载源代码及配置和编译软件,从源代码中构建软件 安装需求 Xcode 安装方式 1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 相关指令 搜索: 1brew search 套件名称 查询套件信息 1brew info 套件名称 安装套件 1brew install 套件名称 查询目前已经安装的套件 1brew list 更新HomeBrew 1brew update 卸载HomeBrew 1234$ cd `brew --prefix`$ rm -rf Cellar$ brew prune$ rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew$ rm -rf ~/Library/Caches/Homebrew wegt 是linux的一个命令用来下载文件的工具我只有在虚拟机上使用过这个命令,主要作用是用来下载文件.比如说做后台的同学想下载tomcat,就可以通过这个来下载,过多的内容接不介绍了 RubyMac OS X 系统自带了ruby环境,所以我们一般是不需要管理ruby环境的,今天说这个问题是在过年期间我在更新mac系统时出错了缺少系统启动文件,然后我就恢复系统了,知道今天才发现我pod install执行不了,提示ruby的版本过低,而我的pod版本是最新版,所以我就想通过更新ruby来解决问题,但是更新ruby时又发现brew出错了.所以很生气,后果很严重.下载brew,更新ruby,pod就好了卸载和安装上面都有讲述.更新ruby 1brew upgrade ruby Cocoapods对于iOS开发的同学,使用cocoapods是在所难免的,所以不再过多讲述,网上的文章一搜一大堆.pod入门到放弃","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"switf","slug":"switf","date":"2018-02-07T07:27:50.000Z","updated":"2018-02-07T07:36:27.266Z","comments":false,"path":"2018/02/07/switf/","link":"","permalink":"http://yoursite.com/2018/02/07/switf/","excerpt":"","text":"我从事iOS开发工作也已经两年了,但是开始swift编程也是刚刚开始,所以在swift上我还是一只菜🐓.但是由于swift的热度一直上涨,所以我也抓紧最后上车的机会,买了一张站票上车了.希望还在使用oc的同学,该买票上车了,因为可能有些同学已经行驶一半了.你还在车下观望. guard or if条件语句在开发过程中经常用到,但是在swift中不仅有if语句还有guard语句帮助我们简化鞭尸型金字塔.常常调戏同事你的智商可能就仅限于三个if了.虽然只是玩笑,但是却有一个实情在里面,如果为了完成某个实情出现了大量的if语句,可能最终结果完美,但是当你回头看代码时,可能也就有些懵了,有注释还好,但是如果没有注释只有if,那么就直说灾难来了,不仅为后面接手的人","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}],"keywords":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}]},{"title":"Xcode之Architectures设置","slug":"Xcode之Architectures设置","date":"2018-01-15T07:42:57.000Z","updated":"2018-01-15T07:48:01.507Z","comments":false,"path":"2018/01/15/Xcode之Architectures设置/","link":"","permalink":"http://yoursite.com/2018/01/15/Xcode之Architectures设置/","excerpt":"","text":"Xcode设置项之Architectures和Valid Architectures为什么会聊到这个话题,我今天早上刚到公司,说我们App晚上要发版,但是我周六对电脑的Xcode中的缓存文件进行了大规模的清理.然后打开项目跑代码的时候,发现怎么运行不起来了,一直报错library not found for -lafnetworking然后我开始不断的尝试各种方法,最终还是没有解决,大约在14年左右吧,这个项目当时还是使用cocoapods的,最后经过岁月的摧残,当我拿到项目的时候,交接的人说cocoapods不能用,我当时心里就感觉到,这他妈要凉啊.那我导入第三方还要手动拖进去,这也太尴尬了吧.最后我实在忍不住了,就执行了pod install,然后应用程序就有问题了,找到问题-&gt;修改问题-&gt;测试-&gt;成功-&gt;倍儿爽!.但是这次我不知道为什么前几天还好好的工程,为什么在我删除Xcode的一些过大文件后就报错了啦.原因目前可能是将某个配置文件删除了,重新编译的过程中,使用了一个有问题的编译配置.知道是配置的问题,那就开始找问题,我找到以前的代码对比配置,尤其是pod的配置,因为错误很明显afnetworking.我发现在Build Active Architecture only这里以前Debug和Release都是No,但是现在却是Yes,当我改成No之后编译就成功了,虽然可能会在调试的时候编译会慢,但是问题还得慢慢找,先解决发版在说.虽然很懵逼,但是很开心.终于可以赶上发版了.要是出问题了,就又得加班了,关键是这个周末我没有休息,来公司做其他项目了.眼睛也不知道为什么会肿.所以看到问题就很难受.言归正传 介绍上面的两个名词 Valid Architectures您的App需要支持的指令集,最终生成的二进制文件所支持的指令集 如果你设置Valid Architectures支出armv7/armv7s/arm64,Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。到底armv7什么含义可以自己去看一下,简单的理解就是arm处理器的指令集,也就是你支持设备版本. Build Active Architecture Only该编译项用于设置是否只编译当前使用的设备对应的arm指令集。就是你用什么设备调试,就是用对应的指令集去进行编译.当该选项设置成YES时，你连上一个armv7指令集的设备，就算你的Valid Architectures和Architectures都设置成armv7/armv7s/arm64，还是依然只会生成一个armv7指令集的二进制包.当选择NO,那就是你设置了几种,它就会编译几种,最终产生的二进制文件较大,而且编译过程会慢. 重点 指令集都是可以向下兼容的 作用如果你想较小包的大小,就可以设置这个来减少编译不同指令的包.","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"React第三课","slug":"React第三课","date":"2018-01-11T08:32:18.000Z","updated":"2018-01-11T08:41:02.531Z","comments":false,"path":"2018/01/11/React第三课/","link":"","permalink":"http://yoursite.com/2018/01/11/React第三课/","excerpt":"","text":"函数组件和类定义组件组件:在react和react-native中通常会把可复用的部件封装起来,构建成一个单独的组件.组件从概念上看上去就像一个函数,他可以接收任意输入的值称之为(props)属性.并返回一个需要在页面上显示的React元素 函数定义组件 123456789function Student(props) &#123; return &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 上面的函数就是一个有效的React组件,它接收一个props的对象参数,并返回一个有效的React元素.我们称之为函数定义组件 类定义组件 12345678910111213class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;weiqi&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 看到Class这个关键字,我们很清楚的知道这个是一个类,不论是在java,oc,还是swift他都指代一个类.所以我们通过创建一个类来完成定义在类的render()函数中返回一个React元素,然后将元素添加到界面上显示.在render函数中我们看到了this.props.name,this代表是这个类本身.而props是这个类的属性,那么是具体属性的名称. 以一个上边为图片下边为文字的button来用oc的语言特征进行解释解释(强行扯上关系):比如封装一个上图下文的button 函数形式: 我们可以通过在需要用到的地方以函数的形式构建,然后通过函数返回值返回需要的结果,添加到页面上显示代码在这里就不写了,没什么技术含量. 类形式 创建一个继承自UIbutton的子类,然后在init方法中构建自己需要的页面样式.在需要使用的地方初始化,加载. 上面我举的是一个很微不足道的例子,只是为了做解释说明,方便大家记忆理解,同时也是为了方便我记忆理解.可能让你单独记忆这个概念,可能记不住,但是你一旦把他和你的生活上经常干的事扯上关系,那就不算记忆,只是做一些扩展而已.就变得简单多了. 组件渲染从上面的函数定义组件分析组件渲染: 组件 元素调用的ReactDom的render函数 React将{name:”vicky”}作为Student的props传递给了Student组件 在Student组件将函数结果返回. ReactDom将Dom更新为组件返回的结果 介绍俩个概念: Dom标签:我们前面使用过的在ReactDom.render函数中直接使用的标签,作为React的元素 自定义组件:通过函数或类来自定义的组件 组合组件1234567891011121314151617181920212223class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;Student name = &quot;张三&quot;/&gt; &lt;Student name = &quot;李四&quot;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;App /&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 理解:就是在一个组件内部可已使用另外的一个组件.工程中中就是在一个自定义的子视图中使用另外的一个自定义子视图控件 重点:一个新的React程序的顶部一般都是App组件,如果要讲React集成到现有的应用程序中,则可以从下而上使用小组件作为开始,然后逐渐向顶层扩展. 警告:组件的返回值只能有一个根元素. 提取组件123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 看到上面的代码有什么感受,好多div啊,而且嵌套了好多层啊.现在让我们一起讲上面的代码进行提取组件,然后使代码变得清晰. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Avatar(props) &#123; return ( &lt;img className=&quot;Avatar&quot; src=&#123;props.author.url&#125; alt=&#123;props.author.name&#125; /&gt; )&#125;;function UserInfo(props) &#123; return ( &lt;div className=&quot;UserInfU&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; )&#125;;function CommentText(props) &#123; return ( &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; )&#125;;function CommentDate(props) &#123; return ( &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; )&#125;;function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user = &#123;props.author&#125; /&gt; &lt;UserInfo user = &#123;props.author&#125;/&gt; &lt;/div&gt; &lt;CommentText text = &#123;props.text&#125;/&gt; &lt;CommentDate date = &#123;props.date&#125;/&gt; &lt;/div&gt; );&#125;; 拆解之后有什么好处: 1.代码的可读性较高 2.拆解出来的组件可以进行复用 3.可以分别拆解到不同的文件,减少单独文件的代码量 props属性和只读属性123function sum(a,b) &#123; return a + b;&#125; 这个函数并没有修改输入值得本身,当传入值相同时结果是相同的这种函数较重纯函数 123function withdraw(account, amount) &#123; account.total -= amount;&#125; 这个函数对它自身输入的值进行了-=操作,输入值本身发生了变化. ##重点:所有的React组件必须(必须)(必须)像纯函数那样使用它们的props 类的定义初级类定义:刚开始学就这样了,后面学习到了慢慢改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先引入React和PropTypesimport React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;//开始定义Student类class Student extends React.Component &#123; render() &#123; const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt; name:&#123;name&#125; &lt;/h1&gt; &lt;h1&gt; age: &#123;age&#125; &lt;/h1&gt; &lt;h1&gt; star:&#123;star&#125; &lt;/h1&gt; &lt;h1&gt; sex:&#123;sex&#125; &lt;/h1&gt; &lt;h1&gt; phone: &#123;phone&#125; &lt;/h1&gt; &lt;h1&gt; account:&#123;account&#125; &lt;/h1&gt; &lt;img src= &#123;headImage&#125;/&gt; &lt;/div&gt; ) &#125;&#125;//到底我们需要哪些属性啦?按需求来定Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125;//检查数据类型,如果数据类型不匹配会进行报错提醒Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125;//export default Student; 然后在index.js引入文件并渲染组件 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&quot;56&quot; star=&quot;白羊&quot; sex=&quot;2&quot; phone=&quot;122222222&quot; account=&quot;2222222&quot; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 然后运行发现报错了报错大概是这样的 export default was not found ./Stundet到底什么意思啦就是在类定义组件并且分文件之后要将自己暴露出来,在类定义的最后一行引入这行代码 1export default Student; 然后在运行发现还有报错:这次就不展示什么报错了,就是类型检查报错,因为我们声明了很多属性的类型为number类型,但是我们用string赋值肯定会报错的. 修改完后的代码 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&#123;56&#125; star=&quot;白羊&quot; sex=&#123;2&#125; phone=&#123;122222222&#125; account=&#123;2222222&#125; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 报错是消失了,但是图片和名字还是没有显示,原来是属性名写错了,sorry低级失误. 添加属性的方法 可以再使用组件时直接添加,例如,然后在组件内部return是用this.props.name来获取属性值 添加属性默认值 12345678910Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125; 检查数据类型,如果数据类型不匹配会进行报错提醒 123456789Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125; render函数的使用属性的多种方法,常见的就是this.props.name这种,还有在一些人的代码中经常会看到这样的代码 1234567891011const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; 简化赋值操作.","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React第二课","slug":"React第二课","date":"2018-01-10T07:52:22.000Z","updated":"2018-01-10T08:07:11.213Z","comments":true,"path":"2018/01/10/React第二课/","link":"","permalink":"http://yoursite.com/2018/01/10/React第二课/","excerpt":"","text":"React 学习第二课元素渲染:元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器的数据内容和React的保持一致 浏览器中的Dom元素: 元素和组件:元素是组件的一个组成部分,而组件更加广义,在下一课中我们一起学习组件 元素举例 1const element = &lt;h1&gt;hello world!&lt;/h1&gt; 将元素渲染到Dom中在学习完元素之后,我们应该如何将元素显示并渲染到界面上就是这个问题所要研究的内容.大家是否还记得在创建完项目后,我们打开看过index.html的源码在body中有一行这样的代码 1&lt;div id= &quot;root&quot;&gt;&lt;/div&gt; 如果还没有回忆起来那就打开项目看一下,而且在上一课中我按照我的理解已经解释过为什么屏幕上会出现hello world!的原理.这里在说一次在index.js的代码中又这样几行代码 123456const element = &lt;h1&gt;hello world!&lt;/h1&gt;ReactDom.render( element, document.getElementById(&apos;root&apos;)); 也就是说在这个div中的所有内容将有ReactDom来管理,render只是一个渲染函数,这个div也被称为根Dom节点.做过手机App开发的也可以这样理解他就是父视图,后续所有的元素和子视图都是在他上面添加和渲染的.我们会将我们需要渲染的内容通过id获取到根dom节点,然后将其填充到根dom节点中,渲染到页面上.这一切的操作都是由ReactDom来完成的. 更新Dom元素重点:React元素都是不可变的,做过App的都知道不可变的类型有很多在iOS 中常见的NSString,NSArray,NSDictionary,NSSet等.,所以React也是不可以修改其内容和属性的.那么到目前为止我们应该怎样去更新这个元素啦?就是通过创建一个新的元素然后重新渲染到界面上.(is only,not is only)只是针对目前知识浅薄而已.后面应该会有办法更新的,后面我们一起学到了再说.说到这里就举一个例子吧 1234567891011121314151617let tick = () =&gt; &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick,1000); 1234567891011121314151617function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125; 上面的例子中我们通过定时器不断的调用ReactDom的render函数来更新h2这个标签的内容.效果大家可以自己在自己代码中尝试一下(两端代码都可以,一个是箭头函数,一个是常规的js),并且使用检查来观察h2的变化. 重点:在实际项目中render函数只会被调用一次.这次只是为了在目前学习到的基础上看到更新的效果才不得已而为之,如果在以后的开发中,你们使用了这样的方式调用render函数,那么你就要考虑代码的设计问题了. React只会更新必要的部分在开发中又用过数据库的同学应该了解数据库的update操作,当一条记录需要被更新时,他会拿到这条记录的主见然后查找到这条记录,进行字段比对,当有某一个值更新时,才会更新.所以React的更新也是这样的,只会更新发生变化的部分,其他的东西我不会主动更新. 在上一个例子中,我们使用定时器不断的创建描述整个界面的元素,但是当你使用检查检测时会发现,只有h2在不断变化,其他的都是不会发生变化的.在开发中我们会将界面视为一帧一帧的动画,不是随时变化的.我们在发生更新时只需要更新那一帧动画即可,并不需要将更段动画全部更新. 在很多时候都是这样的.基本上所有的开发中只关注我们需要更新的内容,其余的内容我们不需要理会.","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"react第一课","slug":"react第一节","date":"2018-01-08T07:19:53.000Z","updated":"2018-01-11T08:42:13.327Z","comments":true,"path":"2018/01/08/react第一节/","link":"","permalink":"http://yoursite.com/2018/01/08/react第一节/","excerpt":"","text":"配置React开发环境我们选择使用HomeBrew来安装node 安装homebrew ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 更新brew brew update 配置环境变量 vim ./bash.profile export PATH=\"/usr/local/bin:$PATH\" esc,shift+wq退出并保存 为了保证你的环境中没有node的参与文件,可以通过以下命令完全删除node sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*} 安装node brew link node brew uninstall node brew install node 测试安装是否成功 npm install -g grunt-cli 创建项目mkdir react-demo cd react-demo npm install -g create-react-app create-react-app my-app cd my-app npm start 这样就可以看到运行起来的react项目 修改项目删除APP.js,App.css,App.test.js,index.css,logo.svg,registerServiceWorker.js 文件修改index.js文件 import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; ReactDOM.render( &lt;h1&gt;Hello world&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); npm start 运行 理解上面的这段代码会渲染一个id叫做root的dom元素,所以在index.html中我们会看到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 因为我是iOS的开发工作者,我的理解是,html文件向我们提供了一个父视图View也就是这里的div,然后我们根据设置这个View的id来让外界访问.然后在index.js文件中我们创建了一个子视图,并添加到div这个父视图上.就显示到了html页面上. 开始学习本人从未开发过react项目一切都是从零开始,选择编辑器开发react的工具有很多,有IDEA,WebStrom,SublimeText等.具体安装什么插件,网上都有教程,这里不做详细说明,可以按照个人喜好安装. 我选择是idea来编辑项目,因为公司的前端小伙伴都是使用这个编辑器,方便学习和交流,我也推荐大家按照公司小伙伴的喜好来使用编辑器,这样有什么不懂的更方便询问和学习. JSX简介我对jsx 的理解就是JavaScript + XML组成JSX第一步使用JSX语法修改刚才的项目 const element = &lt;h1&gt;Hello world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 第一行的代码看起来既不是字符串也不是html,而他正式这个react的主角:JSX,也就是js的语法扩展,在OC中也有很多语法扩展.说到这里我就说一下iOS中的语法扩展GCC扩展语法,为什么这样写,这样写有什么好处 优点:1.如果不是通过XIB来定义控件我们经常会看到大量的定义UI界面的代码,如果开发这的代码规范有很大的纰漏,那样我相信你们会很发燥,因为可能要到处找代码,例如这个控件的颜色到底在哪里设置的.但是通过这样的语法我们就可以将代码放在大括号内部,是代码更加清晰整洁.2.如果你看到这样的代码,是不是也会认为这样的代码逼格会高一点啦. UIButton *secondButton = ({ UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.frame = CGRectMake(100, 100, 100, 100); button; }); 回到JSX的话题. let fommat = (user)=&gt; user.firstName + &apos;&apos; + user.lastName; const user = { firstName:&apos;wei&apos;, lastName:&apos;qi&apos; }; const element = ( &lt;h1&gt; Hello {fommat(user)}! &lt;/h1&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 划重点:第一行代码使用了箭头函数,后面的就是JSX的基础使用 这次是我学习react的第一课,希望大家多多谅解!如果有志同道合者希望加入我的队列.谢谢!","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"HTTP-DNS解析-DNS劫持","slug":"HTTP-DNS解析-DNS劫持","date":"2018-01-05T06:53:24.000Z","updated":"2018-01-05T07:04:38.674Z","comments":true,"path":"2018/01/05/HTTP-DNS解析-DNS劫持/","link":"","permalink":"http://yoursite.com/2018/01/05/HTTP-DNS解析-DNS劫持/","excerpt":"","text":"HTTP/DNS解析/DNS劫持HTTP请求HTTP全名超文本传输协议，是一种用于分布式，协作式的超媒体信息系统的应用层协议。 HTTP请求行：请求地址和协议版本 HTTP请求头： 请求头中包含：Accept(能够接受的回应内容类型)，Accept-Charset(能够接受的字符集)，Cache-Control(缓存机制)，Connenct(连接类型)，Cookie，Content-Length(请求体的长度)，Content-Type（请求体的多媒体类型），Host(端口)等 HTTP请求体： 任意类型：服务器不会解析请求体，请求体的处理需要后台同学自己处理解析 application/json 使得请求体结构化，序列化可以方便提交复杂的数据结构，也适合在调试接口阶段进行抓包等行为。 text/xml：以XML的方式提交，因为XML支持各种语言使用广泛。但是XML相对于JSON较为臃肿。目前大多数场景都是使用JSON提交 表单提交：application/x-www-form-urlencoded，使得参数必须以键值对的形式并用&amp;链接。 文件提交：multipart/form-data 在上传图片时或者其他类型文件时，都是将文件分成多个部分。每一个部分都是以boundary分割 HTTP请求方法： POST 向指定资源提交数据，数据放在请求本文中，这个请求可以修改现有资源也可以创建新资源 GET 获取指定资源，使用GET请求只用于读取数据。 HEAD 向服务器放出指定资源的请求(目前我还没用到) DELETE 删除服务器上Request-URL标记的资源 PUT 向服务器指定资源位置上传最新内容 TRACE (没用到)HTTP维基百科 OPTIONS (没用到)HTTP维基百科 CONNECT (没用到)HTTP维基百科 HTTP请求过程：当我们手机，pc等网络设备请求百度的域名时分为三步： 1.请求到达运营商DNS服务器并解析这个域名，查找对应的IP地址2.根据IP地址查找对应的服务器，向服务器发起一个HTTP请求3.服务器收到请求后，将所需资源包装后原路返回给网络设备DNS解析就在前一段时间我刚自己买了一个VPS服务器，然后自己买了域名，目的就是为了搭建属于自己的博客，买完服务器后，服务器有对应的IP地址，我为了使用我买的域名访问我的博客，我就必须将服务器的IP和域名进行映射(DNS解析) DNS解析：就是讲域名指向网站空间的IP上，让用户可以通过域名访问到网站的一种服务。域名解析就是域名到IP地址的转换过程。这个过程由DNS服务器完成。 DNS解析的过程： 1.用户主机上运行着DNS的客户端2.浏览器将输入的URL中抽出域名字段3.DNS客户端会向DNS服务器端发送一个查询报文，报文中包含域名字段。4.DNS服务器端响应DNS客户端报文，找到域名对应的IP地址。5.DNS客户端收到DNS服务器的响应报文，其中包含主机名和IP地址6.浏览器拿到IP地址后，就是向该IP地址定位到的HTTP服务器发起请求进行TCP连接。DNS劫持在发生请求时，当运营商收到用户主机请求后，获取到域名，然后通过DNS服务器进行解析，在解析的过程中可能DNS服务器受到第三方攻击。就是第三方攻击解析服务器，使得服务器无法正常解析，然后修改解析后的IP地址指向一个虚假的服务器。如图所示 解决办法：可以使用自己的解析服务器自行解析，或者在APP内部使用解析好的域名以IP的形式访问。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Objective-C学习资源和大神博客","slug":"Objective-C学习资源和大神博客","date":"2017-12-25T06:11:55.000Z","updated":"2017-12-26T16:18:59.000Z","comments":true,"path":"2017/12/25/Objective-C学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Objective-C学习资源和大神博客/","excerpt":"","text":"Objective-C视频学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源又包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift学习资源和大神博客","slug":"Swift学习资源和大神博客","date":"2017-12-25T06:11:37.000Z","updated":"2017-12-26T16:19:08.000Z","comments":true,"path":"2017/12/25/Swift学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift学习资源和大神博客/","excerpt":"","text":"Swift学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源也包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Swift基础篇","slug":"Swift基础篇","date":"2017-12-25T06:09:36.000Z","updated":"2017-12-26T16:19:18.000Z","comments":true,"path":"2017/12/25/Swift基础篇/","link":"","permalink":"http://yoursite.com/2017/12/25/Swift基础篇/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}]},{"title":"instrument的使用","slug":"instrument的使用","date":"2017-12-25T06:03:23.000Z","updated":"2017-12-26T16:19:33.000Z","comments":true,"path":"2017/12/25/instrument的使用/","link":"","permalink":"http://yoursite.com/2017/12/25/instrument的使用/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"优化内存泄漏的几点分析","slug":"优化内存泄漏的几点分析","date":"2017-12-25T05:26:08.000Z","updated":"2017-12-26T02:56:39.000Z","comments":true,"path":"2017/12/25/优化内存泄漏的几点分析/","link":"","permalink":"http://yoursite.com/2017/12/25/优化内存泄漏的几点分析/","excerpt":"","text":"内存优化的几点分析: CoreFoundation的内存管理 block的循环引用 在for循环大量数据,不断创建局部变量的几点思考 mrc的基础问题 第三方框架中的内存问题 CoreFoundation的内存管理在编程过程中我们会多次使用CoreFoundation的API,例如CFStringRef,CFArray,CFUUIDRef等。当遇到这些某些关键字的时候我们要时刻注意内存管理方面的问题了。例如alloc,create,copy,mutableCopy,CFRetain等关键字。当遇到这些关键字时，我们就要手动去管理内存了。释放内存的原则还是与手动引用计数相似， 需要引用时，引用计数+1，不需要引用时，引用计数-1 谁创建，谁release 谁retain，谁release 只要调用了alloc,必须要有realease(autorelease)example: 1234CFUUIDRef uuid = CFUUIDCreate(NULL);appUID = (NSString *)CFUUIDCreateString(NULL,uuid);CFRelease(uuid);CFRelease(appUID); block的循环引用问题循环引用问题的现象就是在内存管理方面形成了闭环，互相强引用了对方，导致在内存释放时，都无法得到释放，所以导致了该现象的发生。解决办法：就是打破闭环，在某一端的引用问题上实现弱引用，这也就是我们在代码中常见的strongSelf和weakSelf的使用。for example实例1：123456- (void)case1 &#123;NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name = @&quot;case 1&quot;; &#125;);&#125; 这种情况是不会造成内存泄漏原因就是：在block中内部引用了slef，但是self并没有引用block在系统API的block中不会出现循环引用的问题，这样的API还有UIView的动画block，GCD等。实例2：12345678- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weaktypeof(self) weakSelf = self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;case 2&quot;; &#125;];&#125; 这种就是我们常见的循环引用问题self持有了requestData这个block，在block中又引用了self，形成了一个闭环，使用weakself来打破闭环，解除循环引用。但是为了避免在block执行过程中self过早释放的问题，在block中又将weakself进行了强制引用。当self释放时，block还能够继续执行，当block执行结束后会对强引用的self进行释放。实例3：1234567- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name = @&quot;case 4&quot;; self.teacher = nil; &#125;];&#125; 不存在循环引用，因为在block执行结束后，block主动释放了持有者，在很多框架设计的时候都有这种设计。还有一种设计思想来自猿题库的网络框架设计YTKNetwork就是在block执行结束后，将block置nil。实例4：1234567- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t = [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name = @&quot;case 5&quot;; &#125;];&#125; 不存在循环引用，因为局部变量持有的block，在这个case5方法内部有效，出了大括号局部变量就会释放。 实例512345678910- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block = ^(NSData *data) &#123; self.name = @&quot;case 6&quot;; //下面两句代码任选其一 self.teacher = nil; // self.teacher.case6Block = nil; &#125;;&#125; 在block执行结束后置nil操作，解决内存泄漏问题 for循环大量数据时，不断创建局部变量的思考在使用for循环大量数据并创建大量局部变量时内存会飙升，有兴趣的同学可以试试，从10000次-到10万次看一下内存的增长速度。conclusion：在for循环大量数据并不断创建局部变量时，不适用@autorelasepool，临时变量的内存增长可能是爆发式的。但是当使用@autoreleasepool后，在每个@autoreleasepool结束时，局部变量都会被回收，内存使用更加合理。 mrc的基础虽然现在已经有arc帮助我们管理内存，但是做为一个开发者，理解内存管理是基础。所以在iOS开发中我们要牢记mrc的基本原则： 需要引用时，引用计数+1，不需要引用时，引用计数-1 （reatin-&gt;release） 谁创建，谁release (alloc-&gt;release） 谁retain，谁release (retain-&gt;release) 只要调用了alloc,必须要有realease(autorelease) (alloc-&gt;release(autorelease)) 关于第三方出现的循环引用问题我们项目中网络请求库用的AFN，但是由于在实例化AFHTTPSessionManager中，当并行多个请求时会创建多个manager，当使用leaks查看内存问题时看到AFN代码中这行代码中的init方法会出现内存泄漏。1[[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; 解决办法：采用单例的方式创建。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"localizable.strings国际化和本地化处理","slug":"localizable-strings国际化和本地化处理","date":"2017-12-25T04:59:25.000Z","updated":"2017-12-25T05:46:57.000Z","comments":true,"path":"2017/12/25/localizable-strings国际化和本地化处理/","link":"","permalink":"http://yoursite.com/2017/12/25/localizable-strings国际化和本地化处理/","excerpt":"","text":"","categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}],"keywords":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}]}]}