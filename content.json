{"meta":{"title":"Vicky的技术博客","subtitle":null,"description":"15年毕业于榆林学院,现就职于杭州东导数据科技有限公司.两年多的iOS开发,使我熟练掌握和使用Objective-C和Swift","author":"Vicky","url":"http://yoursite.com"},"pages":[{"title":"文章分类","date":"2017-12-25T05:35:45.000Z","updated":"2018-10-12T02:53:39.508Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-12-25T05:34:40.000Z","updated":"2018-10-12T02:54:47.216Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人简介我是一名Coder，从事iOS开发两年多，暂居于杭州。 吾尚未足以，必潜心修行。"},{"title":"标签","date":"2017-12-25T05:34:40.000Z","updated":"2018-10-12T02:53:48.688Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"rxswift学习(一)","slug":"rxswift学习","date":"2018-10-12T06:49:10.000Z","updated":"2018-10-12T07:00:20.610Z","comments":true,"path":"2018/10/12/rxswift学习/","link":"","permalink":"http://yoursite.com/2018/10/12/rxswift学习/","excerpt":"","text":"sssssssss","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"iOS开发小记","slug":"iOS开发小记","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:08:36.847Z","comments":false,"path":"2018/10/12/iOS开发小记/","link":"","permalink":"http://yoursite.com/2018/10/12/iOS开发小记/","excerpt":"","text":"iOS","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"HomeBrew VS Wegt","slug":"HomeBrew与Ruby更新","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:05:33.984Z","comments":false,"path":"2018/10/12/HomeBrew与Ruby更新/","link":"","permalink":"http://yoursite.com/2018/10/12/HomeBrew与Ruby更新/","excerpt":"","text":"HomeBrew 与 wegtHomeBrew 是一款自由及开放源代码的软件包管理系统,用以简化Mac OS X系统上的软件安装过程.它使用Ruby语言写成,针对Mac OS X操作系统自带的Ruby版本,默认安装在/usr/local下.由一个核心的git版本库构成,以使用户能更新HomeBrew.包管理器使用一种称为”公式”的DSL脚本来管理依赖,下载源代码及配置和编译软件,从源代码中构建软件 安装需求 Xcode 安装方式 1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 相关指令 搜索: 1brew search 套件名称 查询套件信息 1brew info 套件名称 安装套件 1brew install 套件名称 查询目前已经安装的套件 1brew list 更新HomeBrew 1brew update 卸载HomeBrew 1234$ cd `brew --prefix`$ rm -rf Cellar$ brew prune$ rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew$ rm -rf ~/Library/Caches/Homebrew wegt 是linux的一个命令用来下载文件的工具我只有在虚拟机上使用过这个命令,主要作用是用来下载文件.比如说做后台的同学想下载tomcat,就可以通过这个来下载,过多的内容接不介绍了 RubyMac OS X 系统自带了ruby环境,所以我们一般是不需要管理ruby环境的,今天说这个问题是在过年期间我在更新mac系统时出错了缺少系统启动文件,然后我就恢复系统了,知道今天才发现我pod install执行不了,提示ruby的版本过低,而我的pod版本是最新版,所以我就想通过更新ruby来解决问题,但是更新ruby时又发现brew出错了.所以很生气,后果很严重.下载brew,更新ruby,pod就好了卸载和安装上面都有讲述.更新ruby 1brew upgrade ruby Cocoapods对于iOS开发的同学,使用cocoapods是在所难免的,所以不再过多讲述,网上的文章一搜一大堆.pod入门到放弃","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"HomeBrew","slug":"HomeBrew","permalink":"http://yoursite.com/tags/HomeBrew/"},{"name":"wegt","slug":"wegt","permalink":"http://yoursite.com/tags/wegt/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"细说IBoutlet","slug":"IBoutlet杂谈","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:07:18.181Z","comments":false,"path":"2018/10/12/IBoutlet杂谈/","link":"","permalink":"http://yoursite.com/2018/10/12/IBoutlet杂谈/","excerpt":"","text":"细说IBoutlet当我们在XIb文件或者SB文件中添加空间后,需要与对应属性关联时就会产生 @property(nonatomic,weak) IBoutlet UIbutton *button 那么 IBoutlet到底有什么作用啦.首先IBoutlet不是系统关键字,只是位于系统头文件中的一组预处理命令 #ifdef IBoutlet #define IBoutlet #endif 对于编译器来说,它没有任何作用.它只是告诉Xcode,它和Xib文件中的对象关联. 在古老的OC语言中.我们声明属性是,都需要声明相对应的实例变量 @interface ViewController : UIViewController { IBoutlet UIbutton *button; } @property(nonatomic,weak) IBoutlet UIbutton *button; @end 那为什么要这么做,因为当时采用GCC的编译器.最后苹果开发出了自己的编译器LLVM.在声明属性时,就不需要声明实例变量了.因为LLVM在编译过程中如果没有找到对应属性的实例变量,会自己创建.所以就不需要声明了.就将IBoutlet迁移到了属性声明上.区别于自己声明的属性和与XIB文件中对象关联的属性.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"IBoutlet","slug":"IBoutlet","permalink":"http://yoursite.com/tags/IBoutlet/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"Objective-C视频学习资源","slug":"Objective-C学习资源和大神博客","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:13:22.293Z","comments":false,"path":"2018/10/12/Objective-C学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2018/10/12/Objective-C学习资源和大神博客/","excerpt":"","text":"Objective-C视频学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源又包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Objective-C对象的构造模式","slug":"Objective-C的对象构造模式","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:46:44.078Z","comments":false,"path":"2018/10/12/Objective-C的对象构造模式/","link":"","permalink":"http://yoursite.com/2018/10/12/Objective-C的对象构造模式/","excerpt":"","text":"谈对象的构造模式Objective-C语言在创建对象的时候需要先调用alloc,然后实例对象调用init方法完成初始化. alloc究竟干了什么为了能够看到alloc到底干了什么,我们可以下载GNUStep开源的libs-base工程然后找到NSObject.m文件.为什么用GNUStep来查看源码? GNUstep，GNU计划的项目之一。它将Cocoa（前身为NeXT的OpenStep）Objective-C软件库，部件工具箱（widget toolkits）以及其上的应用软件，以自由软件方式重新实现。它能够运行在类Unix操作系统上，也能运作在Microsoft Windows上。GNUStep 1234+ (id) alloc&#123; return [self allocWithZone: NSDefaultMallocZone()];&#125; 可以看到它调用了allocWithZone方法,具体作用就是给当前创建的实例对象开辟内存空间. 12345NSZone*NSDefaultMallocZone (void)&#123; return &amp;default_zone;&#125; 我们都知道oc对象的本质其实就是结构体,在开辟内存空间函数内部,他会遍历当前结构体的所有成员变量,然后根据成员变量的数据类型计算内存大小. 当alloc函数调用完成后会返回一个未初始化的实例,在这里cocoa不仅为这个实例申请了足够大的内存空间还做了以下几件事:1.将该对象的引用计数加12.将该对象的isa指针指向类3.为成员变量初始化值nil/0 init方法init方法是该对象的初始化方法,目的是初始化该对象的成员变量. new方法类方法new的出现是苹果对java等程序员的照顾,而new方法的内部和调用alloc、init是一致的。可以从GNUStep的源代码中得出结论。 1234+ (id) new&#123; return [[self alloc] init];&#125; 设计原则alloc和init的定位不同： alloc旨在为实例对象在虚拟内存上申请足够大的内存空间。而且将对象的retainCount+1.帮助系统完成内存管理。将isa指针指向该类，是为了在运行时环境中完成对该类的检查。 init方法旨在完成该对象成员变量的初始化。在内存方面并没有什么处理。 这样设计的结果可以使苹果开发者更加清晰的了解这两个函数的作用。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"alloc","slug":"alloc","permalink":"http://yoursite.com/tags/alloc/"},{"name":"构造模式","slug":"构造模式","permalink":"http://yoursite.com/tags/构造模式/"},{"name":"init","slug":"init","permalink":"http://yoursite.com/tags/init/"},{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/设计原则/"},{"name":"new","slug":"new","permalink":"http://yoursite.com/tags/new/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"React(二)","slug":"React第二课","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:14:12.658Z","comments":false,"path":"2018/10/12/React第二课/","link":"","permalink":"http://yoursite.com/2018/10/12/React第二课/","excerpt":"","text":"元素渲染:元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器的数据内容和React的保持一致 浏览器中的Dom元素: 元素和组件:元素是组件的一个组成部分,而组件更加广义,在下一课中我们一起学习组件 元素举例 1const element = &lt;h1&gt;hello world!&lt;/h1&gt; 将元素渲染到Dom中在学习完元素之后,我们应该如何将元素显示并渲染到界面上就是这个问题所要研究的内容.大家是否还记得在创建完项目后,我们打开看过index.html的源码在body中有一行这样的代码 1&lt;div id= &quot;root&quot;&gt;&lt;/div&gt; 如果还没有回忆起来那就打开项目看一下,而且在上一课中我按照我的理解已经解释过为什么屏幕上会出现hello world!的原理.这里在说一次在index.js的代码中又这样几行代码 123456const element = &lt;h1&gt;hello world!&lt;/h1&gt;ReactDom.render( element, document.getElementById(&apos;root&apos;)); 也就是说在这个div中的所有内容将有ReactDom来管理,render只是一个渲染函数,这个div也被称为根Dom节点.做过手机App开发的也可以这样理解他就是父视图,后续所有的元素和子视图都是在他上面添加和渲染的.我们会将我们需要渲染的内容通过id获取到根dom节点,然后将其填充到根dom节点中,渲染到页面上.这一切的操作都是由ReactDom来完成的. 更新Dom元素重点:React元素都是不可变的,做过App的都知道不可变的类型有很多在iOS 中常见的NSString,NSArray,NSDictionary,NSSet等.,所以React也是不可以修改其内容和属性的.那么到目前为止我们应该怎样去更新这个元素啦?就是通过创建一个新的元素然后重新渲染到界面上.(is only,not is only)只是针对目前知识浅薄而已.后面应该会有办法更新的,后面我们一起学到了再说.说到这里就举一个例子吧 1234567891011121314151617let tick = () =&gt; &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick,1000); 1234567891011121314151617function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;h2&gt; Is is Time &#123;new Date().toLocaleString()&#125;. &lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125; 上面的例子中我们通过定时器不断的调用ReactDom的render函数来更新h2这个标签的内容.效果大家可以自己在自己代码中尝试一下(两端代码都可以,一个是箭头函数,一个是常规的js),并且使用检查来观察h2的变化. 重点:在实际项目中render函数只会被调用一次.这次只是为了在目前学习到的基础上看到更新的效果才不得已而为之,如果在以后的开发中,你们使用了这样的方式调用render函数,那么你就要考虑代码的设计问题了. React只会更新必要的部分在开发中又用过数据库的同学应该了解数据库的update操作,当一条记录需要被更新时,他会拿到这条记录的主见然后查找到这条记录,进行字段比对,当有某一个值更新时,才会更新.所以React的更新也是这样的,只会更新发生变化的部分,其他的东西我不会主动更新. 在上一个例子中,我们使用定时器不断的创建描述整个界面的元素,但是当你使用检查检测时会发现,只有h2在不断变化,其他的都是不会发生变化的.在开发中我们会将界面视为一帧一帧的动画,不是随时变化的.我们在发生更新时只需要更新那一帧动画即可,并不需要将更段动画全部更新. 在很多时候都是这样的.基本上所有的开发中只关注我们需要更新的内容,其余的内容我们不需要理会.","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[],"keywords":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}]},{"title":"SDWebImage源码阅读(一)","slug":"SDWebImage源码阅读","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:16:29.675Z","comments":false,"path":"2018/10/12/SDWebImage源码阅读/","link":"","permalink":"http://yoursite.com/2018/10/12/SDWebImage源码阅读/","excerpt":"","text":"SDWebImage的目录层级都说技术的成长要不断的学习和不断的练习.学习可以有很多方法For example 读书,阅读博客,阅读源代码,还有就是我们观看一些技术讨论会,分享会和开发者大会.而我们今天要讲的是从阅读源码开始.从事iOS开发三年来,有读过源码,但是都不完整.所以我目前的长进还只是停留在某个层面.所以从现在开始养成阅读源码的习惯.但是好的源码有很多,到底该如何入手.那么先从加载图片框架开始! 我们要阅读一份源码,首先会看到这份源码的层级结构,包含哪些文件根据文件名判断其主要功能和作用.SD目录层级如下:","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/categories/源码阅读/"}],"tags":[{"name":"sdwebimage","slug":"sdwebimage","permalink":"http://yoursite.com/tags/sdwebimage/"}],"keywords":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/categories/源码阅读/"}]},{"title":"Swift学习资源","slug":"Swift学习资源和大神博客","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:17:41.165Z","comments":false,"path":"2018/10/12/Swift学习资源和大神博客/","link":"","permalink":"http://yoursite.com/2018/10/12/Swift学习资源和大神博客/","excerpt":"","text":"Swift学习资源因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源也包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。 视频教程(英文) Lynda Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。 Udemy Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。 书籍 Objective-C Programming 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。 iOS Programming 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论 Cocoa Design Patterns 适合打算深入了解 Cocoa 的人看 Learn Objective-C 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解 Objective-C 基础教程 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读 iOS 开发进阶 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读 Programming in Objective-C Programming in Objective-C 这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细 iOS 测试指南 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。 Objective-C 编程之道 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读 Objective-C 高级编程 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读 Effective Objective C 2.0 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用 The Swift Programming Language 中文版 学习Swift基础的中文文档，目前更新到Swift3.0文档 博客 OneV’s Den 唐巧的技术博客 ibireme bang 孙源的技术博客 破船之家 NSHipster Limboy 无网不剩 Kevin Blog IMTX 廖雪峰 向晨宇的技术博客 雷纯锋的技术博客 老谭笔记 Kenshin Cui’s Blog Casa Taloyum 庞海礁的个人空间 土土哥的技术blog 玉令天下的博客 萧宸宇 摇滚诗人 王中周的技术博客 Blog | nswebfrog limboy 社区论坛 objc中国 cocoachina objc code4App Cocos2d-x iPhone Dev SDK 国内知名程序员开发日报 掘金 极客头条 开发者头条 码农周刊 伯乐头条 segmentfault 知乎","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"Architectures","slug":"Xcode之Architectures设置","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:19:09.404Z","comments":false,"path":"2018/10/12/Xcode之Architectures设置/","link":"","permalink":"http://yoursite.com/2018/10/12/Xcode之Architectures设置/","excerpt":"","text":"Xcode设置项之Architectures和Valid Architectures为什么会聊到这个话题,我今天早上刚到公司,说我们App晚上要发版,但是我周六对电脑的Xcode中的缓存文件进行了大规模的清理.然后打开项目跑代码的时候,发现怎么运行不起来了,一直报错library not found for -lafnetworking然后我开始不断的尝试各种方法,最终还是没有解决,大约在14年左右吧,这个项目当时还是使用cocoapods的,最后经过岁月的摧残,当我拿到项目的时候,交接的人说cocoapods不能用,我当时心里就感觉到,这他妈要凉啊.那我导入第三方还要手动拖进去,这也太尴尬了吧.最后我实在忍不住了,就执行了pod install,然后应用程序就有问题了,找到问题-&gt;修改问题-&gt;测试-&gt;成功-&gt;倍儿爽!.但是这次我不知道为什么前几天还好好的工程,为什么在我删除Xcode的一些过大文件后就报错了啦.原因目前可能是将某个配置文件删除了,重新编译的过程中,使用了一个有问题的编译配置.知道是配置的问题,那就开始找问题,我找到以前的代码对比配置,尤其是pod的配置,因为错误很明显afnetworking.我发现在Build Active Architecture only这里以前Debug和Release都是No,但是现在却是Yes,当我改成No之后编译就成功了,虽然可能会在调试的时候编译会慢,但是问题还得慢慢找,先解决发版在说.虽然很懵逼,但是很开心.终于可以赶上发版了.要是出问题了,就又得加班了,关键是这个周末我没有休息,来公司做其他项目了.眼睛也不知道为什么会肿.所以看到问题就很难受.言归正传 介绍上面的两个名词 Valid Architectures您的App需要支持的指令集,最终生成的二进制文件所支持的指令集 如果你设置Valid Architectures支出armv7/armv7s/arm64,Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。到底armv7什么含义可以自己去看一下,简单的理解就是arm处理器的指令集,也就是你支持设备版本. Build Active Architecture Only该编译项用于设置是否只编译当前使用的设备对应的arm指令集。就是你用什么设备调试,就是用对应的指令集去进行编译.当该选项设置成YES时，你连上一个armv7指令集的设备，就算你的Valid Architectures和Architectures都设置成armv7/armv7s/arm64，还是依然只会生成一个armv7指令集的二进制包.当选择NO,那就是你设置了几种,它就会编译几种,最终产生的二进制文件较大,而且编译过程会慢. 重点 指令集都是可以向下兼容的 作用如果你想较小包的大小,就可以设置这个来减少编译不同指令的包.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"Xcode常用命令","slug":"Xcode调试技巧和常用快捷键","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:18:22.600Z","comments":false,"path":"2018/10/12/Xcode调试技巧和常用快捷键/","link":"","permalink":"http://yoursite.com/2018/10/12/Xcode调试技巧和常用快捷键/","excerpt":"","text":"Xcode常用命令p :常用来输出基础数据类型 po :常用来输出oc对象类型 expr :可以在调试时动态的执行表达式，同时打印出结果。常用来动态修改变量的值。 call :常用来动态调用函数 image: image命令可以列出当前App中的所有模块 po [view recursiveDescription] 查看view的层级关系 Xcode常用快捷键shift+command+o :快速打开文件 Command+1~9:导航面版切换","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"常用命令","slug":"常用命令","permalink":"http://yoursite.com/tags/常用命令/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"版本控制","slug":"git从0到1","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:04:37.125Z","comments":false,"path":"2018/10/12/git从0到1/","link":"","permalink":"http://yoursite.com/2018/10/12/git从0到1/","excerpt":"","text":"关于版本控制版本控制是帮助我们记录文件内容发生变化,方便后面查阅每个版本不同的修订情况.还可以通过版本控制回溯到某个版本的状态.还可以比较文件的变化细节. 集中化的版本控制系统","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"iOS内存管理(二)","slug":"iOS内存管理-1","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T02:55:43.746Z","comments":false,"path":"2018/10/12/iOS内存管理-1/","link":"","permalink":"http://yoursite.com/2018/10/12/iOS内存管理-1/","excerpt":"","text":"ssssss","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"release","slug":"release","permalink":"http://yoursite.com/tags/release/"},{"name":"autorelease","slug":"autorelease","permalink":"http://yoursite.com/tags/autorelease/"},{"name":"dealloc","slug":"dealloc","permalink":"http://yoursite.com/tags/dealloc/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"iOS应用攻防实战(一)","slug":"iOS应用安全攻防实战","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:10:32.468Z","comments":false,"path":"2018/10/12/iOS应用安全攻防实战/","link":"","permalink":"http://yoursite.com/2018/10/12/iOS应用安全攻防实战/","excerpt":"","text":"误解1: 认证因为这设备是安全可信任的设备和产品的认证,只是认证机构对于设备和产品的概念性功能和实现能力的合规性认证,在认证的过程中并没有对设备和产品进行渗透性测试.并不能保证设备和程序不被黑客攻破. 误解2: 单一性安全机制单一性安全机制的问题,就存在与单一性上,他简化了攻破所需要分析的代码.如果一旦单一的安全机制被攻破,所有基于这个单一安全机制的设备和程序都将被攻破. iOS安全模型1.设备安全:防止未授权的人使用设备 2.数据安全:存储在设备上的数据得到保护 3.网络安全:当通过网络传输时的加密工具 4.应用软件安全:加固操作系统并隔离运行时应用软件的机制 设备安全对于设备安全,苹果做出的应对是设置密码和PIN锁.苹果允许企业在安全策略中强制设置这些锁,或个人用户手动设置. 数据安全苹果的数据加密是很值得一提的,采用硬件加密加速器来加密选定的应用软件数据.通过将这些存储在设备上的特定加密密钥与用户设置的密码结合,该系统可以保证只有在用户输入密码后文件系统中这些被保护的文件才会解密.所以用户输入的密码的安全性就是关键.所以密码的复杂度就决定破解的难度. 网络安全苹果使用了很多方法来加密网络包括VPN,SSL,TLS传输层协议,WEP,WPA,WPA2无线网络加密和认证,和2017年一月份提出的HTTPS强制要求都是为了网络安全. 应用软件的安全应用软件的安全,完全依赖于苹果的沙盒技术.拼过系统将自身可被访问的API作为接口放出.应用软件本身不可以访问系统组件,和其他应用软件.沙盒机制限制了一个应用的内存和CPU使用的总量,当超出限制时,出现崩溃闪退现象.他只可以对自己文件目录访问. 为了限制应用软件访问设备资源,苹果使用代码签名的方式,所有运行在设备上的二进制代码,必须经过苹果签名或者使用苹果办法的证书签名.这样做可以保证自身无法修改二进制文件.苹果也可以检测其应用软件的完整性.确保没有被签名的代码注入. 钥匙串技术,可以将一些网络凭证,其他信息保存在钥匙串中,还提供了低级别的加密解密方法. 苹果还提供了基础的加密解密算法(common crypto),开发者可以使用加密算法,对数据机型加密. 误解三:iOS文件系统加密可以防止设备上的数据失窃(直到iOS5)iOS的文件系统加密使用了将秘钥he数据存储在同一设备上的加密系统(直到iOS5)攻击者只需要活的在设备上执行代码的权限,就可以计算出密钥来破解数据.密钥是数字形态的,谁拥有设备的数字拥有权,谁就能同时拿到锁和钥匙 密码等于弱安全相比于PC，移动设备的安全性和用户体验之间的取舍就很严重了。举一个例子：我们在使用完手机后，时不时会把放进口袋里。每一次使用手机都要进行解锁。所以手机厂商在设计这个安全锁时，就必须考虑密码的简单性。要不然用户体验就会很差（vicky_12@.qq.com）。这样的密码在pc上输入还可以，在每次解锁手机屏幕时，用户可能会取消这个设备锁。因为太过于麻烦。所以厂商的设计一般都是某种图形或者是4位或者6位数字。所以密码是弱安全。 误解四：关心安全的用户会设置复杂的密码大多数用户任然选择PIN码和简单的密码保护自己的设备。这样做是因为他们不知道密码的复杂度与设备加密强度的关系。他们自认为，我设置密码就可以赶跑那些坏人。如果坏人足够坏，你设置的密码是远远不够的。所以假设你的用户一般都只会使用简单PIN码和密码来保护设备。 误解五：强密码依然不能保证设备安全我们所指出的强弱密码并不能完全保证你设备的安全，因为在强的东西也有破绽，只是击破它的复杂度上升了，并没有说完全安全性。在互联网方面，没有完全的安全。 数字取证击败加密可能你编写的代码是很安全的，你的应用软件是很安全的。按时操作系统会不断削减你的安全性。操作系统会不断缓存你所产生的操作（键盘操作）web缓存。文件操作等。操作系统都可以缓存到磁盘中。而且操作系统还可以恢复你删除掉的私密文件。私密文件的加密秘钥只要还存在，私密文件就可能被恢复。而且更加恐怖的是连私密文件的密钥都可以被恢复。 误解六： 如果应用软件安全的实现了加密，数据就无法从设备中被恢复首先你错了。上面已经说过了操作系统会不断削弱你的安全性，会缓存你的操作和文件。就连你私密文件的密钥都能操作，你还认为应用软件安全吗？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"攻防","slug":"攻防","permalink":"http://yoursite.com/tags/攻防/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"HTTP/DNS解析与DNS劫持","slug":"HTTP-DNS解析-DNS劫持","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:06:41.566Z","comments":false,"path":"2018/10/12/HTTP-DNS解析-DNS劫持/","link":"","permalink":"http://yoursite.com/2018/10/12/HTTP-DNS解析-DNS劫持/","excerpt":"","text":"HTTP/DNS解析/DNS劫持HTTP请求HTTP全名超文本传输协议，是一种用于分布式，协作式的超媒体信息系统的应用层协议。 HTTP请求行：请求地址和协议版本 HTTP请求头： 请求头中包含：Accept(能够接受的回应内容类型)，Accept-Charset(能够接受的字符集)，Cache-Control(缓存机制)，Connenct(连接类型)，Cookie，Content-Length(请求体的长度)，Content-Type（请求体的多媒体类型），Host(端口)等 HTTP请求体： 任意类型：服务器不会解析请求体，请求体的处理需要后台同学自己处理解析 application/json 使得请求体结构化，序列化可以方便提交复杂的数据结构，也适合在调试接口阶段进行抓包等行为。 text/xml：以XML的方式提交，因为XML支持各种语言使用广泛。但是XML相对于JSON较为臃肿。目前大多数场景都是使用JSON提交 表单提交：application/x-www-form-urlencoded，使得参数必须以键值对的形式并用&amp;链接。 文件提交：multipart/form-data 在上传图片时或者其他类型文件时，都是将文件分成多个部分。每一个部分都是以boundary分割 HTTP请求方法： POST 向指定资源提交数据，数据放在请求本文中，这个请求可以修改现有资源也可以创建新资源 GET 获取指定资源，使用GET请求只用于读取数据。 HEAD 向服务器放出指定资源的请求(目前我还没用到) DELETE 删除服务器上Request-URL标记的资源 PUT 向服务器指定资源位置上传最新内容 TRACE (没用到)HTTP维基百科 OPTIONS (没用到)HTTP维基百科 CONNECT (没用到)HTTP维基百科 HTTP请求过程：当我们手机，pc等网络设备请求百度的域名时分为三步： 1.请求到达运营商DNS服务器并解析这个域名，查找对应的IP地址2.根据IP地址查找对应的服务器，向服务器发起一个HTTP请求3.服务器收到请求后，将所需资源包装后原路返回给网络设备DNS解析就在前一段时间我刚自己买了一个VPS服务器，然后自己买了域名，目的就是为了搭建属于自己的博客，买完服务器后，服务器有对应的IP地址，我为了使用我买的域名访问我的博客，我就必须将服务器的IP和域名进行映射(DNS解析) DNS解析：就是讲域名指向网站空间的IP上，让用户可以通过域名访问到网站的一种服务。域名解析就是域名到IP地址的转换过程。这个过程由DNS服务器完成。 DNS解析的过程： 1.用户主机上运行着DNS的客户端2.浏览器将输入的URL中抽出域名字段3.DNS客户端会向DNS服务器端发送一个查询报文，报文中包含域名字段。4.DNS服务器端响应DNS客户端报文，找到域名对应的IP地址。5.DNS客户端收到DNS服务器的响应报文，其中包含主机名和IP地址6.浏览器拿到IP地址后，就是向该IP地址定位到的HTTP服务器发起请求进行TCP连接。DNS劫持在发生请求时，当运营商收到用户主机请求后，获取到域名，然后通过DNS服务器进行解析，在解析的过程中可能DNS服务器受到第三方攻击。就是第三方攻击解析服务器，使得服务器无法正常解析，然后修改解析后的IP地址指向一个虚假的服务器。如图所示 解决办法：可以使用自己的解析服务器自行解析，或者在APP内部使用解析好的域名以IP的形式访问。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"HTTP/DNS解析","slug":"HTTP-DNS解析","permalink":"http://yoursite.com/tags/HTTP-DNS解析/"},{"name":"DNS劫持","slug":"DNS劫持","permalink":"http://yoursite.com/tags/DNS劫持/"}],"keywords":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}]},{"title":"国际化本地化","slug":"localizable-strings国际化和本地化处理","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:11:00.124Z","comments":false,"path":"2018/10/12/localizable-strings国际化和本地化处理/","link":"","permalink":"http://yoursite.com/2018/10/12/localizable-strings国际化和本地化处理/","excerpt":"","text":"这篇文章我在简书上已经写过直接跳转简书查看利用Localizable.strings做本地化和国际化处理","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"Localizable.strings","slug":"Localizable-strings","permalink":"http://yoursite.com/tags/Localizable-strings/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"instrument使用","slug":"instrument的使用","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:08:15.489Z","comments":false,"path":"2018/10/12/instrument的使用/","link":"","permalink":"http://yoursite.com/2018/10/12/instrument的使用/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"内存分析","slug":"内存分析","permalink":"http://yoursite.com/tags/内存分析/"},{"name":"时间复杂度分析","slug":"时间复杂度分析","permalink":"http://yoursite.com/tags/时间复杂度分析/"},{"name":"CPU占用分析","slug":"CPU占用分析","permalink":"http://yoursite.com/tags/CPU占用分析/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"mysql","slug":"mysql安装","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:11:38.811Z","comments":false,"path":"2018/10/12/mysql安装/","link":"","permalink":"http://yoursite.com/2018/10/12/mysql安装/","excerpt":"","text":"mac 安装mysql 1.安装homebrew 2.brew uninstall mysql 3.brew install mysql 4.mysql -u root -p 5.如果出现报错执行 unset TMPDIR bash mysql_install_db --verbose --user=root --basedir=&quot;$(brew --prefix mysql)&quot;--datadir=/usr/local/var/mysql --tmpdir=/tmp bash mysql.server start","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/安装/"},{"name":"使用","slug":"使用","permalink":"http://yoursite.com/tags/使用/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"React(一)","slug":"react第一节","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:14:58.960Z","comments":false,"path":"2018/10/12/react第一节/","link":"","permalink":"http://yoursite.com/2018/10/12/react第一节/","excerpt":"","text":"配置React开发环境我们选择使用HomeBrew来安装node 安装homebrew ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 更新brew brew update 配置环境变量 vim ./bash.profile export PATH=\"/usr/local/bin:$PATH\" esc,shift+wq退出并保存 为了保证你的环境中没有node的参与文件,可以通过以下命令完全删除node sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*} 安装node brew link node brew uninstall node brew install node 测试安装是否成功 npm install -g grunt-cli 创建项目mkdir react-demo cd react-demo npm install -g create-react-app create-react-app my-app cd my-app npm start 这样就可以看到运行起来的react项目 修改项目删除APP.js,App.css,App.test.js,index.css,logo.svg,registerServiceWorker.js 文件修改index.js文件 import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; ReactDOM.render( &lt;h1&gt;Hello world&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); npm start 运行 理解上面的这段代码会渲染一个id叫做root的dom元素,所以在index.html中我们会看到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 因为我是iOS的开发工作者,我的理解是,html文件向我们提供了一个父视图View也就是这里的div,然后我们根据设置这个View的id来让外界访问.然后在index.js文件中我们创建了一个子视图,并添加到div这个父视图上.就显示到了html页面上. 开始学习本人从未开发过react项目一切都是从零开始,选择编辑器开发react的工具有很多,有IDEA,WebStrom,SublimeText等.具体安装什么插件,网上都有教程,这里不做详细说明,可以按照个人喜好安装. 我选择是idea来编辑项目,因为公司的前端小伙伴都是使用这个编辑器,方便学习和交流,我也推荐大家按照公司小伙伴的喜好来使用编辑器,这样有什么不懂的更方便询问和学习. JSX简介我对jsx 的理解就是JavaScript + XML组成JSX第一步使用JSX语法修改刚才的项目 const element = &lt;h1&gt;Hello world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 第一行的代码看起来既不是字符串也不是html,而他正式这个react的主角:JSX,也就是js的语法扩展,在OC中也有很多语法扩展.说到这里我就说一下iOS中的语法扩展GCC扩展语法,为什么这样写,这样写有什么好处 优点:1.如果不是通过XIB来定义控件我们经常会看到大量的定义UI界面的代码,如果开发这的代码规范有很大的纰漏,那样我相信你们会很发燥,因为可能要到处找代码,例如这个控件的颜色到底在哪里设置的.但是通过这样的语法我们就可以将代码放在大括号内部,是代码更加清晰整洁.2.如果你看到这样的代码,是不是也会认为这样的代码逼格会高一点啦. UIButton *secondButton = ({ UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.frame = CGRectMake(100, 100, 100, 100); button; }); 回到JSX的话题. let fommat = (user)=&gt; user.firstName + &apos;&apos; + user.lastName; const user = { firstName:&apos;wei&apos;, lastName:&apos;qi&apos; }; const element = ( &lt;h1&gt; Hello {fommat(user)}! &lt;/h1&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 划重点:第一行代码使用了箭头函数,后面的就是JSX的基础使用 这次是我学习react的第一课,希望大家多多谅解!如果有志同道合者希望加入我的队列.谢谢!","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[],"keywords":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}]},{"title":"runtime(一)","slug":"runtime（一）","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:15:41.350Z","comments":false,"path":"2018/10/12/runtime（一）/","link":"","permalink":"http://yoursite.com/2018/10/12/runtime（一）/","excerpt":"","text":"iOS runtime是如何通过selector找到对应的IMP地址？举例： 12345678#import &quot;NSString+GetImp.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSString (GetImp)+ (void)load &#123; IMP imp = class_getMethodImplementation([NSString class], @selector(substringFromIndex:)); &#125;@end 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 分析类对象的定义objc_class的结构体有以下几个成员isa指针指向元类，所有的类方法全部在元类的方法列表中name：类名varsion：版本号info：类信息instance_size：实例的大小objc_ivar_list：成员变量listobjc_method_list：实例方法列表objc_cache：缓存objc_protocol_list：协议列表 12345struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; char * _Nullable method_types OBJC2_UNAVAILABLE; IMP _Nonnull method_imp OBJC2_UNAVAILABLE;&#125; 实例方法列表中保存的都是objc_method 分析实例方法method_name：方法名称method_types：方法的参数和返回值类型method_imp：方法实现。到目前我们已经看到我们需要的IMP 那么runtime到底是如何工作的啦。 1.根据class_getMethodImplementation的第一个参数确定对象类。2.然后根据第二个参数开始进行查找类方法列表和实例方法列表（方法类型）3.遍历实例方法列表寻找与传入的method_name相等的方法，如果找到就返回该方法的实现4.如果没找到就查找父类的方法列表和元类的方法列表，知道查找到根类和根元类的方法列表。如果还没有找到就抛出异常，否则返回。","categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}],"tags":[],"keywords":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"Effective Objective-C 2.0 52个方法","slug":"52个方法","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T06:21:03.399Z","comments":true,"path":"2018/10/12/52个方法/","link":"","permalink":"http://yoursite.com/2018/10/12/52个方法/","excerpt":"","text":"第一条:了解Objective-C的语言的起源?Objective-C和C++、Java 等都是面向对象的语言。但是在面向对象的语言中Objective-C采用的是消息结构语言，而其他的面向语言采用的还是函数调用的方式。消息结构语言来自于SmallTalk。 消息结构和函数调用的区别 消息结构决定其运行过程中所需要执行的代码由运行时环境决定，而其他面向对象语言则是由编译器决定。我们都知道 OC 是在运行时才会确定对象类型。而调用方法亦是如此，在运行时才回去查找到底该执行哪个方法。而且在 OC 中接收消息的对象可以为 nil 这是其他面向对象语言所不具有的。其他的语言都会先进行判断。 OC 作为 C 的超集在很多方面还是沿用","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"52个方法","slug":"52个方法","permalink":"http://yoursite.com/tags/52个方法/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"三个ImageView实现无限轮播","slug":"三个ImageView实现无限轮播和三个Label实现公告","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:02:09.439Z","comments":false,"path":"2018/10/12/三个ImageView实现无限轮播和三个Label实现公告/","link":"","permalink":"http://yoursite.com/2018/10/12/三个ImageView实现无限轮播和三个Label实现公告/","excerpt":"","text":"三个ImageView实现无限轮播思路 scrollView上添加三张ImageView,分别为left,center,right 初始化scrollview时设置contentOffset为中间这张图片的位置 添加定时器,设置定时器事件,当前页+1,然后在动画过渡到第三张图片的位置,在动画结束后,进行复位操作.left的image = center.image,center.image = right.imgae, 然后设置contentOffset = center.right.image = 获取下一张图片 代码实现如下 初始化scrollview let scrollview = UIScrollView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height)) scrollview.contentSize = CGSize(width: self.frame.size.width * 3, height: 0) scrollview.isPagingEnabled = true scrollview.bounces = false scrollview.showsVerticalScrollIndicator = false scrollview.showsHorizontalScrollIndicator = false scrollview.delegate = self 初始化timer timer = Timer(timeInterval: TimeInterval(scrollInterval), target: self, selector: #selector(timerAction), userInfo: nil, repeats: true) RunLoop.current.add(timer!, forMode: .commonModes) 初始化 leftImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height)) centerImageView = UIImageView(frame: CGRect(x: self.frame.size.width * 1, y: 0, width: self.frame.size.width, height: self.frame.size.height)) rightImageView = UIImageView(frame:CGRect(x: self.frame.size.width * 2, y: 0, width: self.frame.size.width, height: self.frame.size.height)) leftImageView?.kf.setImage(with: ImageResource(downloadURL: getBeforeImageUrl(index: self.currentPage))) centerImageView?.kf.setImage(with: ImageResource(downloadURL: getImageUrl(index: self.currentPage)!)) rightImageView?.kf.setImage(with: ImageResource(downloadURL: getAfterImageUrl(index: self.currentPage))) Timer事件 currentPage = currentPage + 1 if currentPage == imageArray.count { currentPage = 0 } UIView.animate(withDuration: animationInterval, animations: { self.centerImageView?.isUserInteractionEnabled = false self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 2, y: 0) }) { (finish) in self.centerImageView?.isUserInteractionEnabled = true self.leftImageView?.image = self.centerImageView?.image self.centerImageView?.image = self.rightImageView?.image self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 1, y: 0) self.rightImageView?.kf.setImage(with: ImageResource(downloadURL: self.getAfterImageUrl(index: self.currentPage))) self.pageController?.currentPage = self.currentPage } 主要代码如上,主要是理解思路. 三个Label实现公告这个和上面的思路一致,只不过是横向换成竖向.代码就不贴了.如果对这个感兴趣,可以私聊我.我可以发代码给你.或者把代码放到git上.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"轮播","slug":"轮播","permalink":"http://yoursite.com/tags/轮播/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"内存优化","slug":"优化内存泄漏的几点分析","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:03:42.106Z","comments":false,"path":"2018/10/12/优化内存泄漏的几点分析/","link":"","permalink":"http://yoursite.com/2018/10/12/优化内存泄漏的几点分析/","excerpt":"","text":"内存优化的几点分析: CoreFoundation的内存管理 block的循环引用 在for循环大量数据,不断创建局部变量的几点思考 mrc的基础问题 第三方框架中的内存问题 CoreFoundation的内存管理在编程过程中我们会多次使用CoreFoundation的API,例如CFStringRef,CFArray,CFUUIDRef等。当遇到这些某些关键字的时候我们要时刻注意内存管理方面的问题了。例如alloc,create,copy,mutableCopy,CFRetain等关键字。当遇到这些关键字时，我们就要手动去管理内存了。释放内存的原则还是与手动引用计数相似， 需要引用时，引用计数+1，不需要引用时，引用计数-1 谁创建，谁release 谁retain，谁release 只要调用了alloc,必须要有realease(autorelease)example: 1234CFUUIDRef uuid = CFUUIDCreate(NULL);appUID = (NSString *)CFUUIDCreateString(NULL,uuid);CFRelease(uuid);CFRelease(appUID); block的循环引用问题循环引用问题的现象就是在内存管理方面形成了闭环，互相强引用了对方，导致在内存释放时，都无法得到释放，所以导致了该现象的发生。解决办法：就是打破闭环，在某一端的引用问题上实现弱引用，这也就是我们在代码中常见的strongSelf和weakSelf的使用。for example实例1：123456- (void)case1 &#123;NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name = @&quot;case 1&quot;; &#125;);&#125; 这种情况是不会造成内存泄漏原因就是：在block中内部引用了slef，但是self并没有引用block在系统API的block中不会出现循环引用的问题，这样的API还有UIView的动画block，GCD等。实例2：12345678- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weaktypeof(self) weakSelf = self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;case 2&quot;; &#125;];&#125; 这种就是我们常见的循环引用问题self持有了requestData这个block，在block中又引用了self，形成了一个闭环，使用weakself来打破闭环，解除循环引用。但是为了避免在block执行过程中self过早释放的问题，在block中又将weakself进行了强制引用。当self释放时，block还能够继续执行，当block执行结束后会对强引用的self进行释放。实例3：1234567- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name = @&quot;case 4&quot;; self.teacher = nil; &#125;];&#125; 不存在循环引用，因为在block执行结束后，block主动释放了持有者，在很多框架设计的时候都有这种设计。还有一种设计思想来自猿题库的网络框架设计YTKNetwork就是在block执行结束后，将block置nil。实例4：1234567- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t = [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name = @&quot;case 5&quot;; &#125;];&#125; 不存在循环引用，因为局部变量持有的block，在这个case5方法内部有效，出了大括号局部变量就会释放。 实例512345678910- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block = ^(NSData *data) &#123; self.name = @&quot;case 6&quot;; //下面两句代码任选其一 self.teacher = nil; // self.teacher.case6Block = nil; &#125;;&#125; 在block执行结束后置nil操作，解决内存泄漏问题 for循环大量数据时，不断创建局部变量的思考在使用for循环大量数据并创建大量局部变量时内存会飙升，有兴趣的同学可以试试，从10000次-到10万次看一下内存的增长速度。conclusion：在for循环大量数据并不断创建局部变量时，不适用@autorelasepool，临时变量的内存增长可能是爆发式的。但是当使用@autoreleasepool后，在每个@autoreleasepool结束时，局部变量都会被回收，内存使用更加合理。 mrc的基础虽然现在已经有arc帮助我们管理内存，但是做为一个开发者，理解内存管理是基础。所以在iOS开发中我们要牢记mrc的基本原则： 需要引用时，引用计数+1，不需要引用时，引用计数-1 （reatin-&gt;release） 谁创建，谁release (alloc-&gt;release） 谁retain，谁release (retain-&gt;release) 只要调用了alloc,必须要有realease(autorelease) (alloc-&gt;release(autorelease)) 关于第三方出现的循环引用问题我们项目中网络请求库用的AFN，但是由于在实例化AFHTTPSessionManager中，当并行多个请求时会创建多个manager，当使用leaks查看内存问题时看到AFN代码中这行代码中的init方法会出现内存泄漏。1[[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; 解决办法：采用单例的方式创建。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"内存问题优化","slug":"内存问题优化","permalink":"http://yoursite.com/tags/内存问题优化/"},{"name":"CoreFoundation","slug":"CoreFoundation","permalink":"http://yoursite.com/tags/CoreFoundation/"},{"name":"block的循环引用问题","slug":"block的循环引用问题","permalink":"http://yoursite.com/tags/block的循环引用问题/"},{"name":"for循环","slug":"for循环","permalink":"http://yoursite.com/tags/for循环/"},{"name":"mrc的基础","slug":"mrc的基础","permalink":"http://yoursite.com/tags/mrc的基础/"},{"name":"关于第三方出现的循环引用问题","slug":"关于第三方出现的循环引用问题","permalink":"http://yoursite.com/tags/关于第三方出现的循环引用问题/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"内存分配合内存区块","slug":"内存分配和内存区块","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:01:45.865Z","comments":false,"path":"2018/10/12/内存分配和内存区块/","link":"","permalink":"http://yoursite.com/2018/10/12/内存分配和内存区块/","excerpt":"","text":"-：内存分区栈区：分为动态分配和静态分配。栈区的地址分配是高地址指向低地址栈区主要存储函数的实参和局部变量。静态分配是由编译器完成，动态分配是由malloc函数来完成。栈区的内存释放由系统完成。 堆区：内存的申请和释放由程序员管理。在内存申请时，操作系统会从管理堆区的内存地址的链表中查找未被使用的且足够大的内存。当完成内存分配后会从链表中删除这段内存。将剩余内存的首地址插入到链表中。所以与栈区对比堆区的内存具有碎片化的特性。堆内存的释放有程序员完成，如果程序员未完成内存释放，在程序结束后系统将自动释放这段内存。 静态（全局区）：全局变量和静态变量的存放位置，初始化的静态变量和初始化的全局变量存放在.data段（数据段）。未初始化的放在。bss段系统管理内存的释放。 代码区：存放函数的二进制代码 文字常量区：存放字符串常量 栈区-&gt;堆区-&gt;静态全局区-&gt;文字常量区-&gt;代码区高地址&lt;——————————————————————————&gt;低地址 问题补充：当发起内存申请，系统会如何响应？栈：当每一个函数执行的时候，都会向系统索要资源，函数的运行时发生在栈区的。栈区内存是静态分配和动态分配两种。随着函数的运行而分配内存，随着函数的运行而释放内存。注意：在内存申请过程中，如果剩余的内存空间大于申请的内存空间，系统将为城西分配足够大的内存，如果则表示栈内存不够（栈溢出） 堆：堆区的内存管理由程序员负责，在申请内存过程中，系统维护着一张空闲内存的链表。当申请内存时，系统会遍历空闲内存链表，然后找到第一个大于申请内存空间的内存首地址返回。当然申请的内存不可能正好等于分配的内存空间。所以系统会将剩余的内存空间又存到链表当中，这也是为什么堆区的内存会产生碎片化的原因。 二：内存问题举例例1:char *p = &quot;hello world1&quot;; char a[] = &quot;hello world2&quot;; //p[2] = &#39;a&#39;; a[2] = &#39;a&#39;; char *p1 = &quot;hello world1&quot;; printf(&quot;%p\\n,%p\\n,%p\\n&quot;,p,a,p1); printf(&quot;%c\\n&quot;,a[2]); 分析:这个程序是错误的,错误发生在p[2] = ‘a’ 首先变量数组a和变量p都存储于栈区(任何临时变量都是处于栈区) 但是hello world1和hello world2存储于不同区域 数据hello world2存储于数组当中,此数据存储于栈区,对它修改是没有任何问题的.但是指针变量p仅仅你能够保存某个存储单元的地址.也就是真正存储hello world1的内存地址.因为hello world1属于字符串常量所以存储于静态区.虽然通过p[2]可以访问到静态区,但是作为常量不可被修改.所以导致内存问题.指针p1和p保存的内存地址相等,因为数据区只会保留一份相同的数据. 三、堆区、栈区和静态存储区的使用规则 【规则1】用malloc 或new 申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL 的内存。 【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 【规则4】动态内存的申请与释放必须配对，防止内存泄漏。 【规则5】用free 或delete 释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"内存分区","slug":"内存分区","permalink":"http://yoursite.com/tags/内存分区/"},{"name":"内存问题","slug":"内存问题","permalink":"http://yoursite.com/tags/内存问题/"},{"name":"内存使用规则","slug":"内存使用规则","permalink":"http://yoursite.com/tags/内存使用规则/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"多线程","slug":"多线程","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T02:59:17.107Z","comments":false,"path":"2018/10/12/多线程/","link":"","permalink":"http://yoursite.com/2018/10/12/多线程/","excerpt":"","text":"多线程1.你理解的多线程：2.多线程的多种实现方式：3.你更倾向使用哪种？ pthread （C）pthread是一套基于c语言的多线程解决方案。使用与多个平台，linux，unix，windows。是一套跨平台的多线程解决方案。但是由于使用难度，在开发过程中很少使用到。 NSThread (OC)NSThread是苹果开发的一种多线程解决方案，基于面向对象的思想，使用OC语言开发。使用难度小。但唯一的不足就是程序员必须管理线程的生命周期。 GCD (C)GCD旨在减少程序员管理内存问题。有点事API清晰简单，使用起来简单顺手。而且线程由线程池管理。使得程序员只需要关注提交到线程中的任务。 NSOperation (OC)NSOperation是基于GCD封装的一套API。使用面向对象的设计原则，比GCD多了一些简单使用的功能，暂停，取消等，使用起来更加方便.生命周期也是系统管理。 多线程原理在单核处理器时代，我们所说的多线程技术就是CPU在线程之间来回切换。1.提交多个任务，为每个任务开辟线程和获取资源。2.CPU首先执行任务a，执行一段时间后，记录任务a，然后去执行任务b，执行一段时间后，又去执行任务c。最后又去执行任务a。在多个任务键来回切换。3。如果CPU的切换足够快，我们就会看到多线程并发的假象。 总结：开辟的线程越多，CPU的工作量就越大，耗费的系统资源就越多，每个任务被执行的时间效率降低。 多线程的优点：1.能够充分利用系统资源的使用效率。2.提高程序的执行效率 请说出你最优的选择首先我们应该排除Pthread和NSthread，使用难度和线程生命周期管理的原因。（他们只能作为备胎，而不能作为首选） GCD 它的使用更加轻量，API简单，但是功能没有NSOperation完备。程序员只关注向block中提交任务。但是想暂停和取消任务就比较难。而且设置线程依赖也要写非常多的代码。所以对于功能简单和任务明确的小项目适合使用GCD。 NSOperation 是对GCD的一套抽象封装。增加了不少的功能。而且开发者还可以继承NSOperation完成自己特质的需求。通过NSOperationQueue可以快捷方便的设置线程依赖关系。支持取消，暂停等功能。还可以设置线程的优先级。适合复杂功能和项目的开发。 同步与异步,串行与并发同步和异步:决定是否开辟新的线程 串行和并发:决定是否同时执行任务 同步:不会开辟新的线程,异步会开辟新的线程 并发:会同时执行多个任务 串行:每次执行一个任务,先进先出 优秀博文篇多线程基础 并发编程：API及挑战 并发编程 总结当前开发中多线程的使用和理解非常重要。但是在并发编程中会遇到各种问题，例如优先级翻转、死锁、线程竞争资源等。所以我们应该在并发编程中考虑周全，并需要完成大量的测试。保证系统资源的正常使用。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"Pthread","slug":"Pthread","permalink":"http://yoursite.com/tags/Pthread/"},{"name":"NSThread","slug":"NSThread","permalink":"http://yoursite.com/tags/NSThread/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"},{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"},{"name":"多线程原理","slug":"多线程原理","permalink":"http://yoursite.com/tags/多线程原理/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"红海行动","slug":"红海行动","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T02:59:45.903Z","comments":false,"path":"2018/10/12/红海行动/","link":"","permalink":"http://yoursite.com/2018/10/12/红海行动/","excerpt":"","text":"作为一名开发者，我喜欢红海行动中的一段话。我经历了无数次的训练和演习，从来没有像这样害怕过。喜欢这句的原因在于，没有实战的特种兵也不是像他们口号意向“强者无敌”。在开发的过程中我们可能做过无数的练习和实践，但是真正的实战并不是这样的。因为在特定的环境下，一切的训练都会显得不够。在战争面前，训练只是增强了自救的能力，但是畏惧和信心还是需要经过实战来锻炼的。 作为一名观众，我喜欢红海行动。","categories":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/categories/日志/"}],"tags":[],"keywords":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/categories/日志/"}]},{"title":"面试总结","slug":"面试总结","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:00:15.902Z","comments":false,"path":"2018/10/12/面试总结/","link":"","permalink":"http://yoursite.com/2018/10/12/面试总结/","excerpt":"","text":"对于最近面试的总结1.首先面试最近还是蛮多的,而且都还聊的不错. 2.各个公司的面试方向都有所不同主要是业务和产品不同针对的方向不同,首先是某地产公司的金融产品面试,主要从面向对象编程的思想作为出发点,从单个页面到整体思路让我以面向对象的思想做出分析.还有就是对于数据量较多的处理和数据库的知识.再接着就是产品制作和服务企业,因为这个企业的产品用户较多,所以涉及安全方面的问题较多,比如代码方面的安全,个人用户信息的安全等方面.再接着是一家金融产品公司,主要针对方向是基础知识和一些新技术的发展方向和了几情况.对于产品的优化问题是如何提现的.其他的也就是类似的这种.针对企业目前或者是未来的产品做出提问.剩下的就是我们的基本功.如果基本功扎实的话,可以多了解公司. 3.目前面试了很多家发现自己的不足就是说的时候,表达的不够清楚,感觉好像是这么回事有感觉不像这么回事.其实应该仔细考虑提问并花时间考虑回答.因为面试时间较短所以反应能力和表达能力很重要(需要加强) 4.对于基础知识方面:只要是用过的做过的都能说个差不多,但是就怕没用过的.所以发现自己的知识面的横向拓展还有待提高 总结:生活就是这样,亦步亦趋.在面试和生活中找寻不足,然后面对不足做出回应,然后使自己更加完善.","categories":[{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/categories/面试总结/"}],"tags":[],"keywords":[{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/categories/面试总结/"}]},{"title":"React(三)","slug":"React第三课","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:14:43.812Z","comments":false,"path":"2018/10/12/React第三课/","link":"","permalink":"http://yoursite.com/2018/10/12/React第三课/","excerpt":"","text":"函数组件和类定义组件组件:在react和react-native中通常会把可复用的部件封装起来,构建成一个单独的组件.组件从概念上看上去就像一个函数,他可以接收任意输入的值称之为(props)属性.并返回一个需要在页面上显示的React元素 函数定义组件 123456789function Student(props) &#123; return &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 上面的函数就是一个有效的React组件,它接收一个props的对象参数,并返回一个有效的React元素.我们称之为函数定义组件 类定义组件 12345678910111213class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;Student name = &quot;weiqi&quot;/&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 看到Class这个关键字,我们很清楚的知道这个是一个类,不论是在java,oc,还是swift他都指代一个类.所以我们通过创建一个类来完成定义在类的render()函数中返回一个React元素,然后将元素添加到界面上显示.在render函数中我们看到了this.props.name,this代表是这个类本身.而props是这个类的属性,那么是具体属性的名称. 以一个上边为图片下边为文字的button来用oc的语言特征进行解释解释(强行扯上关系):比如封装一个上图下文的button 函数形式: 我们可以通过在需要用到的地方以函数的形式构建,然后通过函数返回值返回需要的结果,添加到页面上显示代码在这里就不写了,没什么技术含量. 类形式 创建一个继承自UIbutton的子类,然后在init方法中构建自己需要的页面样式.在需要使用的地方初始化,加载. 上面我举的是一个很微不足道的例子,只是为了做解释说明,方便大家记忆理解,同时也是为了方便我记忆理解.可能让你单独记忆这个概念,可能记不住,但是你一旦把他和你的生活上经常干的事扯上关系,那就不算记忆,只是做一些扩展而已.就变得简单多了. 组件渲染从上面的函数定义组件分析组件渲染: 组件 元素调用的ReactDom的render函数 React将{name:”vicky”}作为Student的props传递给了Student组件 在Student组件将函数结果返回. ReactDom将Dom更新为组件返回的结果 介绍俩个概念: Dom标签:我们前面使用过的在ReactDom.render函数中直接使用的标签,作为React的元素 自定义组件:通过函数或类来自定义的组件 组合组件1234567891011121314151617181920212223class Student extends React.Component &#123; render() &#123; return &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Student name = &quot;vicky&quot;/&gt; &lt;Student name = &quot;张三&quot;/&gt; &lt;Student name = &quot;李四&quot;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;span&gt; &lt;App /&gt; &lt;/span&gt;, document.getElementById(&apos;root&apos;)); 理解:就是在一个组件内部可已使用另外的一个组件.工程中中就是在一个自定义的子视图中使用另外的一个自定义子视图控件 重点:一个新的React程序的顶部一般都是App组件,如果要讲React集成到现有的应用程序中,则可以从下而上使用小组件作为开始,然后逐渐向顶层扩展. 警告:组件的返回值只能有一个根元素. 提取组件123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 看到上面的代码有什么感受,好多div啊,而且嵌套了好多层啊.现在让我们一起讲上面的代码进行提取组件,然后使代码变得清晰. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Avatar(props) &#123; return ( &lt;img className=&quot;Avatar&quot; src=&#123;props.author.url&#125; alt=&#123;props.author.name&#125; /&gt; )&#125;;function UserInfo(props) &#123; return ( &lt;div className=&quot;UserInfU&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; )&#125;;function CommentText(props) &#123; return ( &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; )&#125;;function CommentDate(props) &#123; return ( &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; )&#125;;function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user = &#123;props.author&#125; /&gt; &lt;UserInfo user = &#123;props.author&#125;/&gt; &lt;/div&gt; &lt;CommentText text = &#123;props.text&#125;/&gt; &lt;CommentDate date = &#123;props.date&#125;/&gt; &lt;/div&gt; );&#125;; 拆解之后有什么好处: 1.代码的可读性较高 2.拆解出来的组件可以进行复用 3.可以分别拆解到不同的文件,减少单独文件的代码量 props属性和只读属性123function sum(a,b) &#123; return a + b;&#125; 这个函数并没有修改输入值得本身,当传入值相同时结果是相同的这种函数较重纯函数 123function withdraw(account, amount) &#123; account.total -= amount;&#125; 这个函数对它自身输入的值进行了-=操作,输入值本身发生了变化. ##重点:所有的React组件必须(必须)(必须)像纯函数那样使用它们的props 类的定义初级类定义:刚开始学就这样了,后面学习到了慢慢改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先引入React和PropTypesimport React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;//开始定义Student类class Student extends React.Component &#123; render() &#123; const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt; name:&#123;name&#125; &lt;/h1&gt; &lt;h1&gt; age: &#123;age&#125; &lt;/h1&gt; &lt;h1&gt; star:&#123;star&#125; &lt;/h1&gt; &lt;h1&gt; sex:&#123;sex&#125; &lt;/h1&gt; &lt;h1&gt; phone: &#123;phone&#125; &lt;/h1&gt; &lt;h1&gt; account:&#123;account&#125; &lt;/h1&gt; &lt;img src= &#123;headImage&#125;/&gt; &lt;/div&gt; ) &#125;&#125;//到底我们需要哪些属性啦?按需求来定Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125;//检查数据类型,如果数据类型不匹配会进行报错提醒Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125;//export default Student; 然后在index.js引入文件并渲染组件 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&quot;56&quot; star=&quot;白羊&quot; sex=&quot;2&quot; phone=&quot;122222222&quot; account=&quot;2222222&quot; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 然后运行发现报错了报错大概是这样的 export default was not found ./Stundet到底什么意思啦就是在类定义组件并且分文件之后要将自己暴露出来,在类定义的最后一行引入这行代码 1export default Student; 然后在运行发现还有报错:这次就不展示什么报错了,就是类型检查报错,因为我们声明了很多属性的类型为number类型,但是我们用string赋值肯定会报错的. 修改完后的代码 12345ReactDOM.render( &lt;Student name=&quot;李四&quot; age=&#123;56&#125; star=&quot;白羊&quot; sex=&#123;2&#125; phone=&#123;122222222&#125; account=&#123;2222222&#125; headImag=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;, document.getElementById(&apos;root&apos;)) 报错是消失了,但是图片和名字还是没有显示,原来是属性名写错了,sorry低级失误. 添加属性的方法 可以再使用组件时直接添加,例如,然后在组件内部return是用this.props.name来获取属性值 添加属性默认值 12345678910Student.defaultProps = &#123; name: &quot;vicky&quot;, age: 25, star: &quot;摩羯座&quot;, sex: 1, //1:男性,2:女性,3:未知 phone: 119110120, account: 513961360, headImage:&quot;https://www.baidu.com/img/bd_logo1.png&quot;,&#125; 检查数据类型,如果数据类型不匹配会进行报错提醒 123456789Student.propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired, star: PropTypes.string.isRequired, sex: PropTypes.number.isRequired, phone: PropTypes.number.isRequired, account: PropTypes.number.isRequired, headImage: PropTypes.string.isRequired&#125; render函数的使用属性的多种方法,常见的就是this.props.name这种,还有在一些人的代码中经常会看到这样的代码 1234567891011const &#123; name, age, star, sex, phone, account, headImage &#125; = this.props; 简化赋值操作.","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[],"keywords":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}]},{"title":"iOS内存分析(一)","slug":"iOS内存管理","date":"2018-10-12T02:22:10.000Z","updated":"2018-10-12T03:42:44.032Z","comments":false,"path":"2018/10/12/iOS内存管理/","link":"","permalink":"http://yoursite.com/2018/10/12/iOS内存管理/","excerpt":"","text":"自动引用计数1.1 什么是自动引用计数自动引用计数就是指在内存管理上不需要程序员再次键入retain和release等内存管理语句.而是由系统自动对引用进行计数 目前我们所创建的项目都是ARC的,它不仅减少了程序员的开发工作,而且也降低了程序的崩溃,内存泄漏等风险. 1.2内存管理/引用计数1.2.1 概要书中的举例非常经典,利用办公室开关灯的实际情况对内存管理进行了详细的分析. 当第一个人进入办公室时需要照明,所以开灯 (引用计数1) 当第二个人进入办公室时也需要照明,持有对象 (引用计数2) 当第一个人离开办公室时不需要照明,但是别人还需要照明,所以不能关闭灯,只能释放自己的持有 (引用计数1) 当最后一个人离开时,不需要灯光了,然后关闭灯光,释放自己持有.对象释放 (引用计数0) 1.2.2 内存管理的思考方式 自己生成的对象,自己持有 非自己生成的对象,自己也能持有 不在需要自己持有的对象时,需要自己释放 不能释放自己不持有的对象对象操作Objective-C方法生成并持有对象alloc/new/copy/mutableCopy等持有对象retain释放对象release废弃对象dealloc 自己生成并持有对象 alloc new copy mutableCopy 123456789/** 自己生成并持有对象*/ id obj = [[NSObject alloc] init]; /** 自己持有对象 */ alloc方法生成的对象自己持有(自己生成并持有对象),并将指向生成持有对象的指针赋给了变量obj.new方法与alloc方法完全一致,copy和mutableCopy方法基于NSCopying和NSMutableCopying协议约定,利用copyWithZ one:方法生成并持有对象的副本 alloc的调用过程1.首先调用NSObject的alloc方法 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 2.调用_objc_rootAlloc()函数 12345id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; 3.调用了callAlloc()函数 123456789101112131415161718192021222324252627282930313233343536static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;//判断是否为Nil和cls是否存在,不存在直接返回 if (checkNil &amp;&amp; !cls) return nil;#if __OBJC2__//判断是否自定义实现的allocwithzone方法 if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast&apos;s summary //还需要再次判断当前的class是否支持快速alloc。如果支持，直接调用calloc函数，申请 bits.fastInstanceSize()大小的内存空间，如果创建失败，会调用callBadAllocHandler函数，如 果不支持快速alloc则调用class_createInstance if (cls-&gt;canAllocFast()) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (!obj) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (!obj) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 4.调用allocWithZone 123+ (id)allocWithZone:(struct _NSZone *)zone &#123; return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);&#125; 5.调用_objc_rootAllocWithZone()函数 12345678910111213141516171819202122id_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&#123; id obj;#if __OBJC2__ //如果是oc代码使用class_createInstance() // allocWithZone under __OBJC2__ ignores the zone parameter (void)zone; obj = class_createInstance(cls, 0);#else//如果不存在zone或者是使用了GC使用class_createInstance(),如果不是使用class_createInstanceFromZone() if (!zone || UseGC) &#123; obj = class_createInstance(cls, 0); &#125; else &#123; obj = class_createInstanceFromZone(cls, 0, zone); &#125;#endif if (!obj) obj = callBadAllocHandler(cls); return obj;&#125; 6.调用class_createInstance()函数 12345id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; 7.调用_class_createInstanceFromZone() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123;//cls是否存在 if (!cls) return nil;//判断该类是否已经做过realize，关于realize的详请可以参考这篇和这篇，realize主要是一些数据的拷贝和整理对齐。 assert(cls-&gt;isRealized()); // Read class&apos;s info bits all at once for performance /* 判断是否支持hasCxxCtor 和 hasCxxDtor还有canAllocNonpointer，hasCxxCtor 和 hasCxxDtor是对 Objective-C++ 的支持，表示这个类是否有 C++ 类构造函数和析构函数，如果有的话，需要进行额外的工 作。canAllocNonpointer我们不用太关心，这里OC 2.0以上基本上返回的都是true。 */ bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocIndexed();//计算instance大小 size_t size = cls-&gt;instanceSize(extraBytes); //if outAllocatedSize存在 *outAllocatedSize的大小 = size if (outAllocatedSize) *outAllocatedSize = size; id obj; //如果不是用gc,不存在zone,??? if (!UseGC &amp;&amp; !zone &amp;&amp; fast) &#123; //分配objc内存大小 obj = (id)calloc(1, size); //如果obj不存在,return nil if (!obj) return nil; //初始化ias指针 obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123;#if SUPPORT_GC if (UseGC) &#123; obj = (id)auto_zone_allocate_object(gc_zone, size, AUTO_OBJECT_SCANNED, 0, 1); &#125; else #endif if (zone) &#123; obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; if (!obj) return nil; // Use non-indexed isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125;// 不懂 if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; 我们都知道alloc的作用是开辟足够的内存空间,并初始化isa指针.然后使obj指针指向对象的内存地址 非自己生成的对象,自己也能持有在我们学习OC的时候我们只有对象的生成方法有两种,一种是使用alloc方法,还有一种是使用便利构造器也就是常见的例如: id obj = [NSArray array]; 分析:这个对象是由自己生成,但并非自己持有. +(instancetype)array { __autoreleasing NSArray *array = [[NSArray alloc] init]; return array;} 从上面第一条自己生成并持有.我们可以得到array只是将自己生成并持有对象的指针赋给了array变量.我们拿到的只是这个变量指针. 那么如何取得这个对象的所有权啦??? 然后就用到了retain方法 id obj = [NSArray array]; [obj retain]; 通过retain函数持有非自己生成对象 retain方法调用过程我们通过查询runtime源代码可以找到retain的调用顺序1.首先是NSObject的retain方法 123- (id)retain &#123; return ((id)self)-&gt;rootRetain();&#125; 2.在retain方法内部调用了rootRetain()方法 12345678id_objc_rootRetain(id obj)&#123;//判断当前的obj对象是否为空 assert(obj); return obj-&gt;rootRetain();&#125; 3.调用obj的rootRetain()函数 12345ALWAYS_INLINE id objc_object::rootRetain()&#123; return rootRetain(false, false);&#125; 4.在rootRetain方法内部调用了objc_object::rootRetain(bool tryRetain, bool handleOverflow)方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123;//判断是否为gc环境(垃圾回收,在mac系统上是由垃圾回收机制的,因为mac的内存足够大) assert(!UseGC); //判断是否为TaggedPointer,TaggedPointer是系统的一个优化方案[TaggedPointer](http://blog.devtang.com/2014/05/30/understand-tagged-pointer/) if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; isa_t oldisa; isa_t newisa;//这里没看懂 do &#123; transcribeToSideTable = false; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; if (!newisa.indexed) goto unindexed; // don&apos;t check newisa.fast_rr; we already called any RR overrides if (tryRetain &amp;&amp; newisa.deallocating) goto tryfail; uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ if (carry) &#123; // newisa.extra_rc++ overflowed if (!handleOverflow) return rootRetain_overflow(tryRetain); // Leave half of the retain counts inline and // prepare to copy the other half to the side table. if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock(); sideTableLocked = true; transcribeToSideTable = true; newisa.extra_rc = RC_HALF; newisa.has_sidetable_rc = true; &#125; &#125; while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); if (transcribeToSideTable) &#123; // Copy the other half of the retain counts to the side table. sidetable_addExtraRC_nolock(RC_HALF); &#125; if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return (id)this; tryfail: if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return nil; unindexed: if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); if (tryRetain) return sidetable_tryRetain() ? (id)this : nil; //调用sidetable_retain()函数 else return sidetable_retain();&#125; 5.调用sidetable_retain()函数,首先获取对象的引用技术管理结构体SideTable,在SideTable中有三个重要的成员(spinlock_t slock,RefcountMap refcnts,weak_table_t weak_table).其中引用计数是保存到refcnts.weak_table弱引用表.第一个是一个自旋锁,保证在多线程中操作. 我们再看引用计数每次加SIDE_TABLE_RC_ONE到底是什么东西? 1#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) 这里使用了一个位操作,在二进制下将1向左移动2位,就是100.然后100代表的数字是4.所以实际上retain加的引用计数是4.第一位标识引用计数是否越界,第三位和第三位标识弱引用和析构状态.这个结构也就造成了我们为什么方位引用计数时为什么总是1而不是0. 12345678910111213141516uintptr_tobjc_object::sidetable_retainCount()&#123; SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; table.unlock(); return refcnt_result;&#125; 从上面的代码的代码可以看出refcnt_result+=引用计数总计.而refcnt_result = 1.所以我们访问时都是1而不是0 12345678910111213141516171819202122idobjc_object::sidetable_retain()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif//获取管理引用计数的结构体SideTable SideTable&amp; table = SideTables()[this]; if (table.trylock()) &#123; //获取当前对象的引用计数散列表,使用散列表可以将对象持有者的内存地址和引用计数保存在散列表中.就算在出现异常情况时,也能定位到地址信息 size_t&amp; refcntStorage = table.refcnts[this]; //判断当前的引用计数是否越界 if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; //如果每引用计数没有越界,引用计数加1 refcntStorage += SIDE_TABLE_RC_ONE; &#125; table.unlock(); return (id)this; &#125; return sidetable_retain_slow(table);&#125; 6.调用sidetable_retain_slow()函数 12345678910111213141516idobjc_object::sidetable_retain_slow(SideTable&amp; table)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif table.lock(); size_t&amp; refcntStorage = table.refcnts[this]; if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; refcntStorage += SIDE_TABLE_RC_ONE; &#125; table.unlock(); return (id)this;&#125; 上述代码也是引用计数进行加一的一个函数 上面的所有的过程就是在我们调用retain的函数调用过程.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"引用计数","slug":"引用计数","permalink":"http://yoursite.com/tags/引用计数/"},{"name":"alloc/new/copy/mutableCopy","slug":"alloc-new-copy-mutableCopy","permalink":"http://yoursite.com/tags/alloc-new-copy-mutableCopy/"},{"name":"retain","slug":"retain","permalink":"http://yoursite.com/tags/retain/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]}]}