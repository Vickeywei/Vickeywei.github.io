<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vicky的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-15T08:17:48.724Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Vicky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rxswift学习(一)</title>
    <link href="http://yoursite.com/2018/10/12/rxswift%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/10/12/rxswift学习/</id>
    <published>2018-10-12T06:49:10.000Z</published>
    <updated>2018-10-15T08:17:48.724Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>HomeBrew VS Wegt</title>
    <link href="http://yoursite.com/2018/10/12/HomeBrew%E4%B8%8ERuby%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/10/12/HomeBrew与Ruby更新/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:05:33.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HomeBrew-与-wegt"><a href="#HomeBrew-与-wegt" class="headerlink" title="HomeBrew 与 wegt"></a>HomeBrew 与 wegt</h1><p>HomeBrew 是一款自由及开放源代码的软件包管理系统,用以简化Mac OS X系统上的软件安装过程.它使用Ruby语言写成,针对Mac OS X操作系统自带的Ruby版本,默认安装在/usr/local下.由一个核心的git版本库构成,以使用户能更新HomeBrew.包管理器使用一种称为”公式”的DSL脚本来管理依赖,下载源代码及配置和编译软件,从源代码中构建软件</p><p>安装需求</p><p>Xcode</p><p>安装方式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></span><br></pre></td></tr></table></figure><p>相关指令</p><p>搜索:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search 套件名称</span><br></pre></td></tr></table></figure><p>查询套件信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info 套件名称</span><br></pre></td></tr></table></figure><p>安装套件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install 套件名称</span><br></pre></td></tr></table></figure><p>查询目前已经安装的套件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list</span><br></pre></td></tr></table></figure><p>更新HomeBrew</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><p>卸载HomeBrew</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd <span class="string">`brew --prefix`</span></span><br><span class="line">$ rm -rf Cellar$ brew prune</span><br><span class="line">$ rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew</span><br><span class="line">$ rm -rf ~<span class="regexp">/Library/</span>Caches/Homebrew</span><br></pre></td></tr></table></figure><p>wegt 是linux的一个命令用来下载文件的工具<br>我只有在虚拟机上使用过这个命令,主要作用是用来下载文件.比如说做后台的同学想下载tomcat,就可以通过这个来下载,过多的内容接不介绍了</p><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><p>Mac OS X 系统自带了ruby环境,所以我们一般是不需要管理ruby环境的,今天说这个问题是在过年期间我在更新mac系统时出错了缺少系统启动文件,然后我就恢复系统了,知道今天才发现我pod install执行不了,提示ruby的版本过低,而我的pod版本是最新版,所以我就想通过更新ruby来解决问题,但是更新ruby时又发现brew出错了.所以很生气,后果很严重.下载brew,更新ruby,pod就好了<br>卸载和安装上面都有讲述.更新ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade ruby</span><br></pre></td></tr></table></figure><h1 id="Cocoapods"><a href="#Cocoapods" class="headerlink" title="Cocoapods"></a>Cocoapods</h1><p>对于iOS开发的同学,使用cocoapods是在所难免的,所以不再过多讲述,网上的文章一搜一大堆.<br><a href="https://www.jianshu.com/p/edd9dbd35576" target="_blank" rel="noopener">pod入门到放弃</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HomeBrew-与-wegt&quot;&gt;&lt;a href=&quot;#HomeBrew-与-wegt&quot; class=&quot;headerlink&quot; title=&quot;HomeBrew 与 wegt&quot;&gt;&lt;/a&gt;HomeBrew 与 wegt&lt;/h1&gt;&lt;p&gt;HomeBrew 是一款自由及开放源
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="HomeBrew" scheme="http://yoursite.com/tags/HomeBrew/"/>
    
      <category term="wegt" scheme="http://yoursite.com/tags/wegt/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存管理(二)</title>
    <link href="http://yoursite.com/2018/10/12/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/"/>
    <id>http://yoursite.com/2018/10/12/iOS内存管理-1/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-17T02:35:06.913Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.vicky.org.cn/2018/10/12/iOS内存管理/" target="_blank" rel="noopener">iOS内存管理(一)</a></p><p>##2.1 release</p><h3 id="2-1-1-release的作用"><a href="#2-1-1-release的作用" class="headerlink" title="2.1.1 release的作用"></a>2.1.1 release的作用</h3><p>我们都知道release的作用是引用计数-1.当我们不需要持有对象的引用时需要进行release.</p><h3 id="2-1-2-release的调用过程"><a href="#2-1-2-release的调用过程" class="headerlink" title="2.1.2 release的调用过程"></a>2.1.2 release的调用过程</h3><ol><li>首先调用对象的release方法</li><li>在release方法中调用rootRelease(),在rootRelease()中断言是否使用的GC,判断是否是<b style="color:blue">TaggedPointer</b>,如果是返回false,否则调用sidetable_release(true)</li><li>在sidetable_release()方法中首先获取对象保存引用计数的数据结构SideTable,定义局部变量do_dealloc是否进行dealloc.然后SideTable开锁.然后获取到对象的引用计数散列表.如果引用计数值==table.refcnts.end(). do_dealloc = true,将对象的引用计数标识为SIDE_TABLE_DEALLOCATING.如果不等于end.判断it-&gt;second  &lt; 小于SIDE_TABLE_DEALLOCATING(判断引用计数是否为0),do_dealloc = true,it-&gt;second = it-&gt;second | SIDE_TABLE_DEALLOCATING.然后如果it-&gt;second &amp; SIDE_TABLE_RC_PINNED(溢出标识).引用计数-1.如果do_dealloc和performDealloc都为true调用dealloc方法.否则调用sidetable_release_slow()</li><li>sidetable_release_slow()的内部实现和sidetable_release大致类似.</li></ol><p><b style="color : red">欠缺点:</b></p><p><b style="color : red">??? it-&gt;second是什么?</b></p><p><b style="color : red">??? 按位与和按位或</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (oneway void)release &#123;</span><br><span class="line">    ((id)self)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);</span><br><span class="line"></span><br><span class="line">    if (isTaggedPointer()) return false;</span><br><span class="line">    return sidetable_release(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uintptr_t </span><br><span class="line">objc_object::sidetable_release(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.indexed);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    bool do_dealloc = false;</span><br><span class="line"></span><br><span class="line">    if (table.trylock()) &#123;</span><br><span class="line">        RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">        if (it == table.refcnts.end()) &#123;</span><br><span class="line">            do_dealloc = true;</span><br><span class="line">            table.refcnts[this] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">        &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">            // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it.</span><br><span class="line">            do_dealloc = true;</span><br><span class="line">            it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">        &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">            it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">        &#125;</span><br><span class="line">        table.unlock();</span><br><span class="line">        if (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        return do_dealloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sidetable_release_slow(table, performDealloc);</span><br><span class="line">&#125;</span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release_slow(SideTable&amp; table, bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.indexed);</span><br><span class="line">#endif</span><br><span class="line">    bool do_dealloc = false;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it == table.refcnts.end()) &#123;</span><br><span class="line">        do_dealloc = true;</span><br><span class="line">        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it.</span><br><span class="line">        do_dealloc = true;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    if (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-autorelease"><a href="#2-2-autorelease" class="headerlink" title="2.2 autorelease"></a>2.2 autorelease</h2><h3 id="2-2-1-autorelease的作用"><a href="#2-2-1-autorelease的作用" class="headerlink" title="2.2.1 autorelease的作用"></a>2.2.1 autorelease的作用</h3><p>autorelease的目的是为了让内存能够延迟释放.那么到底它的释放时机什么时候?那么我们先看autorelease的调用过程</p><ol><li>调用NSObject的autorelease方法</li><li>调用rootAutorelease()方法.在方法内部首先断言是否使用GC,然后就会判断对象是否为<b style="color:blue">TaggedPointer</b>如果是返回当前对象本身,继续判断prepareOptimizedReturn(ReturnAtPlus1),如果为true,返回当前对象,否则调用rootAutorelease2()</li><li>在rootAutorelease2()方法中首先判断是否为<b style="color:blue">TaggedPointer</b>.然后调用AutoreleasePoolPage::autorelease((id)this)</li><li>在AutoreleasePoolPage::autorelease((id)this)方法中首先断言对象obj是否存在,在判断是否为<b style="color:blue">TaggedPointer</b>.然后会定义一个id类型的变量接受autoreleaseFast(obj)的返回值.在autoreleaseFast(obj)方法中首先获取AutoreleasePoolPage对象.如果page存在并且page没有被塞满,就将obj对象加到page中.否则page存在,但是page已经塞满会重新new一个page,然后在添加进去.如果没有page就回调用autoreleaseNoPage,也会new一个然后把obj添加进去.然后返回对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">1.- (id)autorelease &#123;</span><br><span class="line">    return ((id)self)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);</span><br><span class="line"></span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">3.id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line">4.static inline id autorelease(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(obj);</span><br><span class="line">        assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">        assert(!dest  ||  *dest == obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"> 5. static inline id *autoreleaseFast(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">            return page-&gt;add(obj);</span><br><span class="line">        &#125; else if (page) &#123;</span><br><span class="line">            return autoreleaseFullPage(obj, page);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return autoreleaseNoPage(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  6.static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">    &#123;</span><br><span class="line">        // The hot page is full. </span><br><span class="line">        // Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">        // Then add the object to that page.</span><br><span class="line">        assert(page == hotPage());</span><br><span class="line">        assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">            else page = new AutoreleasePoolPage(page);</span><br><span class="line">        &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">        setHotPage(page);</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNoPage(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        // No pool in place.</span><br><span class="line">        assert(!hotPage());</span><br><span class="line"></span><br><span class="line">        if (obj != POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">            // We are pushing an object with no pool in place, </span><br><span class="line">            // and no-pool debugging was requested by environment.</span><br><span class="line">            _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                         &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                         &quot;just leaking - break on &quot;</span><br><span class="line">                         &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                         (void*)obj, object_getClassName(obj));</span><br><span class="line">            objc_autoreleaseNoPool(obj);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Install the first page.</span><br><span class="line">        AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">        setHotPage(page);</span><br><span class="line"></span><br><span class="line">        // Push an autorelease pool boundary if it wasn&apos;t already requested.</span><br><span class="line">        if (obj != POOL_SENTINEL) &#123;</span><br><span class="line">            page-&gt;add(POOL_SENTINEL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Push the requested object.</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就完成了将一个对象的延迟释放.但是autorelease的对象什么时机会释放啦.我们的猜想肯定是和AutoreleasePoolPage有关.我们看class AutoreleasePoolPage 的代码会发现,它有push和pop方法.释放肯定和pop有关,push肯定和入栈有关.<br>我们先看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">    static inline void pop(void *token) </span><br><span class="line">    &#123;</span><br><span class="line">    //定义局部变量AutoreleasePoolPage *page</span><br><span class="line">        AutoreleasePoolPage *page;</span><br><span class="line">        //定义stop变量</span><br><span class="line">        id *stop;</span><br><span class="line">        //根据token获取page</span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">        //然后将token赋值给stop</span><br><span class="line">        stop = (id *)token;</span><br><span class="line">        DebugPoolAllocation:halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools大致的意思就是当自动释放池出现故障或停止时,允许堆调试器跟踪自动释放池</span><br><span class="line">        *stop != POOL_SENTINEL : stop不为nil</span><br><span class="line">        无效的自动释放池</span><br><span class="line">        </span><br><span class="line">        if (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">            // This check is not valid with DebugPoolAllocation off</span><br><span class="line">            // after an autorelease with a pool page but no pool in place.</span><br><span class="line">            _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, </span><br><span class="line">                        token);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果自动释放池的高位置标记存在,就打印高位置标记</span><br><span class="line">        if (PrintPoolHiwat) printHiwat();</span><br><span class="line">        </span><br><span class="line">        //page调用releaseUntil()方法</span><br><span class="line">        page-&gt;releaseUntil(stop);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">      void releaseUntil(id *stop) </span><br><span class="line">    &#123;</span><br><span class="line">        // Not recursive: we don&apos;t want to blow out the stack </span><br><span class="line">        // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">        //当page-&gt;next = stop时停止,否则进行循环</span><br><span class="line">        while (this-&gt;next != stop) &#123;</span><br><span class="line">            // Restart from hotPage() every time, in case -release </span><br><span class="line">            // autoreleased more objects</span><br><span class="line">            //获取AutoreleasePoolPage</span><br><span class="line">            AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">            // fixme I think this `while` can be `if`, but I can&apos;t prove it</span><br><span class="line">            while循环如果page为空,就找parent,然后赋值给page.当page不为空时停止循环</span><br><span class="line">            </span><br><span class="line">            while (page-&gt;empty()) &#123;</span><br><span class="line">                page = page-&gt;parent;</span><br><span class="line">                setHotPage(page);</span><br><span class="line">            &#125;</span><br><span class="line">            //修改page的内存区域保护属性 (mprotect()函数可以用来修改一段指定内存区域的保护属性)</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            ??? 从下面的段代码可以看出将obj添加进page时也是通过next的++操作,然后通过--操作可以获取到当前对象.</span><br><span class="line">            /*</span><br><span class="line">             id *add(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!full());</span><br><span class="line">        unprotect();</span><br><span class="line">        id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">        *next++ = obj;</span><br><span class="line">        protect();</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">            */</span><br><span class="line">            id obj = *--page-&gt;next;</span><br><span class="line">            //将page-&gt;next的内存重置为0xA3</span><br><span class="line">            memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">            修改page的内存区域保护属性</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">            //如果obj不为nil,就会release</span><br><span class="line">            if (obj != POOL_SENTINEL) &#123;</span><br><span class="line">            //和上面的release调用过程同</span><br><span class="line">                objc_release(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">        // we expect any children to be completely empty</span><br><span class="line">        for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">            assert(page-&gt;empty());</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        // memory: delete empty children</span><br><span class="line">        if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">            // special case: delete everything during page-per-pool debugging</span><br><span class="line">            AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(parent);</span><br><span class="line">        &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // special case: delete everything for pop(top) </span><br><span class="line">            // when debugging missing autorelease pools</span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125; </span><br><span class="line">        else if (page-&gt;child) &#123;</span><br><span class="line">            // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">            if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">                page-&gt;child-&gt;kill();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">                page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们根据autoreleasePoolPage的pop方法一直向上寻找,终于找到以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">1. loadimages方法</span><br><span class="line"></span><br><span class="line">const char *</span><br><span class="line">load_images(enum dyld_image_states state, uint32_t infoCount,</span><br><span class="line">            const struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    bool found;</span><br><span class="line"></span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    found = false;</span><br><span class="line">    for (uint32_t i = 0; i &lt; infoCount; i++) &#123;</span><br><span class="line">        if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!found) return nil;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    if (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. call_load_methods方法</span><br><span class="line"></span><br><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.objc_autoreleasePoolPop方法</span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4._objc_load_image 也有调用call_load_methods</span><br><span class="line">OBJC_EXPORT void _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class="line">&#123;</span><br><span class="line">    prepare_load_methods(hinfo);</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看到了AutoreleasePoolPage调用了pop方法.而loadiamges方法以前应该也见过,就是在使用method swwizing的时候,重写load方法时,打上断点看到调用栈时看到过,还有就是framework有问题时,程序已启动就会在控制台上显示loadimages报错等.<br>这个不是这个文章的研究重点,只是简单提一下.xnu内核加载mach-o-&gt;从xnu内核态将控制权转移到dyld-&gt;_dyld_start-&gt;加载系统的framework和dylib到内存,然后runtime开始初始化和注册-&gt;当每次有心的镜像加入运行时会回调loadinages</p><p>然后就是在每次runloop进入休眠期时会调用pop和push释放旧的,创建新的,所以在runloop的每次进入休眠时会释放一次.</p><p><b style="color : red">篇幅已经过长,先进入下面的内容,下次再详细介绍runloop的内容和autoreleasepool</b></p><h2 id="2-3-dealloc"><a href="#2-3-dealloc" class="headerlink" title="2.3 dealloc"></a>2.3 dealloc</h2><p>作用:销毁对象</p><h3 id="2-3-1-调用过程"><a href="#2-3-1-调用过程" class="headerlink" title="2.3.1 调用过程"></a>2.3.1 调用过程</h3><ol><li>NSObject的dealloc方法</li><li>_objc_rootDealloc()方法</li><li>调用objc_object::rootDealloc()</li><li>调用object_dispose(id obj)方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">1.dealloc</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line">2. _objc_rootDealloc</span><br><span class="line">void</span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line">3.objc_object::rootDealloc()</span><br><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;</span><br><span class="line">    object_dispose((id)this);</span><br><span class="line">&#125;</span><br><span class="line">4.object_dispose()</span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    </span><br><span class="line">#if SUPPORT_GC</span><br><span class="line">    if (UseGC) &#123;</span><br><span class="line">        auto_zone_retain(gc_zone, obj); // gc free expects rc==1</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        //对象是否有析构函数</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        //对象是否有动态绑定和关联引用</span><br><span class="line">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">        //是否使用gc</span><br><span class="line">        bool dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        //如果存在使用析构函数</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        //如果存在动态属性,移除动态绑定和关联应用</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        //</span><br><span class="line">        if (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-retainCount"><a href="#2-4-retainCount" class="headerlink" title="2.4 retainCount"></a>2.4 retainCount</h2><p>作用:查看对象的引用计数</p><h3 id="2-4-1-调用"><a href="#2-4-1-调用" class="headerlink" title="2.4.1 调用"></a>2.4.1 调用</h3><ol><li>retainCount</li><li>rootRetainCount</li><li>sidetable_retainCount()</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. retainCount</span><br><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return ((id)self)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line">2. rootRetainCount</span><br><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);</span><br><span class="line"></span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br><span class="line">3.sidetable_retainCount</span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">//获取对象保存引用计数的数据结构</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    //定义局部变量refcnt_result</span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    //获取对象的引用计数表</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    //如果引用计数 != end(引用计数散列表未填充满)</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        // this is valid for SIDE_TABLE_RC_PINNED too</span><br><span class="line">        然后引用计数 = </span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.vicky.org.cn/2018/10/12/iOS内存管理/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS内存管理(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##2.1 release&lt;/p&gt;
&lt;h3 id=&quot;2-1
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="release" scheme="http://yoursite.com/tags/release/"/>
    
      <category term="autorelease" scheme="http://yoursite.com/tags/autorelease/"/>
    
      <category term="dealloc" scheme="http://yoursite.com/tags/dealloc/"/>
    
      <category term="retainCount" scheme="http://yoursite.com/tags/retainCount/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C视频学习资源</title>
    <link href="http://yoursite.com/2018/10/12/Objective-C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%92%8C%E5%A4%A7%E7%A5%9E%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/10/12/Objective-C学习资源和大神博客/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:13:22.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Objective-C视频学习资源"><a href="#Objective-C视频学习资源" class="headerlink" title="Objective-C视频学习资源"></a>Objective-C视频学习资源</h1><p>因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源又包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。</p><h3 id="视频教程-英文"><a href="#视频教程-英文" class="headerlink" title="视频教程(英文)"></a>视频教程(英文)</h3><ul><li><a href="https://www.lynda.com/search?q=ios" target="_blank" rel="noopener">Lynda</a> Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。</li><li><a href="https://www.udemy.com/courses/development/mobile-apps/learn-objective-c/all-courses/" target="_blank" rel="noopener">Udemy</a> Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。</li></ul><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://www.amazon.com/dp/032194206X/ref=cm_sw_r_tw_dp_fWrPub0BGRHJ3" target="_blank" rel="noopener">Objective-C Programming</a> 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。</li><li><a href="https://book.douban.com/subject/24538384/" target="_blank" rel="noopener">iOS Programming</a> 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论</li><li><a href="https://book.douban.com/subject/3688896/" target="_blank" rel="noopener">Cocoa Design Patterns</a> 适合打算深入了解 Cocoa 的人看</li><li><a href="http://cocoadevcentral.com/d/learn_objectivec/" target="_blank" rel="noopener">Learn Objective-C</a> 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解</li><li><a href="https://www.amazon.cn/dp/B00COG40Y0/ref=cm_sw_r_qz_2_dp_l2OPub0N45R0Q" target="_blank" rel="noopener">Objective-C 基础教程</a> 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读</li><li><a href="https://www.amazon.cn/dp/B00R43XG9S/ref=cm_sw_r_qz_pi_T2A_jdp_fCPPub0VBF67T" target="_blank" rel="noopener">iOS 开发进阶</a> 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读</li><li><a href="https://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321967607" target="_blank" rel="noopener">Programming in Objective-C</a>  Programming in Objective-C   这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细</li><li><a href="https://www.amazon.cn/dp/B00JPVNFKM/ref=cm_sw_r_qz_4_dp_tdPPub14X59PV" target="_blank" rel="noopener">iOS 测试指南</a> 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。</li><li><a href="https://book.douban.com/subject/6920082/" target="_blank" rel="noopener">Objective-C 编程之道</a> 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读</li><li><a href="https://www.amazon.cn/dp/B00DE60G3S/ref=cm_sw_r_qz_2_dp_hdPPub11MFE6G" target="_blank" rel="noopener">Objective-C 高级编程</a> 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读</li><li><a href="https://www.amazon.cn/dp/B00IDSGY06/ref=cm_sw_r_qz_2_dp_A2OPub0CH96YH" target="_blank" rel="noopener">Effective Objective C 2.0</a> 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用</li><li><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html" target="_blank" rel="noopener">The Swift Programming Language 中文版</a> 学习Swift基础的中文文档，目前更新到Swift3.0文档</li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul><li><a href="https://onevcat.com/#blog" target="_blank" rel="noopener">OneV’s Den</a></li><li><a href="http://blog.devtang.com/" target="_blank" rel="noopener">唐巧的技术博客</a></li><li><a href="https://blog.ibireme.com" target="_blank" rel="noopener">ibireme</a></li><li><a href="http://blog.cnbang.net" target="_blank" rel="noopener">bang</a></li><li><a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">孙源的技术博客</a></li><li><a href="http://beyondvincent.com/" target="_blank" rel="noopener">破船之家</a></li><li><a href="http://nshipster.cn/" target="_blank" rel="noopener">NSHipster</a></li><li><a href="http://limboy.me/" target="_blank" rel="noopener">Limboy 无网不剩</a></li><li><a href="http://zhowkev.in/" target="_blank" rel="noopener">Kevin Blog</a></li><li><a href="https://imtx.me/" target="_blank" rel="noopener">IMTX</a></li><li><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></li><li><a href="http://www.iosxxx.com" target="_blank" rel="noopener">向晨宇的技术博客</a></li><li><a href="http://blog.leichunfeng.com" target="_blank" rel="noopener">雷纯锋的技术博客</a></li><li><a href="http://www.tanhao.me" target="_blank" rel="noopener">老谭笔记</a></li><li><a href="http://www.cnblogs.com/kenshincui/" target="_blank" rel="noopener">Kenshin Cui’s Blog</a></li><li><a href="https://casatwy.com" target="_blank" rel="noopener">Casa Taloyum</a></li><li><a href="http://www.olinone.com" target="_blank" rel="noopener">庞海礁的个人空间</a></li><li><a href="http://tutuge.me" target="_blank" rel="noopener">土土哥的技术blog</a></li><li><a href="http://yulingtianxia.com" target="_blank" rel="noopener">玉令天下的博客</a></li><li><a href="http://www.iiiyu.com" target="_blank" rel="noopener">萧宸宇</a></li><li><a href="http://www.cnblogs.com/biosli" target="_blank" rel="noopener">摇滚诗人</a></li><li><a href="http://foggry.com" target="_blank" rel="noopener">王中周的技术博客</a></li><li><a href="https://blog.nswebfrog.com" target="_blank" rel="noopener">Blog | nswebfrog</a></li><li><a href="http://limboy.me" target="_blank" rel="noopener">limboy</a></li></ul><h3 id="社区论坛"><a href="#社区论坛" class="headerlink" title="社区论坛"></a>社区论坛</h3><ul><li><a href="https://objccn.io/" target="_blank" rel="noopener">objc中国</a></li><li><a href="http://www.cocoachina.com/" target="_blank" rel="noopener">cocoachina</a></li><li><a href="https://www.objc.io/" target="_blank" rel="noopener">objc</a></li><li><a href="http://www.code4app.com/" target="_blank" rel="noopener">code4App</a></li><li><a href="http://discuss.cocos2d-x.org/" target="_blank" rel="noopener">Cocos2d-x</a></li><li><a href="http://iphonedevsdk.com/" target="_blank" rel="noopener">iPhone Dev SDK</a></li></ul><h3 id="国内知名程序员开发日报"><a href="#国内知名程序员开发日报" class="headerlink" title="国内知名程序员开发日报"></a>国内知名程序员开发日报</h3><ul><li><a href="https://juejin.im/#/tag/iOS" target="_blank" rel="noopener">掘金</a></li><li><a href="http://geek.csdn.net/" target="_blank" rel="noopener">极客头条</a></li><li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li><li><a href="http://weekly.manong.io/" target="_blank" rel="noopener">码农周刊</a></li><li><a href="http://top.jobbole.com/" target="_blank" rel="noopener">伯乐头条</a></li><li><a href="https://segmentfault.com/" target="_blank" rel="noopener">segmentfault</a></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Objective-C视频学习资源&quot;&gt;&lt;a href=&quot;#Objective-C视频学习资源&quot; class=&quot;headerlink&quot; title=&quot;Objective-C视频学习资源&quot;&gt;&lt;/a&gt;Objective-C视频学习资源&lt;/h1&gt;&lt;p&gt;因为iOS的开发者O
      
    
    </summary>
    
      <category term="资源" scheme="http://yoursite.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C对象的构造模式</title>
    <link href="http://yoursite.com/2018/10/12/Objective-C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/12/Objective-C的对象构造模式/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:46:44.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谈对象的构造模式"><a href="#谈对象的构造模式" class="headerlink" title="谈对象的构造模式"></a>谈对象的构造模式</h1><p>Objective-C语言在创建对象的时候需要先调用alloc,然后实例对象调用init方法完成初始化.</p><h1 id="alloc究竟干了什么"><a href="#alloc究竟干了什么" class="headerlink" title="alloc究竟干了什么"></a>alloc究竟干了什么</h1><p>为了能够看到alloc到底干了什么,我们可以下载GNUStep开源的libs-base工程然后找到NSObject.m文件.<br>为什么用GNUStep来查看源码?</p><p>GNUstep，GNU计划的项目之一。它将Cocoa（前身为NeXT的OpenStep）Objective-C软件库，部件工具箱（widget toolkits）以及其上的应用软件，以自由软件方式重新实现。它能够运行在类Unix操作系统上，也能运作在Microsoft Windows上。<a href="https://zh.wikipedia.org/wiki/GNUstep" target="_blank" rel="noopener">GNUStep</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (id) alloc</span><br><span class="line">&#123;</span><br><span class="line">  return [self allocWithZone: NSDefaultMallocZone()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它调用了allocWithZone方法,具体作用就是给当前创建的实例对象开辟内存空间.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSZone*</span><br><span class="line">NSDefaultMallocZone (void)</span><br><span class="line">&#123;</span><br><span class="line">  return &amp;default_zone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道oc对象的本质其实就是结构体,在开辟内存空间函数内部,他会遍历当前结构体的所有成员变量,然后根据成员变量的数据类型计算内存大小.</p><p>当alloc函数调用完成后会返回一个未初始化的实例,在这里cocoa不仅为这个实例申请了足够大的内存空间还做了以下几件事:<br>1.将该对象的引用计数加1<br>2.将该对象的isa指针指向类<br>3.为成员变量初始化值nil/0</p><h1 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h1><p>init方法是该对象的初始化方法,目的是初始化该对象的成员变量.</p><h1 id="new方法"><a href="#new方法" class="headerlink" title="new方法"></a>new方法</h1><p>类方法new的出现是苹果对java等程序员的照顾,而new方法的内部和调用alloc、init是一致的。可以从GNUStep的源代码中得出结论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (id) new</span><br><span class="line">&#123;</span><br><span class="line">  return [[self alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>alloc和init的定位不同：</p><p><strong>alloc旨在为实例对象在虚拟内存上申请足够大的内存空间。而且将对象的retainCount+1.帮助系统完成内存管理。将isa指针指向该类，是为了在运行时环境中完成对该类的检查。</strong></p><p><strong>init方法旨在完成该对象成员变量的初始化。在内存方面并没有什么处理。</strong></p><p>这样设计的结果可以使苹果开发者更加清晰的了解这两个函数的作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;谈对象的构造模式&quot;&gt;&lt;a href=&quot;#谈对象的构造模式&quot; class=&quot;headerlink&quot; title=&quot;谈对象的构造模式&quot;&gt;&lt;/a&gt;谈对象的构造模式&lt;/h1&gt;&lt;p&gt;Objective-C语言在创建对象的时候需要先调用alloc,然后实例对象调用init方法
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="alloc" scheme="http://yoursite.com/tags/alloc/"/>
    
      <category term="构造模式" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="init" scheme="http://yoursite.com/tags/init/"/>
    
      <category term="设计原则" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="new" scheme="http://yoursite.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>React(二)</title>
    <link href="http://yoursite.com/2018/10/12/React%E7%AC%AC%E4%BA%8C%E8%AF%BE/"/>
    <id>http://yoursite.com/2018/10/12/React第二课/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:14:12.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染:"></a>元素渲染:</h2><p>元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器的数据内容和React的保持一致</p><p>浏览器中的Dom元素:</p><p>元素和组件:元素是组件的一个组成部分,而组件更加广义,在下一课中我们一起学习组件</p><p>元素举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;hello world!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="将元素渲染到Dom中"><a href="#将元素渲染到Dom中" class="headerlink" title="将元素渲染到Dom中"></a>将元素渲染到Dom中</h2><p>在学习完元素之后,我们应该如何将元素显示并渲染到界面上就是这个问题所要研究的内容.<br>大家是否还记得在创建完项目后,我们打开看过index.html的源码在body中有一行这样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id= &quot;root&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果还没有回忆起来那就打开项目看一下,而且在上一课中我按照我的理解已经解释过为什么屏幕上会出现hello world!的原理.这里在说一次<br>在index.js的代码中又这样几行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;hello world!&lt;/h1&gt;</span><br><span class="line">ReactDom.render(</span><br><span class="line">element,</span><br><span class="line">document.getElementById(&apos;root&apos;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也就是说在这个div中的所有内容将有ReactDom来管理,render只是一个渲染函数,这个div也被称为根Dom节点.做过手机App开发的也可以这样理解他就是父视图,后续所有的元素和子视图都是在他上面添加和渲染的.<br>我们会将我们需要渲染的内容通过id获取到根dom节点,然后将其填充到根dom节点中,渲染到页面上.这一切的操作都是由ReactDom来完成的.</p><h2 id="更新Dom元素"><a href="#更新Dom元素" class="headerlink" title="更新Dom元素"></a>更新Dom元素</h2><p>重点:React元素都是不可变的,做过App的都知道不可变的类型有很多在iOS 中常见的NSString,NSArray,NSDictionary,NSSet等.,所以React也是不可以修改其内容和属性的.那么到目前为止我们应该怎样去更新这个元素啦?<br>就是通过创建一个新的元素然后重新渲染到界面上.(is only,not is only)只是针对目前知识浅薄而已.后面应该会有办法更新的,后面我们一起学到了再说.<br>说到这里就举一个例子吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let tick = () =&gt; &#123;</span><br><span class="line">const element = (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">hello world</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">Is is Time &#123;new Date().toLocaleString()&#125;.</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">element,</span><br><span class="line">document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">setInterval(tick,1000);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">const element = (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">hello world</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">Is is Time &#123;new Date().toLocaleString()&#125;.</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">element,</span><br><span class="line">document.getElementById(&apos;root&apos;)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中我们通过定时器不断的调用ReactDom的render函数来更新h2这个标签的内容.效果大家可以自己在自己代码中尝试一下(两端代码都可以,一个是箭头函数,一个是常规的js),并且使用检查来观察h2的变化.</p><p>重点:在实际项目中render函数只会被调用一次.这次只是为了在目前学习到的基础上看到更新的效果才不得已而为之,如果在以后的开发中,你们使用了这样的方式调用render函数,那么你就要考虑代码的设计问题了.</p><h2 id="React只会更新必要的部分"><a href="#React只会更新必要的部分" class="headerlink" title="React只会更新必要的部分"></a>React只会更新必要的部分</h2><p>在开发中又用过数据库的同学应该了解数据库的update操作,当一条记录需要被更新时,他会拿到这条记录的主见然后查找到这条记录,进行字段比对,当有某一个值更新时,才会更新.所以React的更新也是这样的,只会更新发生变化的部分,其他的东西我不会主动更新.</p><p>在上一个例子中,我们使用定时器不断的创建描述整个界面的元素,但是当你使用检查检测时会发现,只有h2在不断变化,其他的都是不会发生变化的.在开发中我们会将界面视为一帧一帧的动画,不是随时变化的.我们在发生更新时只需要更新那一帧动画即可,并不需要将更段动画全部更新.</p><p>在很多时候都是这样的.基本上所有的开发中只关注我们需要更新的内容,其余的内容我们不需要理会.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元素渲染&quot;&gt;&lt;a href=&quot;#元素渲染&quot; class=&quot;headerlink&quot; title=&quot;元素渲染:&quot;&gt;&lt;/a&gt;元素渲染:&lt;/h2&gt;&lt;p&gt;元素是React中的最小单位,是用来描述你再屏幕上所看到的内容.与浏览器的Dom元素不同,ReactDom可以保证浏览器
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage源码阅读(一)</title>
    <link href="http://yoursite.com/2018/10/12/SDWebImage%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/10/12/SDWebImage源码阅读/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:16:29.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDWebImage的目录层级"><a href="#SDWebImage的目录层级" class="headerlink" title="SDWebImage的目录层级"></a>SDWebImage的目录层级</h1><p>都说技术的成长要不断的学习和不断的练习.学习可以有很多方法<br>For example 读书,阅读博客,阅读源代码,还有就是我们观看一些技术讨论会,分享会和开发者大会.而我们今天要讲的是从阅读源码开始.从事iOS开发三年来,有读过源码,但是都不完整.所以我目前的长进还只是停留在某个层面.所以从现在开始养成阅读源码的习惯.但是好的源码有很多,到底该如何入手.那么先从加载图片框架开始!</p><p>我们要阅读一份源码,首先会看到这份源码的层级结构,包含哪些文件根据文件名判断其主要功能和作用.SD目录层级如下:</p><img src="/2018/10/12/SDWebImage源码阅读/sdwebimage.gif" title="This is an image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SDWebImage的目录层级&quot;&gt;&lt;a href=&quot;#SDWebImage的目录层级&quot; class=&quot;headerlink&quot; title=&quot;SDWebImage的目录层级&quot;&gt;&lt;/a&gt;SDWebImage的目录层级&lt;/h1&gt;&lt;p&gt;都说技术的成长要不断的学习和不断的练
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="sdwebimage" scheme="http://yoursite.com/tags/sdwebimage/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习资源</title>
    <link href="http://yoursite.com/2018/10/12/Swift%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%92%8C%E5%A4%A7%E7%A5%9E%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/10/12/Swift学习资源和大神博客/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:17:41.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift学习资源"><a href="#Swift学习资源" class="headerlink" title="Swift学习资源"></a>Swift学习资源</h1><p>因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含Swift资源也包含Objective-C 资源，博主并没有细分内容还请各位看官见谅。</p><h3 id="视频教程-英文"><a href="#视频教程-英文" class="headerlink" title="视频教程(英文)"></a>视频教程(英文)</h3><ul><li><a href="https://www.lynda.com/search?q=ios" target="_blank" rel="noopener">Lynda</a> Lynda上面iOS和Objective-C的学习资料比较丰富，从初级到高级都涉及，无论你目前处于什么层次，都有你适合的视频教学。</li><li><a href="https://www.udemy.com/courses/development/mobile-apps/learn-objective-c/all-courses/" target="_blank" rel="noopener">Udemy</a> Udemy帮助初学者规划视频学习路线，从新手到高级分的很详尽。</li></ul><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://www.amazon.com/dp/032194206X/ref=cm_sw_r_tw_dp_fWrPub0BGRHJ3" target="_blank" rel="noopener">Objective-C Programming</a> 内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象。</li><li><a href="https://book.douban.com/subject/24538384/" target="_blank" rel="noopener">iOS Programming</a> 这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论</li><li><a href="https://book.douban.com/subject/3688896/" target="_blank" rel="noopener">Cocoa Design Patterns</a> 适合打算深入了解 Cocoa 的人看</li><li><a href="http://cocoadevcentral.com/d/learn_objectivec/" target="_blank" rel="noopener">Learn Objective-C</a> 短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解</li><li><a href="https://www.amazon.cn/dp/B00COG40Y0/ref=cm_sw_r_qz_2_dp_l2OPub0N45R0Q" target="_blank" rel="noopener">Objective-C 基础教程</a> 该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读</li><li><a href="https://www.amazon.cn/dp/B00R43XG9S/ref=cm_sw_r_qz_pi_T2A_jdp_fCPPub0VBF67T" target="_blank" rel="noopener">iOS 开发进阶</a> 该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书作者已经不再推荐本书，因为内容已经比较老了，但是在学习的过程中还是可以翻阅一下的, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读</li><li><a href="https://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321967607" target="_blank" rel="noopener">Programming in Objective-C</a>  Programming in Objective-C   这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细</li><li><a href="https://www.amazon.cn/dp/B00JPVNFKM/ref=cm_sw_r_qz_4_dp_tdPPub14X59PV" target="_blank" rel="noopener">iOS 测试指南</a> 该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。</li><li><a href="https://book.douban.com/subject/6920082/" target="_blank" rel="noopener">Objective-C 编程之道</a> 解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读</li><li><a href="https://www.amazon.cn/dp/B00DE60G3S/ref=cm_sw_r_qz_2_dp_hdPPub11MFE6G" target="_blank" rel="noopener">Objective-C 高级编程</a> 本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读</li><li><a href="https://www.amazon.cn/dp/B00IDSGY06/ref=cm_sw_r_qz_2_dp_A2OPub0CH96YH" target="_blank" rel="noopener">Effective Objective C 2.0</a> 书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用</li><li><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html" target="_blank" rel="noopener">The Swift Programming Language 中文版</a> 学习Swift基础的中文文档，目前更新到Swift3.0文档</li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul><li><a href="https://onevcat.com/#blog" target="_blank" rel="noopener">OneV’s Den</a></li><li><a href="http://blog.devtang.com/" target="_blank" rel="noopener">唐巧的技术博客</a></li><li><a href="https://blog.ibireme.com" target="_blank" rel="noopener">ibireme</a></li><li><a href="http://blog.cnbang.net" target="_blank" rel="noopener">bang</a></li><li><a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">孙源的技术博客</a></li><li><a href="http://beyondvincent.com/" target="_blank" rel="noopener">破船之家</a></li><li><a href="http://nshipster.cn/" target="_blank" rel="noopener">NSHipster</a></li><li><a href="http://limboy.me/" target="_blank" rel="noopener">Limboy 无网不剩</a></li><li><a href="http://zhowkev.in/" target="_blank" rel="noopener">Kevin Blog</a></li><li><a href="https://imtx.me/" target="_blank" rel="noopener">IMTX</a></li><li><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></li><li><a href="http://www.iosxxx.com" target="_blank" rel="noopener">向晨宇的技术博客</a></li><li><a href="http://blog.leichunfeng.com" target="_blank" rel="noopener">雷纯锋的技术博客</a></li><li><a href="http://www.tanhao.me" target="_blank" rel="noopener">老谭笔记</a></li><li><a href="http://www.cnblogs.com/kenshincui/" target="_blank" rel="noopener">Kenshin Cui’s Blog</a></li><li><a href="https://casatwy.com" target="_blank" rel="noopener">Casa Taloyum</a></li><li><a href="http://www.olinone.com" target="_blank" rel="noopener">庞海礁的个人空间</a></li><li><a href="http://tutuge.me" target="_blank" rel="noopener">土土哥的技术blog</a></li><li><a href="http://yulingtianxia.com" target="_blank" rel="noopener">玉令天下的博客</a></li><li><a href="http://www.iiiyu.com" target="_blank" rel="noopener">萧宸宇</a></li><li><a href="http://www.cnblogs.com/biosli" target="_blank" rel="noopener">摇滚诗人</a></li><li><a href="http://foggry.com" target="_blank" rel="noopener">王中周的技术博客</a></li><li><a href="https://blog.nswebfrog.com" target="_blank" rel="noopener">Blog | nswebfrog</a></li><li><a href="http://limboy.me" target="_blank" rel="noopener">limboy</a></li></ul><h3 id="社区论坛"><a href="#社区论坛" class="headerlink" title="社区论坛"></a>社区论坛</h3><ul><li><a href="https://objccn.io/" target="_blank" rel="noopener">objc中国</a></li><li><a href="http://www.cocoachina.com/" target="_blank" rel="noopener">cocoachina</a></li><li><a href="https://www.objc.io/" target="_blank" rel="noopener">objc</a></li><li><a href="http://www.code4app.com/" target="_blank" rel="noopener">code4App</a></li><li><a href="http://discuss.cocos2d-x.org/" target="_blank" rel="noopener">Cocos2d-x</a></li><li><a href="http://iphonedevsdk.com/" target="_blank" rel="noopener">iPhone Dev SDK</a></li></ul><h3 id="国内知名程序员开发日报"><a href="#国内知名程序员开发日报" class="headerlink" title="国内知名程序员开发日报"></a>国内知名程序员开发日报</h3><ul><li><a href="https://juejin.im/#/tag/iOS" target="_blank" rel="noopener">掘金</a></li><li><a href="http://geek.csdn.net/" target="_blank" rel="noopener">极客头条</a></li><li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li><li><a href="http://weekly.manong.io/" target="_blank" rel="noopener">码农周刊</a></li><li><a href="http://top.jobbole.com/" target="_blank" rel="noopener">伯乐头条</a></li><li><a href="https://segmentfault.com/" target="_blank" rel="noopener">segmentfault</a></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift学习资源&quot;&gt;&lt;a href=&quot;#Swift学习资源&quot; class=&quot;headerlink&quot; title=&quot;Swift学习资源&quot;&gt;&lt;/a&gt;Swift学习资源&lt;/h1&gt;&lt;p&gt;因为iOS的开发者Objective-C和Swift不分家，所以下面的有关资源既包含
      
    
    </summary>
    
      <category term="资源" scheme="http://yoursite.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Architectures</title>
    <link href="http://yoursite.com/2018/10/12/Xcode%E4%B9%8BArchitectures%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/12/Xcode之Architectures设置/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:19:09.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode设置项之Architectures和Valid-Architectures"><a href="#Xcode设置项之Architectures和Valid-Architectures" class="headerlink" title="Xcode设置项之Architectures和Valid Architectures"></a>Xcode设置项之Architectures和Valid Architectures</h1><p>为什么会聊到这个话题,我今天早上刚到公司,说我们App晚上要发版,但是我周六对电脑的Xcode中的缓存文件进行了大规模的清理.然后打开项目跑代码的时候,发现怎么运行不起来了,一直报错library not found for -lafnetworking<br>然后我开始不断的尝试各种方法,最终还是没有解决,大约在14年左右吧,这个项目当时还是使用cocoapods的,最后经过岁月的摧残,当我拿到项目的时候,交接的人说cocoapods不能用,我当时心里就感觉到,这他妈要凉啊.那我导入第三方还要手动拖进去,这也太尴尬了吧.最后我实在忍不住了,就执行了pod install,然后应用程序就有问题了,找到问题-&gt;修改问题-&gt;测试-&gt;成功-&gt;倍儿爽!.但是这次我不知道为什么前几天还好好的工程,为什么在我删除Xcode的一些过大文件后就报错了啦.原因目前可能是将某个配置文件删除了,重新编译的过程中,使用了一个有问题的编译配置.知道是配置的问题,那就开始找问题,我找到以前的代码对比配置,尤其是pod的配置,因为错误很明显afnetworking.我发现在Build Active Architecture only这里以前Debug和Release都是No,但是现在却是Yes,当我改成No之后编译就成功了,虽然可能会在调试的时候编译会慢,但是问题还得慢慢找,先解决发版在说.虽然很懵逼,但是很开心.终于可以赶上发版了.要是出问题了,就又得加班了,关键是这个周末我没有休息,来公司做其他项目了.眼睛也不知道为什么会肿.所以看到问题就很难受.言归正传</p><p>介绍上面的两个名词</p><h1 id="Valid-Architectures"><a href="#Valid-Architectures" class="headerlink" title="Valid Architectures"></a>Valid Architectures</h1><p>您的App需要支持的指令集,最终生成的二进制文件所支持的指令集</p><p>如果你设置Valid Architectures支出armv7/armv7s/arm64,<br>Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。<br>到底armv7什么含义可以自己去看一下,简单的理解就是arm处理器的指令集,也就是你支持设备版本.</p><h1 id="Build-Active-Architecture-Only"><a href="#Build-Active-Architecture-Only" class="headerlink" title="Build Active Architecture Only"></a>Build Active Architecture Only</h1><p>该编译项用于设置是否只编译当前使用的设备对应的arm指令集。<br>就是你用什么设备调试,就是用对应的指令集去进行编译.<br>当该选项设置成YES时，你连上一个armv7指令集的设备，就算你的Valid Architectures和Architectures都设置成armv7/armv7s/arm64，还是依然只会生成一个armv7指令集的二进制包.<br>当选择NO,那就是你设置了几种,它就会编译几种,最终产生的二进制文件较大,而且编译过程会慢.</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ul><li>指令集都是可以向下兼容的</li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>如果你想较小包的大小,就可以设置这个来减少编译不同指令的包.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xcode设置项之Architectures和Valid-Architectures&quot;&gt;&lt;a href=&quot;#Xcode设置项之Architectures和Valid-Architectures&quot; class=&quot;headerlink&quot; title=&quot;Xcode设置项
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode常用命令</title>
    <link href="http://yoursite.com/2018/10/12/Xcode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/10/12/Xcode调试技巧和常用快捷键/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:18:22.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode常用命令"><a href="#Xcode常用命令" class="headerlink" title="Xcode常用命令"></a>Xcode常用命令</h1><p>p :常用来输出基础数据类型</p><p>po :常用来输出oc对象类型</p><p>expr :可以在调试时动态的执行表达式，同时打印出结果。常用来动态修改变量的值。</p><p>call :常用来动态调用函数</p><p>image: image命令可以列出当前App中的所有模块</p><p>po [view recursiveDescription] 查看view的层级关系</p><h1 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h1><p>shift+command+o :快速打开文件</p><p>Command+1~9:导航面版切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xcode常用命令&quot;&gt;&lt;a href=&quot;#Xcode常用命令&quot; class=&quot;headerlink&quot; title=&quot;Xcode常用命令&quot;&gt;&lt;/a&gt;Xcode常用命令&lt;/h1&gt;&lt;p&gt;p :常用来输出基础数据类型&lt;/p&gt;
&lt;p&gt;po :常用来输出oc对象类型&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="常用命令" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>版本控制</title>
    <link href="http://yoursite.com/2018/10/12/git%E4%BB%8E0%E5%88%B01/"/>
    <id>http://yoursite.com/2018/10/12/git从0到1/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:04:37.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h1><p>版本控制是帮助我们记录文件内容发生变化,方便后面查阅每个版本不同的修订情况.还可以通过版本控制回溯到某个版本的状态.还可以比较文件的变化细节.</p><p>集中化的版本控制系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于版本控制&quot;&gt;&lt;a href=&quot;#关于版本控制&quot; class=&quot;headerlink&quot; title=&quot;关于版本控制&quot;&gt;&lt;/a&gt;关于版本控制&lt;/h1&gt;&lt;p&gt;版本控制是帮助我们记录文件内容发生变化,方便后面查阅每个版本不同的修订情况.还可以通过版本控制回溯到某个版本
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本控制" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用攻防实战(一)</title>
    <link href="http://yoursite.com/2018/10/12/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/10/12/iOS应用安全攻防实战/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:10:32.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="误解1-认证因为这设备是安全可信任的"><a href="#误解1-认证因为这设备是安全可信任的" class="headerlink" title="误解1: 认证因为这设备是安全可信任的"></a>误解1: 认证因为这设备是安全可信任的</h1><p>设备和产品的认证,只是认证机构对于设备和产品的概念性功能和实现能力的合规性认证,在认证的过程中并没有对设备和产品进行渗透性测试.并不能保证设备和程序不被黑客攻破.</p><h1 id="误解2-单一性安全机制"><a href="#误解2-单一性安全机制" class="headerlink" title="误解2: 单一性安全机制"></a>误解2: 单一性安全机制</h1><p>单一性安全机制的问题,就存在与单一性上,他简化了攻破所需要分析的代码.如果一旦单一的安全机制被攻破,所有基于这个单一安全机制的设备和程序都将被攻破.</p><h1 id="iOS安全模型"><a href="#iOS安全模型" class="headerlink" title="iOS安全模型"></a>iOS安全模型</h1><p>1.设备安全:防止未授权的人使用设备</p><p>2.数据安全:存储在设备上的数据得到保护</p><p>3.网络安全:当通过网络传输时的加密工具</p><p>4.应用软件安全:加固操作系统并隔离运行时应用软件的机制</p><h1 id="设备安全"><a href="#设备安全" class="headerlink" title="设备安全"></a>设备安全</h1><p>对于设备安全,苹果做出的应对是设置密码和PIN锁.苹果允许企业在安全策略中强制设置这些锁,或个人用户手动设置.</p><h1 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h1><p>苹果的数据加密是很值得一提的,采用硬件加密加速器来加密选定的应用软件数据.通过将这些存储在设备上的特定加密密钥与用户设置的密码结合,该系统可以保证只有在用户输入密码后文件系统中这些被保护的文件才会解密.所以用户输入的密码的安全性就是关键.所以密码的复杂度就决定破解的难度.</p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p>苹果使用了很多方法来加密网络包括VPN,SSL,TLS传输层协议,WEP,WPA,WPA2无线网络加密和认证,和2017年一月份提出的HTTPS强制要求都是为了网络安全.</p><h1 id="应用软件的安全"><a href="#应用软件的安全" class="headerlink" title="应用软件的安全"></a>应用软件的安全</h1><p>应用软件的安全,完全依赖于苹果的沙盒技术.拼过系统将自身可被访问的API作为接口放出.应用软件本身不可以访问系统组件,和其他应用软件.沙盒机制限制了一个应用的内存和CPU使用的总量,当超出限制时,出现崩溃闪退现象.他只可以对自己文件目录访问.</p><p>为了限制应用软件访问设备资源,苹果使用代码签名的方式,所有运行在设备上的二进制代码,必须经过苹果签名或者使用苹果办法的证书签名.这样做可以保证自身无法修改二进制文件.苹果也可以检测其应用软件的完整性.确保没有被签名的代码注入.</p><p>钥匙串技术,可以将一些网络凭证,其他信息保存在钥匙串中,还提供了低级别的加密解密方法.</p><p>苹果还提供了基础的加密解密算法(common crypto),开发者可以使用加密算法,对数据机型加密.</p><h1 id="误解三-iOS文件系统加密可以防止设备上的数据失窃-直到iOS5"><a href="#误解三-iOS文件系统加密可以防止设备上的数据失窃-直到iOS5" class="headerlink" title="误解三:iOS文件系统加密可以防止设备上的数据失窃(直到iOS5)"></a>误解三:iOS文件系统加密可以防止设备上的数据失窃(直到iOS5)</h1><p>iOS的文件系统加密使用了将秘钥he数据存储在同一设备上的加密系统(直到iOS5)攻击者只需要活的在设备上执行代码的权限,就可以计算出密钥来破解数据.密钥是数字形态的,谁拥有设备的数字拥有权,谁就能同时拿到锁和钥匙</p><h1 id="密码等于弱安全"><a href="#密码等于弱安全" class="headerlink" title="密码等于弱安全"></a>密码等于弱安全</h1><p>相比于PC，移动设备的安全性和用户体验之间的取舍就很严重了。<br>举一个例子：我们在使用完手机后，时不时会把放进口袋里。每一次使用手机都要进行解锁。所以手机厂商在设计这个安全锁时，就必须考虑密码的简单性。要不然用户体验就会很差（vicky_12@.qq.com）。这样的密码在pc上输入还可以，在每次解锁手机屏幕时，用户可能会取消这个设备锁。因为太过于麻烦。所以厂商的设计一般都是某种图形或者是4位或者6位数字。所以密码是弱安全。</p><h1 id="误解四：关心安全的用户会设置复杂的密码"><a href="#误解四：关心安全的用户会设置复杂的密码" class="headerlink" title="误解四：关心安全的用户会设置复杂的密码"></a>误解四：关心安全的用户会设置复杂的密码</h1><p>大多数用户任然选择PIN码和简单的密码保护自己的设备。这样做是因为他们不知道密码的复杂度与设备加密强度的关系。他们自认为，我设置密码就可以赶跑那些坏人。如果坏人足够坏，你设置的密码是远远不够的。所以假设你的用户一般都只会使用简单PIN码和密码来保护设备。</p><h1 id="误解五：强密码依然不能保证设备安全"><a href="#误解五：强密码依然不能保证设备安全" class="headerlink" title="误解五：强密码依然不能保证设备安全"></a>误解五：强密码依然不能保证设备安全</h1><p>我们所指出的强弱密码并不能完全保证你设备的安全，因为在强的东西也有破绽，只是击破它的复杂度上升了，并没有说完全安全性。在互联网方面，没有完全的安全。</p><h1 id="数字取证击败加密"><a href="#数字取证击败加密" class="headerlink" title="数字取证击败加密"></a>数字取证击败加密</h1><p>可能你编写的代码是很安全的，你的应用软件是很安全的。按时操作系统会不断削减你的安全性。操作系统会不断缓存你所产生的操作（键盘操作）web缓存。文件操作等。操作系统都可以缓存到磁盘中。而且操作系统还可以恢复你删除掉的私密文件。私密文件的加密秘钥只要还存在，私密文件就可能被恢复。而且更加恐怖的是连私密文件的密钥都可以被恢复。</p><h1 id="误解六：-如果应用软件安全的实现了加密，数据就无法从设备中被恢复"><a href="#误解六：-如果应用软件安全的实现了加密，数据就无法从设备中被恢复" class="headerlink" title="误解六： 如果应用软件安全的实现了加密，数据就无法从设备中被恢复"></a>误解六： 如果应用软件安全的实现了加密，数据就无法从设备中被恢复</h1><p>首先你错了。上面已经说过了操作系统会不断削弱你的安全性，会缓存你的操作和文件。就连你私密文件的密钥都能操作，你还认为应用软件安全吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;误解1-认证因为这设备是安全可信任的&quot;&gt;&lt;a href=&quot;#误解1-认证因为这设备是安全可信任的&quot; class=&quot;headerlink&quot; title=&quot;误解1: 认证因为这设备是安全可信任的&quot;&gt;&lt;/a&gt;误解1: 认证因为这设备是安全可信任的&lt;/h1&gt;&lt;p&gt;设备和产
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="攻防" scheme="http://yoursite.com/tags/%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>instrument使用</title>
    <link href="http://yoursite.com/2018/10/12/instrument%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/12/instrument的使用/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:08:15.489Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="内存分析" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    
      <category term="时间复杂度分析" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
      <category term="CPU占用分析" scheme="http://yoursite.com/tags/CPU%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发小记</title>
    <link href="http://yoursite.com/2018/10/12/iOS%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/12/iOS开发小记/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:08:36.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS&quot;&gt;&lt;a href=&quot;#iOS&quot; class=&quot;headerlink&quot; title=&quot;iOS&quot;&gt;&lt;/a&gt;iOS&lt;/h1&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS内存分析(一)</title>
    <link href="http://yoursite.com/2018/10/12/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/12/iOS内存管理/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-17T02:35:01.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><h2 id="1-1-什么是自动引用计数"><a href="#1-1-什么是自动引用计数" class="headerlink" title="1.1 什么是自动引用计数"></a>1.1 什么是自动引用计数</h2><p>自动引用计数就是指在内存管理上不需要程序员再次键入retain和release等内存管理语句.而是由系统自动对引用进行计数</p><p>目前我们所创建的项目都是ARC的,它不仅减少了程序员的开发工作,而且也降低了程序的崩溃,内存泄漏等风险.</p><h2 id="1-2内存管理-引用计数"><a href="#1-2内存管理-引用计数" class="headerlink" title="1.2内存管理/引用计数"></a>1.2内存管理/引用计数</h2><h3 id="1-2-1-概要"><a href="#1-2-1-概要" class="headerlink" title="1.2.1 概要"></a>1.2.1 概要</h3><p>书中的举例非常经典,利用办公室开关灯的实际情况对内存管理进行了详细的分析.</p><ul><li>当第一个人进入办公室时需要照明,所以开灯 (引用计数1)</li><li>当第二个人进入办公室时也需要照明,持有对象 (引用计数2)</li><li>当第一个人离开办公室时不需要照明,但是别人还需要照明,所以不能关闭灯,只能释放自己的持有 (引用计数1)</li><li>当最后一个人离开时,不需要灯光了,然后关闭灯光,释放自己持有.对象释放 (引用计数0)</li></ul><h2 id="1-2-2-内存管理的思考方式"><a href="#1-2-2-内存管理的思考方式" class="headerlink" title="1.2.2 内存管理的思考方式"></a>1.2.2 内存管理的思考方式</h2><ul><li>自己生成的对象,自己持有</li><li>非自己生成的对象,自己也能持有</li><li>不在需要自己持有的对象时,需要自己释放</li><li>不能释放自己不持有的对象</li></ul><table><tr><th>对象操作</th><th>Objective-C方法</th></tr><tr><th>生成并持有对象</th><th>alloc/new/copy/mutableCopy等</th></tr><tr><th>持有对象</th><th>retain</th></tr><tr><th>释放对象</th><th>release</th></tr><tr><th>废弃对象</th><th>dealloc</th></tr></table><h3 id="自己生成并持有对象"><a href="#自己生成并持有对象" class="headerlink" title="自己生成并持有对象"></a>自己生成并持有对象</h3><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 自己生成并持有对象</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">* 自己持有对象</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>alloc方法生成的对象自己持有(自己生成并持有对象),并将指向生成持有对象的指针赋给了变量obj.new方法与alloc方法完全一致,copy和mutableCopy方法基于NSCopying和NSMutableCopying协议约定,利用copyWithZ    one:方法生成并持有对象的副本</p><p>##1.2.3 alloc的调用过程</p><p>1.首先调用NSObject的alloc方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.调用_objc_rootAlloc()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.调用了callAlloc()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">//判断是否为Nil和cls是否存在,不存在直接返回</span><br><span class="line">    if (checkNil &amp;&amp; !cls) return nil;</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">//判断是否自定义实现的allocwithzone方法</span><br><span class="line">    if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123;</span><br><span class="line">        // No alloc/allocWithZone implementation. Go straight to the allocator.</span><br><span class="line">        // fixme store hasCustomAWZ in the non-meta class and </span><br><span class="line">        // add it to canAllocFast&apos;s summary</span><br><span class="line">        //还需要再次判断当前的class是否支持快速alloc。如果支持，直接调用calloc函数，申请</span><br><span class="line">        bits.fastInstanceSize()大小的内存空间，如果创建失败，会调用callBadAllocHandler函数，如</span><br><span class="line">        果不支持快速alloc则调用class_createInstance</span><br><span class="line">        if (cls-&gt;canAllocFast()) &#123;</span><br><span class="line">            // No ctors, raw isa, etc. Go straight to the metal.</span><br><span class="line">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            if (!obj) return callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Has ctor or raw isa or something. Use the slower path.</span><br><span class="line">            id obj = class_createInstance(cls, 0);</span><br><span class="line">            if (!obj) return callBadAllocHandler(cls);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    if (allocWithZone) return [cls allocWithZone:nil];</span><br><span class="line">    return [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.调用allocWithZone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.调用_objc_rootAllocWithZone()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)</span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line">#if __OBJC2__ //如果是oc代码使用class_createInstance()</span><br><span class="line">    // allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    (void)zone;</span><br><span class="line">    obj = class_createInstance(cls, 0);</span><br><span class="line">#else</span><br><span class="line">//如果不存在zone或者是使用了GC使用class_createInstance(),如果不是使用class_createInstanceFromZone()</span><br><span class="line">    if (!zone || UseGC) &#123;</span><br><span class="line">        obj = class_createInstance(cls, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        obj = class_createInstanceFromZone(cls, 0, zone);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (!obj) obj = callBadAllocHandler(cls);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.调用class_createInstance()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.调用_class_createInstanceFromZone()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct = true, </span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">//cls是否存在</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">//判断该类是否已经做过realize,realize主要是一些数据的拷贝和整理对齐。???(具体做什么)</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    // Read class&apos;s info bits all at once for performance</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    判断是否支持hasCxxCtor 和 hasCxxDtor还有canAllocNonpointer，hasCxxCtor 和 hasCxxDtor是对</span><br><span class="line">     Objective-C++ 的支持，表示这个类是否有 C++ 类构造函数和析构函数，如果有的话，需要进行额外的工</span><br><span class="line">     作。canAllocNonpointer我们不用太关心，这里OC 2.0以上基本上返回的都是true。</span><br><span class="line">    */</span><br><span class="line">    bool hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast = cls-&gt;canAllocIndexed();</span><br><span class="line"></span><br><span class="line">//计算instance大小</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    //if outAllocatedSize存在 *outAllocatedSize的大小 = size</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    //如果不是用gc,不存在zone,???</span><br><span class="line">    if (!UseGC  &amp;&amp;  !zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    //分配objc内存大小</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        //如果obj不存在,return nil</span><br><span class="line">        </span><br><span class="line">        if (!obj) return nil;</span><br><span class="line">        //初始化函数</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">#if SUPPORT_GC</span><br><span class="line">        if (UseGC) &#123;</span><br><span class="line">            obj = (id)auto_zone_allocate_object(gc_zone, size,</span><br><span class="line">                                                AUTO_OBJECT_SCANNED, 0, 1);</span><br><span class="line">        &#125; else </span><br><span class="line">#endif</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">        // Use non-indexed isa on the assumption that they might be </span><br><span class="line">        // doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 不懂</span><br><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道alloc的作用是开辟足够的内存空间,并<b style="color:red">初始化</b>.然后使obj指针指向对象的内存地址</p><p>##1.2.4 initInstanceIsa与init</p><h3 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);//是否使用GC</span><br><span class="line">    assert(!cls-&gt;requiresRawIsa());//是否具有原始的isa</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());//是否有析构函数</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">//非TaggedPointer</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    if (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    </span><br><span class="line">        assert(!DisableIndexedIsa);</span><br><span class="line">        //设置bits的值为define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.indexed is part of ISA_MAGIC_VALUE</span><br><span class="line">        //设置isa构造韩式</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        </span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到initInstanceIsa与isa有巨大关系和对象本身没有多大关系,所以上面的韩式是初始化isa的操作</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // In practice, it will be hard to rely on this function.</span><br><span class="line">    // Many classes do not properly chain -init calls.</span><br><span class="line">    //返回对象本身</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当我们不自定义实现init方法时,系统默认只是返回对象本身,我们可以再自定义的init方法中设置属性的值</p><p>##1.2.5 非自己生成的对象,自己也能持有</p><p>在我们学习OC的时候我们只有对象的生成方法有两种,一种是使用alloc方法,还有一种是使用便利构造器也就是常见的例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj = [NSArray array];</span><br></pre></td></tr></table></figure><p>分析:<br>这个对象是由自己生成,但并非自己持有.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)array &#123; </span><br><span class="line"> __autoreleasing NSArray *array = [[NSArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    return array;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面第一条自己生成并持有.我们可以得到array只是将自己生成并持有对象的指针赋给了array变量.我们拿到的只是这个变量指针.</p><p>那么如何取得这个对象的所有权啦???<em>**</em></p><p>然后就用到了retain方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [NSArray array];</span><br><span class="line"></span><br><span class="line">[obj retain];</span><br></pre></td></tr></table></figure><p>通过retain函数持有非自己生成对象</p><h4 id="retain方法调用过程"><a href="#retain方法调用过程" class="headerlink" title="retain方法调用过程"></a>retain方法调用过程</h4><p>我们通过查询runtime源代码可以找到retain的调用顺序<br>1.首先是NSObject的retain方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)retain &#123;</span><br><span class="line">    return ((id)self)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在retain方法内部调用了rootRetain()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootRetain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">//判断当前的obj对象是否为空</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在rootRetain方法内部调用了objc_object::rootRetain()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);</span><br><span class="line">    //如果是TaggedPointer直接返回对象本身</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    //如果不是调用sidetable_retain()</span><br><span class="line">    return sidetable_retain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.调用sidetable_retain()函数,首先获取对象的引用技术管理结构体SideTable,在SideTable中有三个重要的成员(spinlock_t slock,RefcountMap refcnts,weak_table_t weak_table).其中引用计数是保存到refcnts.weak_table弱引用表.第一个是一个自旋锁,保证在多线程中操作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看引用计数每次加SIDE_TABLE_RC_ONE到底是什么东西?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span><br><span class="line">#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  // MSB-ward of weak bit</span><br><span class="line">#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  // MSB-ward of deallocating bit</span><br><span class="line">#define SIDE_TABLE_RC_PINNED         (1UL&lt;WORD_BITS-1))</span><br><span class="line"></span><br><span class="line">#define SIDE_TABLE_RC_SHIFT 2</span><br><span class="line">#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span><br></pre></td></tr></table></figure><p>这里使用了一个位操作,在二进制下将1向左移动2位,就是100.然后100代表的数字是4.所以实际上retain加的引用计数是4.<br>SIDE_TABLE_WEAKLY_REFERENCED （内存的第1位）标识该对象是否有过weak对象；<br>SIDE_TABLE_DEALLOCATING（内存的第2位），标识该对象是否正在dealloc。<br>SIDE_TABLE_RC_ONE （内存的第3位），存放引用计数数值（三位之后都用来存放引用计数数值）。<br>SIDE_TABLE_RC_PINNED, 标识引用计数的溢出<br>所以每次我们引用计数加一时，真正加的是4,在取出真正的引用计数时需要右移两位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        // this is valid for SIDE_TABLE_RC_PINNED too</span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码的代码可以看出refcnt_result+=引用计数总计.而refcnt_result = 1.所以我们访问时都是1而不是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.indexed);</span><br><span class="line">#endif</span><br><span class="line">//获取管理引用计数的结构体SideTable</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    if (table.trylock()) &#123;</span><br><span class="line">    //获取当前对象的引用计数散列表,使用散列表可以将对象持有者的内存地址和引用计数保存在散列表中.就算在出现异常情况时,也能定位到地址信息</span><br><span class="line">        size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">        //判断当前的引用计数是否越界</span><br><span class="line">        if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        //如果引用计数没有越界,引用计数加1</span><br><span class="line">            refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">        &#125;</span><br><span class="line">        table.unlock();</span><br><span class="line">        return (id)this;</span><br><span class="line">    &#125;</span><br><span class="line">    return sidetable_retain_slow(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.调用sidetable_retain_slow()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain_slow(SideTable&amp; table)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.indexed);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也是引用计数进行加一的一个函数</p><p>上面的所有的过程就是在我们调用retain的函数调用过程.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动引用计数&quot;&gt;&lt;a href=&quot;#自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;自动引用计数&quot;&gt;&lt;/a&gt;自动引用计数&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是自动引用计数&quot;&gt;&lt;a href=&quot;#1-1-什么是自动引用计数&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="引用计数" scheme="http://yoursite.com/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="alloc/new/copy/mutableCopy" scheme="http://yoursite.com/tags/alloc-new-copy-mutableCopy/"/>
    
      <category term="retain" scheme="http://yoursite.com/tags/retain/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2018/10/12/mysql%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/10/12/mysql安装/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:11:38.811Z</updated>
    
    <content type="html"><![CDATA[<p>mac 安装mysql</p><p>1.安装<a href="http://blog.vicky.org.cn/2018/02/24/HomeBrew与Ruby更新/" target="_blank" rel="noopener">homebrew</a></p><p>2.brew uninstall mysql</p><p>3.brew install mysql</p><p>4.mysql -u root -p</p><p>5.如果出现报错执行</p><p><code>unset TMPDIR</code></p><p><code>bash mysql_install_db --verbose --user=root --basedir=&quot;$(brew --prefix mysql)&quot;--datadir=/usr/local/var/mysql --tmpdir=/tmp</code></p><p><code>bash mysql.server start</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac 安装mysql&lt;/p&gt;
&lt;p&gt;1.安装&lt;a href=&quot;http://blog.vicky.org.cn/2018/02/24/HomeBrew与Ruby更新/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;homebrew&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="使用" scheme="http://yoursite.com/tags/%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>React(一)</title>
    <link href="http://yoursite.com/2018/10/12/react%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
    <id>http://yoursite.com/2018/10/12/react第一节/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:14:58.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置React开发环境"><a href="#配置React开发环境" class="headerlink" title="配置React开发环境"></a>配置React开发环境</h2><p>我们选择使用HomeBrew来安装node</p><ul><li>安装homebrew</li></ul><pre><code class="Ruby">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></code></pre><ul><li>更新brew</li></ul><pre><code class="Ruby">brew update</code></pre><ul><li>配置环境变量</li></ul><pre><code class="Ruby">vim ./bash.profileexport PATH=<span class="string">"/usr/local/bin:$PATH"</span>esc,shift+wq退出并保存</code></pre><ul><li>为了保证你的环境中没有node的参与文件,可以通过以下命令完全删除node</li></ul><pre><code class="sudo">sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}</code></pre><ul><li>安装node</li></ul><pre><code class="node">brew link nodebrew uninstall nodebrew install node</code></pre><ul><li>测试安装是否成功</li></ul><pre><code class="node">npm install -g grunt-cli</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><pre><code class="mkdir">mkdir react-democd react-demonpm install -g create-react-appcreate-react-app my-appcd my-appnpm start</code></pre><p>这样就可以看到运行起来的react项目</p><h2 id="修改项目"><a href="#修改项目" class="headerlink" title="修改项目"></a>修改项目</h2><p>删除APP.js,App.css,App.test.js,index.css,logo.svg,registerServiceWorker.js 文件<br>修改index.js文件</p><pre><code class="react">import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;ReactDOM.render(    &lt;h1&gt;Hello world&lt;/h1&gt;,     document.getElementById(&apos;root&apos;));npm start 运行</code></pre><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>上面的这段代码会渲染一个id叫做root的dom元素,所以在index.html中我们会看到</p><pre><code class="react">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></pre><p>因为我是iOS的开发工作者,我的理解是,html文件向我们提供了一个父视图View也就是这里的div,然后我们根据设置这个View的id来让外界访问.然后在index.js文件中我们创建了一个子视图,并添加到div这个父视图上.就显示到了html页面上.</p><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><p>本人从未开发过react项目一切都是从零开始,选择编辑器开发react的工具有很多,有IDEA,WebStrom,SublimeText等.具体安装什么插件,网上都有教程,这里不做详细说明,可以按照个人喜好安装.</p><p>我选择是idea来编辑项目,因为公司的前端小伙伴都是使用这个编辑器,方便学习和交流,我也推荐大家按照公司小伙伴的喜好来使用编辑器,这样有什么不懂的更方便询问和学习.</p><h2 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h2><p>我对jsx    的理解就是JavaScript + XML组成JSX<br>第一步使用JSX语法修改刚才的项目</p><pre><code class="react">const element = &lt;h1&gt;Hello world!&lt;/h1&gt;;ReactDOM.render(    element,    document.getElementById(&apos;root&apos;));</code></pre><p>第一行的代码看起来既不是字符串也不是html,而他正式这个react的主角:JSX,也就是js的语法扩展,在OC中也有很多语法扩展.说到这里我就说一下iOS中的语法扩展GCC扩展语法,为什么这样写,这样写有什么好处</p><p>优点:<br>1.如果不是通过XIB来定义控件我们经常会看到大量的定义UI界面的代码,如果开发这的代码规范有很大的纰漏,那样我相信你们会很发燥,因为可能要到处找代码,例如这个控件的颜色到底在哪里设置的.但是通过这样的语法我们就可以将代码放在大括号内部,是代码更加清晰整洁.<br>2.如果你看到这样的代码,是不是也会认为这样的代码逼格会高一点啦.</p><pre><code class="Objective-C">UIButton *secondButton = ({        UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];        button.frame = CGRectMake(100, 100, 100, 100);        button;    });</code></pre><p>回到JSX的话题.</p><pre><code class="React">let fommat = (user)=&gt; user.firstName + &apos;&apos; + user.lastName;const  user = {    firstName:&apos;wei&apos;,    lastName:&apos;qi&apos;};const  element = (    &lt;h1&gt;        Hello {fommat(user)}!    &lt;/h1&gt;);ReactDOM.render(    element,    document.getElementById(&apos;root&apos;));</code></pre><p>划重点:第一行代码使用了箭头函数,后面的就是JSX的基础使用</p><p>这次是我学习react的第一课,希望大家多多谅解!如果有志同道合者希望加入我的队列.谢谢!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置React开发环境&quot;&gt;&lt;a href=&quot;#配置React开发环境&quot; class=&quot;headerlink&quot; title=&quot;配置React开发环境&quot;&gt;&lt;/a&gt;配置React开发环境&lt;/h2&gt;&lt;p&gt;我们选择使用HomeBrew来安装node&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
  </entry>
  
  <entry>
    <title>runtime(一)</title>
    <link href="http://yoursite.com/2018/10/12/runtime%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/10/12/runtime（一）/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:15:41.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-runtime是如何通过selector找到对应的IMP地址？"><a href="#iOS-runtime是如何通过selector找到对应的IMP地址？" class="headerlink" title="iOS runtime是如何通过selector找到对应的IMP地址？"></a>iOS runtime是如何通过selector找到对应的IMP地址？</h1><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSString+GetImp.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation NSString (GetImp)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">  IMP imp = class_getMethodImplementation([NSString class], @selector(substringFromIndex:));</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><h1 id="分析类对象的定义"><a href="#分析类对象的定义" class="headerlink" title="分析类对象的定义"></a>分析类对象的定义</h1><p>objc_class的结构体有以下几个成员<br>isa指针指向元类，所有的类方法全部在元类的方法列表中<br>name：类名<br>varsion：版本号<br>info：类信息<br>instance_size：实例的大小<br>objc_ivar_list：成员变量list<br>objc_method_list：实例方法列表<br>objc_cache：缓存<br>objc_protocol_list：协议列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例方法列表中保存的都是objc_method</p><h1 id="分析实例方法"><a href="#分析实例方法" class="headerlink" title="分析实例方法"></a>分析实例方法</h1><p>method_name：方法名称<br>method_types：方法的参数和返回值类型<br>method_imp：方法实现。<br>到目前我们已经看到我们需要的IMP</p><p>那么runtime到底是如何工作的啦。</p><p>1.根据class_getMethodImplementation的第一个参数确定对象类。<br>2.然后根据第二个参数开始进行查找类方法列表和实例方法列表（方法类型）<br>3.遍历实例方法列表寻找与传入的method_name相等的方法，如果找到就返回该方法的实现<br>4.如果没找到就查找父类的方法列表和元类的方法列表，知道查找到根类和根元类的方法列表。如果还没有找到就抛出异常，否则返回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-runtime是如何通过selector找到对应的IMP地址？&quot;&gt;&lt;a href=&quot;#iOS-runtime是如何通过selector找到对应的IMP地址？&quot; class=&quot;headerlink&quot; title=&quot;iOS runtime是如何通过select
      
    
    </summary>
    
      <category term="runtime" scheme="http://yoursite.com/categories/runtime/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 52个方法</title>
    <link href="http://yoursite.com/2018/10/12/52%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/12/52个方法/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T06:21:03.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一条-了解Objective-C的语言的起源"><a href="#第一条-了解Objective-C的语言的起源" class="headerlink" title="第一条:了解Objective-C的语言的起源?"></a>第一条:了解Objective-C的语言的起源?</h1><p>Objective-C和C++、Java 等都是面向对象的语言。但是在面向对象的语言中Objective-C采用的是消息结构语言，而其他的面向语言采用的还是函数调用的方式。消息结构语言来自于SmallTalk。</p><p>消息结构和函数调用的区别</p><p>消息结构决定其运行过程中所需要执行的代码由运行时环境决定，而其他面向对象语言则是由编译器决定。我们都知道 OC 是在运行时才会确定对象类型。而调用方法亦是如此，在运行时才回去查找到底该执行哪个方法。而且在 OC 中接收消息的对象可以为 nil 这是其他面向对象语言所不具有的。其他的语言都会先进行判断。</p><p>OC 作为 C 的超集在很多方面还是沿用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一条-了解Objective-C的语言的起源&quot;&gt;&lt;a href=&quot;#第一条-了解Objective-C的语言的起源&quot; class=&quot;headerlink&quot; title=&quot;第一条:了解Objective-C的语言的起源?&quot;&gt;&lt;/a&gt;第一条:了解Objective-
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="52个方法" scheme="http://yoursite.com/tags/52%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三个ImageView实现无限轮播</title>
    <link href="http://yoursite.com/2018/10/12/%E4%B8%89%E4%B8%AAImageView%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%92%8C%E4%B8%89%E4%B8%AALabel%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%91%8A/"/>
    <id>http://yoursite.com/2018/10/12/三个ImageView实现无限轮播和三个Label实现公告/</id>
    <published>2018-10-12T02:22:10.000Z</published>
    <updated>2018-10-12T03:02:09.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三个ImageView实现无限轮播"><a href="#三个ImageView实现无限轮播" class="headerlink" title="三个ImageView实现无限轮播"></a>三个ImageView实现无限轮播</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>scrollView上添加三张ImageView,分别为left,center,right</li><li>初始化scrollview时设置contentOffset为中间这张图片的位置</li><li>添加定时器,设置定时器事件,当前页+1,然后在动画过渡到第三张图片的位置,在动画结束后,进行复位操作.left的image = center.image,center.image = right.imgae, 然后设置contentOffset = center.right.image = 获取下一张图片</li></ol><p>代码实现如下</p><p>初始化scrollview</p><pre><code>let scrollview = UIScrollView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height))scrollview.contentSize = CGSize(width: self.frame.size.width * 3, height: 0)scrollview.isPagingEnabled = truescrollview.bounces = falsescrollview.showsVerticalScrollIndicator = falsescrollview.showsHorizontalScrollIndicator = falsescrollview.delegate = self</code></pre><p>初始化timer</p><pre><code>timer = Timer(timeInterval: TimeInterval(scrollInterval), target: self, selector: #selector(timerAction), userInfo: nil, repeats: true)RunLoop.current.add(timer!, forMode: .commonModes)</code></pre><p>初始化</p><pre><code>leftImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: self.frame.size.height))centerImageView = UIImageView(frame: CGRect(x: self.frame.size.width * 1, y: 0, width: self.frame.size.width, height: self.frame.size.height))rightImageView = UIImageView(frame:CGRect(x: self.frame.size.width * 2, y: 0, width: self.frame.size.width, height: self.frame.size.height))leftImageView?.kf.setImage(with: ImageResource(downloadURL: getBeforeImageUrl(index: self.currentPage)))centerImageView?.kf.setImage(with: ImageResource(downloadURL: getImageUrl(index: self.currentPage)!))rightImageView?.kf.setImage(with: ImageResource(downloadURL: getAfterImageUrl(index: self.currentPage)))</code></pre><p> Timer事件</p><pre><code> currentPage = currentPage + 1if currentPage == imageArray.count {  currentPage = 0}UIView.animate(withDuration: animationInterval, animations: {  self.centerImageView?.isUserInteractionEnabled = false  self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 2, y: 0)}) { (finish) in  self.centerImageView?.isUserInteractionEnabled = true  self.leftImageView?.image = self.centerImageView?.image  self.centerImageView?.image = self.rightImageView?.image  self.scrollView?.contentOffset = CGPoint(x: self.frame.size.width * 1, y: 0)  self.rightImageView?.kf.setImage(with: ImageResource(downloadURL: self.getAfterImageUrl(index: self.currentPage)))  self.pageController?.currentPage = self.currentPage}</code></pre><p>主要代码如上,主要是理解思路.</p><h1 id="三个Label实现公告"><a href="#三个Label实现公告" class="headerlink" title="三个Label实现公告"></a>三个Label实现公告</h1><p>这个和上面的思路一致,只不过是横向换成竖向.代码就不贴了.如果对这个感兴趣,可以私聊我.我可以发代码给你.或者把代码放到git上.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三个ImageView实现无限轮播&quot;&gt;&lt;a href=&quot;#三个ImageView实现无限轮播&quot; class=&quot;headerlink&quot; title=&quot;三个ImageView实现无限轮播&quot;&gt;&lt;/a&gt;三个ImageView实现无限轮播&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="轮播" scheme="http://yoursite.com/tags/%E8%BD%AE%E6%92%AD/"/>
    
  </entry>
  
</feed>
